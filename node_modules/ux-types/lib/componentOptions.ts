import { ComponentBuildinType, CreateComponentPublicInstance } from './componentPublicInstance';
import { ComponentObjectPropsOptions, ExtractPropTypes } from './props';
import { ProjectType } from './shared';

export declare type ComputedGetter<T> = (...args: any[]) => T;
export declare type ComputedSetter<T> = (v: T) => void;
export declare interface WritableComputedOptions<T> {
	get: ComputedGetter<T>;
	set: ComputedSetter<T>;
}

export type ComputedOptions = Record<string, ComputedGetter<any> | WritableComputedOptions<any>>;
export interface MethodOptions {
	[key: string]: Function;
}

export type ExtractComputedReturns<T extends any> = {
	[key in keyof T]: T[key] extends { get: (...args: any[]) => infer TReturn }
		? TReturn
		: T[key] extends (...args: any[]) => infer TReturn
		? TReturn
		: never;
};

export type ComponentOptionsWithNoProps<
	Props = {},
	Private = {},
	Protected = {},
	Public = {},
	D = {},
	C extends ComputedOptions = {},
	O = {},
	T extends ProjectType = 'quickapp'
> = ComponentOptionsBase<Private, Protected, Public, D, C, O> & { props?: undefined } & ThisType<
		CreateComponentPublicInstance<Props, Private, Protected, Public, D, C, O, T>
	>;

export type ComponentOptionsWithArrayProps<
	PropsNames extends string = string,
	Private = {},
	Protected = {},
	Public = {},
	D = {},
	C extends ComputedOptions = {},
	O = {},
	T extends ProjectType = 'quickapp',
	Props = Readonly<{ [key in PropsNames]: any }>
> = ComponentOptionsBase<Private, Protected, Public, D, C, O> & { props: PropsNames[] } & ThisType<
		CreateComponentPublicInstance<Props, Private, Protected, Public, D, C, O, T>
	>;

export type ComponentOptionsWithObjectProps<
	PropsOptions = ComponentObjectPropsOptions,
	Private = {},
	Protected = {},
	Public = {},
	D = {},
	C extends ComputedOptions = {},
	O = {},
	T extends ProjectType = 'quickapp',
	Props = Readonly<ExtractPropTypes<PropsOptions>>
> = ComponentOptionsBase<Private, Protected, Public, D, C, O> & {
	props: PropsOptions & ThisType<void>;
} & ThisType<CreateComponentPublicInstance<Props, Private, Protected, Public, D, C, O, T>>;

interface LegacyOptions<Private = {}, Protected = {}, Public = {}, D = {}, C extends ComputedOptions = {}> {
	// state
	// Limitation: we cannot expose RawBindings on the `this` context for data
	// since that leads to some sort of circular inference and breaks ThisType
	// for the entire component.

	private?: Private;
	protected?: Protected;
	public?: Public;

	/**  data may be an Object or Function */
	data?: D | (()=>D);
	computed?: C;

	// assets
	filters?: Record<string, Function>;

	// lifecycle
	//页面初始化
	onInit?(): void;
	onReady?(): void;
	onShow?(): void;
	onHide?(): void;
	onDestroy?(): void;
	onBackPress?(): void;
	onMenuPress?(): void;
	onRefresh?(): void;
	onConfigurationChanged?(): void;
	onReachTop?(): void;
	onReachBottom?(): void;
	onPageScroll?(event: any): void;
}

export type GeyMethods<O = {}> = {
	[K in keyof Omit<O, keyof ComponentBuildinType>]: O[K] extends Function ? O[K] : never;
};

export type ComponentOptionsBase<
	Private = {},
	Protected = {},
	Public = {},
	D = {},
	C extends ComputedOptions = {},
	O = {}
> = LegacyOptions<Private, Protected, Public, D, C> & GeyMethods<O>;
