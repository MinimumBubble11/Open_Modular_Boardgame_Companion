/** S of props */

import { IfAny } from './shared';

export declare type ComponentPropsOptions<P = Data> = ComponentObjectPropsOptions<P> | string[];

export declare type Data = Record<string, unknown>;

export declare type ComponentObjectPropsOptions<P = Data> = {
	[K in keyof P]: Prop<P[K]> | null;
};
export declare type Prop<T, D = T> = PropOptions<T, D> | PropType<T>;

export declare interface PropOptions<T = any, D = T> {
	type?: PropType<T> | true | null;
	required?: boolean;
	default?: D | DefaultFactory<D> | null | undefined | object;
	validator?(value: unknown): boolean;
}
export declare type PropType<T> = PropConstructor<T> | PropConstructor<T>[];
declare type DefaultFactory<T> = (props: Data) => T | null | undefined;
declare type PropConstructor<T = any> =
	| {
			new (...args: any[]): T & {};
	  }
	| {
			(): T;
	  }
	| PropMethod<T>;

declare type PropMethod<T, TConstructor = any> = [T] extends [((...args: any) => any) | undefined]
	? {
			new (): TConstructor;
			(): T;
			readonly prototype: TConstructor;
	  }
	: never;
type RequiredKeys<T> = {
	[K in keyof T]: T[K] extends
		| { required: true }
		| { default: any }
		// don't mark Boolean props as undefined
		| BooleanConstructor
		| { type: BooleanConstructor }
		? T[K] extends { default: undefined | (() => undefined) }
			? never
			: K
		: never;
}[keyof T];

type OptionalKeys<T> = Exclude<keyof T, RequiredKeys<T>>;

type InferPropType<T> = [T] extends [null]
	? any // null & true would fail to infer
	: [T] extends [{ type: null | true }]
	? any // As TS issue https://github.com/Microsoft/TypeScript/issues/14829 // somehow `ObjectConstructor` when inferred from { (): T } becomes `any` // `BooleanConstructor` when inferred from PropConstructor(with PropMethod) becomes `Boolean`
	: [T] extends [ObjectConstructor | { type: ObjectConstructor }]
	? Record<string, any>
	: [T] extends [BooleanConstructor | { type: BooleanConstructor }]
	? boolean
	: [T] extends [DateConstructor | { type: DateConstructor }]
	? Date
	: [T] extends [(infer U)[] | { type: (infer U)[] }]
	? U extends DateConstructor
		? Date | InferPropType<U>
		: InferPropType<U>
	: [T] extends [Prop<infer V, infer D>]
	? unknown extends V
		? IfAny<V, V, D>
		: V
	: T;

export type ExtractPropTypes<O> = {
	// use `keyof Pick<O, RequiredKeys<O>>` instead of `RequiredKeys<O>` to support IDE features
	[K in keyof Pick<O, RequiredKeys<O>>]: InferPropType<O[K]>;
} & {
	// use `keyof Pick<O, OptionalKeys<O>>` instead of `OptionalKeys<O>` to support IDE features
	[K in keyof Pick<O, OptionalKeys<O>>]?: InferPropType<O[K]>;
};
/** E of props  */
