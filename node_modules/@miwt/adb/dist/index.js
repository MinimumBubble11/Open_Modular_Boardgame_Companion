"use strict";Object.defineProperty(exports, "__esModule", {value: true});var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

// src/core.ts





var _child_process = require('child_process');
var _path = require('path');
var TIMEOUT = 8 * 1e4;
var base = _path.resolve.call(void 0, __dirname, "..", "bin");
var hasSystemAdb;
var supportedPlatform = ["win32", "darwin", "linux"];
var PriorityAdbModuleType = /* @__PURE__ */ ((PriorityAdbModuleType2) => {
  PriorityAdbModuleType2["Host"] = "host";
  PriorityAdbModuleType2["Internal"] = "internal";
  PriorityAdbModuleType2["Custom"] = "custom";
  return PriorityAdbModuleType2;
})(PriorityAdbModuleType || {});
var ADB_BINARY_FILE = () => ({
  win32: process.env.NODE_ADB_BIN_PATH || _path.resolve.call(void 0, base, "win/adb.exe"),
  darwin: process.env.NODE_ADB_BIN_PATH || _path.resolve.call(void 0, base, "mac/adb"),
  linux: process.env.NODE_ADB_BIN_PATH || _path.resolve.call(void 0, base, "linux/adb")
});
function getAdbFullPath() {
  try {
    return ADB_BINARY_FILE()[process.platform];
  } catch (error) {
    throw new Error(
      `Sorry, @miwt/adb not support your system, supported platform has ${supportedPlatform.toString()}
` + error
    );
  }
}
function getAdbReactivePath(cwd = process.cwd()) {
  try {
    return _path.relative.call(void 0, cwd, ADB_BINARY_FILE()[process.platform]);
  } catch (error) {
    throw new Error(
      `Sorry, @miwt/adb not support your system, supported platform has ${supportedPlatform.toString()}` + error
    );
  }
}
function isSystemAdbAvailable() {
  if (hasSystemAdb !== void 0)
    return hasSystemAdb;
  try {
    const res = _child_process.execSync.call(void 0, "adb version").toString().includes("Android Debug Bridge version");
    hasSystemAdb = res;
    return hasSystemAdb;
  } catch (e) {
    hasSystemAdb = false;
    return hasSystemAdb;
  }
}
var ipRegExp = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?):(\d+)$/;
function ensureArgs(command, options) {
  let cwd = (options == null ? void 0 : options.cwd) || process.cwd();
  if (process.env.PRIORITY_ADB_MODULE_TYPE === "custom" /* Custom */ || process.env.PRIORITY_ADB_MODULE_TYPE === "internal" /* Internal */ || !isSystemAdbAvailable()) {
    let cmd = command.split(" ");
    const binFile = getAdbFullPath();
    cmd[0] = binFile;
    command = cmd.join(" ");
  }
  const res = [
    command,
    __spreadProps(__spreadValues({}, options), {
      cwd,
      timeout: (options == null ? void 0 : options.timeout) || TIMEOUT
    })
  ];
  return res;
}
function execAdbCmdSync(command, options) {
  return _child_process.execSync.call(void 0, ...ensureArgs(command, options)).toString();
}
function execAdbCmdAsync(command, options) {
  return new Promise(async (resolve2, reject) => {
    _child_process.exec.call(void 0, ...ensureArgs(command, options), (err, stdout) => {
      if (err)
        return reject(err);
      const msg = stdout.toString();
      return resolve2(msg);
    });
  });
}
function execAdbCmd(command, options) {
  return _child_process.exec.call(void 0, ...ensureArgs(command, options));
}
function spawnAdbCmd(command, args, options) {
  const [cmd, opts] = ensureArgs(command, options);
  console.log("cmd", cmd, opts);
  return _child_process.spawn.call(void 0, cmd, args, opts);
}
function spawnSyncAdbCmd(command, args, options) {
  const [cmd, opts] = ensureArgs(command, options);
  return _child_process.spawnSync.call(void 0, cmd, args, opts);
}

// src/apk.ts
async function warpExecAdbCmdAsync(cmd) {
  try {
    const res = await execAdbCmdAsync(cmd);
    return {
      status: true,
      msg: res
    };
  } catch (error) {
    return {
      status: false,
      msg: error.toString()
    };
  }
}
async function isApkInstalled(sn, apkName) {
  const res = await warpExecAdbCmdAsync(`adb -s ${sn} shell pm path ${apkName}`);
  res.status = res.msg.includes("package:");
  return res;
}
function installApk(sn, apkPath) {
  return warpExecAdbCmdAsync(`adb -s ${sn} install ${apkPath}`);
}
async function uninstallApk(sn, apkName) {
  return warpExecAdbCmdAsync(`adb -s ${sn} uninstall ${apkName}`);
}

// src/device.ts
async function getAdbDevices() {
  const list = await execAdbCmdAsync("adb devices");
  return _parseDeviceInfo(list);
  function _parseDeviceInfo(stdout) {
    if (!stdout) {
      return [];
    }
    const lines = stdout.replace(/(\n|\r\n){1,}/g, "\n").split("\n");
    const result = lines.filter((item, idx) => {
      return idx !== 0 && item !== "";
    }).map((item) => {
      const [sn, status] = item.split("	");
      return { sn, status };
    });
    return result;
  }
}
async function connectDevice(sn) {
  try {
    const cmd = `adb connect ${sn}`;
    const res = await execAdbCmdAsync(cmd);
    let result = {
      status: false,
      msg: res
    };
    if (/connected to/.test(res))
      result.status = true;
    return result;
  } catch (error) {
    return {
      status: false,
      msg: error.toString()
    };
  }
}
async function disconnectDevice(sn) {
  try {
    const cmd = `adb disconnect ${sn}`;
    const res = await execAdbCmdAsync(cmd);
    let result = {
      status: false,
      msg: res
    };
    if (/disconnected/.test(res))
      result.status = true;
    return result;
  } catch (error) {
    return {
      status: false,
      msg: error.toString()
    };
  }
}





















exports.ADB_BINARY_FILE = ADB_BINARY_FILE; exports.PriorityAdbModuleType = PriorityAdbModuleType; exports.connectDevice = connectDevice; exports.disconnectDevice = disconnectDevice; exports.ensureArgs = ensureArgs; exports.execAdbCmd = execAdbCmd; exports.execAdbCmdAsync = execAdbCmdAsync; exports.execAdbCmdSync = execAdbCmdSync; exports.getAdbDevices = getAdbDevices; exports.getAdbFullPath = getAdbFullPath; exports.getAdbReactivePath = getAdbReactivePath; exports.installApk = installApk; exports.ipRegExp = ipRegExp; exports.isApkInstalled = isApkInstalled; exports.isSystemAdbAvailable = isSystemAdbAvailable; exports.spawnAdbCmd = spawnAdbCmd; exports.spawnSyncAdbCmd = spawnSyncAdbCmd; exports.supportedPlatform = supportedPlatform; exports.uninstallApk = uninstallApk; exports.warpExecAdbCmdAsync = warpExecAdbCmdAsync;
