import * as child_process from 'child_process';
import { ExecSyncOptionsWithStringEncoding, ChildProcessWithoutNullStreams } from 'child_process';

declare const supportedPlatform: readonly ["win32", "darwin", "linux"];
type SupportedPlatform = (typeof supportedPlatform)[number];
/**
 * Enum for specifying the preferred ADB module type.
 *
 * @enum {string}
 * @example
 * process.env.NODE_ADB_BIN_PATH = '/path/to/your/customBin'
 * process.env.PRIORITY_ADB_MODULE_TYPE = 'custom'
 */
declare enum PriorityAdbModuleType {
    /**
     * Use the ADB module installed on the host machine.
     * @type {string}
     */
    Host = "host",
    /**
     * Use the internal ADB module provided by the plugin.
     * @type {string}
     */
    Internal = "internal",
    /**
     * Use a custom ADB module specified by the environment variable `NODE_ADB_BIN_PATH`.
     * @type {string}
     */
    Custom = "custom"
}
declare const ADB_BINARY_FILE: () => {
    win32: string;
    darwin: string;
    linux: string;
};
declare function getAdbFullPath(): string;
declare function getAdbReactivePath(cwd?: string): string;
/** @description Is there an available ADB in your computer? */
declare function isSystemAdbAvailable(): boolean;
declare const ipRegExp: RegExp;
declare function ensureArgs(command: string, options?: ExecSyncOptionsWithStringEncoding): [string, ExecSyncOptionsWithStringEncoding];
/**
 *  @description use sync method to run adb commamnd, will return a string
 *  @example execAdbCmdSync('adb devices')
 */
declare function execAdbCmdSync(command: string, options?: ExecSyncOptionsWithStringEncoding): string;
/**
 *  @description use async method to run adb commamnd, will return a string
 *  @example execAdbCmdAsync('adb devices')
 */
declare function execAdbCmdAsync(command: string, options?: ExecSyncOptionsWithStringEncoding & {
    log?: any;
}): Promise<string>;
/**
 *  @description use exec method to run adb commamnd, will return a ChildProcess
 *  so than you can control the adb process more finely
 *  @example
 *  const lsProcess = execAdbCmd('adb shell ls /data/tmp')
 *  lsProcess.stdout.on('data',(data)=>{
 *    console.log(data.toString())
 *  })
 *
 *  const adbShell = spawnAdbCmd('adb', ['shell'])
 *  adbShell.stdin.write('ls /data/tmp \n')
 *  adbShell.stdin.write('ls /data/tmp/dir \n')
 */
declare function execAdbCmd(command: string, options?: ExecSyncOptionsWithStringEncoding): ChildProcessWithoutNullStreams;
/**
 *  @description use spawn method to run adb commamnd, will return a ChildProcess
 *  so than you can control the adb process more finely
 *  @description 使用 nodejs 子进程的exec方法运行一个 adb 命令，并返回这个子进程，使得你可以更细腻度的方式控制 adb 命令
 *  @example
 *  const adbShell = spawnAdbCmd('adb', ['shell'])
 *  adbShell.stdin.write('ls /data/tmp \n')
 *  adbShell.stdin.write('ls /data/tmp/dir \n')
 */
declare function spawnAdbCmd(command: string, args: string[], options?: ExecSyncOptionsWithStringEncoding): ChildProcessWithoutNullStreams;
/**
 *  @description use sync spawn method to run adb commamnd, will return a string
 *  @example spawnSyncAdbCmd('adb', ['devices'])
 */
declare function spawnSyncAdbCmd(command: string, args?: string[], options?: ExecSyncOptionsWithStringEncoding): child_process.SpawnSyncReturns<string | Buffer>;

declare function warpExecAdbCmdAsync(cmd: string): Promise<{
    status: boolean;
    msg: string;
}>;
declare function isApkInstalled(sn: string, apkName: string): Promise<{
    status: boolean;
    msg: string;
}>;
declare function installApk(sn: string, apkPath: string): Promise<{
    status: boolean;
    msg: string;
}>;
declare function uninstallApk(sn: string, apkName: string): Promise<{
    status: boolean;
    msg: string;
}>;

type AdbDeviceStatus = 'offline' | 'device' | 'unauthorized';
/** @description return adb devices  */
declare function getAdbDevices(): Promise<{
    sn: string;
    status: AdbDeviceStatus;
}[]>;
declare function connectDevice(sn: string): Promise<{
    status: boolean;
    msg: any;
}>;
declare function disconnectDevice(sn: string): Promise<{
    status: boolean;
    msg: any;
}>;

export { ADB_BINARY_FILE, AdbDeviceStatus, PriorityAdbModuleType, SupportedPlatform, connectDevice, disconnectDevice, ensureArgs, execAdbCmd, execAdbCmdAsync, execAdbCmdSync, getAdbDevices, getAdbFullPath, getAdbReactivePath, installApk, ipRegExp, isApkInstalled, isSystemAdbAvailable, spawnAdbCmd, spawnSyncAdbCmd, supportedPlatform, uninstallApk, warpExecAdbCmdAsync };
