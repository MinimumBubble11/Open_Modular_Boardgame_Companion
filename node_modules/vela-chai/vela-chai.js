function getType(value) {
  if (typeof value === 'undefined') {
    return 'undefined';
  }
  
  if (value === null) {
    return 'null';
  }

  const stringTag = value[Symbol.toStringTag];
  if (typeof stringTag === 'string') {
    return stringTag;
  }
  const type = Object.prototype.toString.call(value).slice(8, -1);
  return type;
}

const assert = {
  equal: function (actual, expected, message) {
    if (actual != expected && (!isNaN(actual) || !isNaN(expected))) {
      const err = new Error('AssertionError: ' + (message ? `${message}: ` : '') + `expected ${actual} to equal ${expected}`)
      err.actual = actual
      err.expected = expected
      throw err
    }
  },

  approxEqual: function(actual, accuracy, message) {
    const gap = Math.abs(Math.abs(actual) - Math.abs(accuracy))
    assert.isAtMost(gap, 2, message)
  },

  fail: function (message) {
    const err = new Error('AssertionError: ' + (message ? `${message}: ` : '') + 'assert.fail()')
    err.actual = message
    throw err
  },

  include: function (haystack, needle, message) {
    const err = new Error('AssertionError: ' + (message ? `${message}: ` : '') + `expected ${haystack} to include ${needle}`)
    const type = Object.prototype.toString.call(haystack)

    err.actual = haystack

    switch (type) {
      case '[object String]':
      case '[object Array]':
        if (!~haystack.indexOf(needle)) throw err
        break;
      case '[object Object]':
        const haystackKeys = Object.keys(haystack)
        const needleKeys = Object.keys(needle)
        // haystack keys 个数小于 needle keys 个数 一定不包含
        if (haystackKeys.length < needleKeys) throw err    
        // 判断key是否被包含
        for (let i = 0; i < needleKeys.length; i++) {
          let key = needleKeys[i]
          // 存在不包含的key
          if (!haystackKeys.includes(key)) throw err 
          if (typeof needle[key] === 'object') {
            // 如果对比项类型是 object 递归
            include(haystack[key], needle[key], message)
          } else if (haystack[key] !== needle[key]) {
            throw err 
          }
        }
        break;
      default:
        throw err
    }
  },

  isArray: function (value, message) {
    if (!Array.isArray(value)) {
      const err = new Error('AssertionError: ' + (message ? `${message}: ` : '') + `expected ${value} to be an array`)
      err.actual = value
      throw err
    }
  },

  isAtLeast: function (valueToCheck, valueToBeAtLeast, message) {
    if (valueToCheck < valueToBeAtLeast) {
      const err = new Error('AssertionError: ' + (message ? `${message}: ` : '') + `expected ${valueToCheck} to be at least ${valueToBeAtLeast}`)
      err.actual = valueToCheck
      err.expected = valueToBeAtLeast
      throw err
    }
  },

  isAtMost: function (valueToCheck, valueToBeAtMost, message) {
    const err = new Error()
    err.actual = valueToCheck
    err.expected = valueToBeAtMost
    
    if (typeof valueToCheck !== 'number' || typeof valueToCheck !== 'number') {
      err.message = message || 'the argument to above must be a number'
      throw err
    } else if (valueToCheck > valueToBeAtMost) {
      err.message = 'AssertionError: ' + (message ? `${message}: ` : '') + `expected ${valueToCheck} to be at most ${valueToBeAtMost}`
      throw err
    }
  },

  isBelow: function (valueToCheck, valueToBeBelow, message) {
    const err = new Error()
    err.actual = valueToCheck
    err.expected = valueToBeBelow

    if (typeof valueToCheck !== 'number' || typeof valueToCheck !== 'number') {
      err.message = message || 'the argument to above must be a number'
      throw err
    } else if (valueToCheck >= valueToBeBelow) {
      err.message = 'AssertionError: ' + (message ? `${message}: ` : '') + `expected ${valueToCheck} to be below ${valueToBeBelow}`
      throw err
    }
  },

  isBoolean: function (value, message) {
    if (typeof value !== 'boolean') {
      const err = new Error('AssertionError: ' + (message ? `${message}: ` : '') + `expected ${value} to be a boolean`)
      err.actual = value
      throw err
    }
  },

  isNotArray: function (value, message) {
    if (Array.isArray(value)) {
      const err = new Error('AssertionError: ' + (message ? `${message}: ` : '') + `expected ${value} not to be an array`)
      err.actual = value
      throw err
    }
  },

  isNotBoolean: function (value, message) {
    if (typeof value === 'boolean') {
      const err = new Error('AssertionError: ' + (message ? `${message}: ` : '') + `expected ${value} not to be a boolean`)
      err.actual = value
      throw err
    }
  },

  isNotNull: function (value, message) {
    if (value === null) {
      const err = new Error('AssertionError: ' + (message ? `${message}: ` : '') + `expected ${value} to not equal null`)
      err.actual = value
      throw err
    }
  },

  isNotNumber: function (value, message) {
    if (typeof value === `number`) {
      const err = new Error('AssertionError: ' + (message ? `${message}: ` : '') + `expected ${value} not to be a number`)
      err.actual = value
      throw err
    }
  },

  isNotOk: function (value, message) {
    if (value) {
      const err = new Error('AssertionError: ' + (message ? `${message}: ` : '') + `expected ${value} to be falsy`)
      err.actual = value
      throw err
    }
  },

  isNotString: function (value, message) {
    if (typeof value === `string`) {
      const err = new Error('AssertionError: ' + (message ? `${message}: ` : '') + `expected ${value} not to be a string`)
      err.actual = value
      throw err
    }
  },

  isNull: function (value, message) {
    if (value !== null) {
      const err = new Error('AssertionError: ' + (message ? `${message}: ` : '') + `expected ${value} to equal null`)
      err.actual = value
      throw err
    }
  },

  isNumber: function (value, message) {
    if (typeof value !== `number`) {
      const err = new Error('AssertionError: ' + (message ? `${message}: ` : '') + `expected ${value} to be a number`)
      err.actual = value
      throw err
    }
  },

  isOk: function (value, message) {
    if (!value) {
      const err = new Error('AssertionError: ' + (message ? `${message}: ` : '') + `expected ${value} to be truthy`)
      err.actual = value
      throw err
    }
  },

  isString: function (value, message) {
    if (typeof value !== `string`) {
      const err = new Error('AssertionError: ' + (message ? `${message}: ` : '') + `expected ${value} to be a string`)
      err.actual = value
      throw err
    }
  },

  notStrictEqual: function (actual, expected, message) {
    if (Object.is(actual, expected)) {
      const err = new Error('AssertionError: ' + (message ? `${message}: ` : '') + `expected ${actual} to not equal ${expected}`)
      err.actual = actual
      err.expected = expected
      throw err
    }
  },

  strictEqual: function (actual, expected, message) {
    if (actual !== expected) {
      const err = new Error('AssertionError: ' + (message ? `${message}: ` : '') + `expected ${actual} to equal ${expected}`)
      err.actual = actual
      err.expected = expected
      throw err
    }
  },

  typeOf: function (value, type, message) {
    type = type.toLowerCase()
    const detectedType = getType(value)
    value = detectedType.toLowerCase()
    if (value !== type) {

      article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';

      const err = new Error('AssertionError: ' + (message ? `${message}: ` : '') + `expected ${detectedType} to be ${article} ${type}`)
      err.actual = value
      err.expected = type
      throw err
    }
  },

  isObject: function (value, message) {
    const detectedType = getType(value).toLowerCase()
    if (detectedType !== 'object') {
      const err = new Error('AssertionError: ' + (message ? `${message}: ` : '') + `expected ${value} to be an object`)
      err.actual = value
      throw err
    }
  },

  lengthOf: function (object, length, message) {
    const detectedType = getType(object)
    const objType = detectedType.toLowerCase()
    let itemsCount, descriptor = 'length'

    switch (objType) {
      case 'map':
      case 'set':
        descriptor = 'size';
        itemsCount = object.size;
        break;
      default:
        itemsCount = object.length;
    }

    if (itemsCount !== length) {
      const err = new Error('AssertionError: ' + (message ? `${message}: ` : '') + `expected this ${detectedType} to have a ${descriptor} of ${length} but got ${itemsCount}`)
      err.actual = itemsCount
      err.expected = length
      throw err
    }
  }
}

export {
  assert
}
