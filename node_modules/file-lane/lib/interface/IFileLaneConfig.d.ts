import { MatchType } from '@aiot-toolkit/shared-utils';
import IFileLaneContext from './IFileLaneContext';
import ILoader from './ILoader';
import IPlugin from './IPlugin';
import FileLaneCompilation from '../FileLaneCompilation';
import { IChangedFile } from './IChangedFile';
export type ILoaderClass = (new (...args: any[]) => ILoader) & {
    raw?: boolean;
};
export interface IRule {
    /**
     * 配置文件
     */
    test: MatchType;
    /**
     * 文件的 Loader，从前向后依次执行，前一个 loader 结果做为后一个 loader 的入参
     */
    loader: ILoaderClass[];
    exclude?: MatchType;
    include?: MatchType;
}
/**
 * IFileLaneConfig
 */
export default interface IFileLaneConfig<O = any> {
    /**
     * 项目文件采集器
     *
     * @param entryFileList 输入的文件列表
     *
     * @returns 返回项目中所有待处理的文件路径
     *
     * @description 用于采集所有要处理的真实文件路径列表，或者输入文件列表中要处理的真实文件路径列表
     */
    collectFile?: (entryFileList?: IChangedFile[]) => string[];
    /**
     * 文件收集器
     *
     *
     * @param path 文件路径
     *
     * @returns 要合并的文件路径
     *
     * @description 通常用于多转1，例如 src/a.hml -->[src/a.hml, src/a.js, src/a.css]
     * 不填写，表示直接使用源文件
     *
     */
    fileCollector?: (file: string) => string[];
    /**
     * 指定处理的文件范围
     *
     * 此属性的函数形式，在多转1可能很有用
     * 例如：a.js 做为js需要处理，但同目录存在 a.ux 时，则排除
     *
     * @example /^src/
     *
     */
    include?: MatchType;
    exclude?: MatchType;
    /**
     * 输出目录
     *
     */
    output: string;
    /**
     * 文件转换配置
     */
    module: {
        /**
         * 转换规则
         */
        rules: IRule[];
    };
    /**
     * 插件
     *
     * 触发时机如下
     * 1. 每个文件转换完成
     * 2. 所有文件转换完成
     */
    plugins?: IPlugin[];
    /**
     * 启动阶段的准备工作
     */
    beforeWorks?: BeforeWork[];
    /**
     * 收尾阶段的工作
     */
    afterWorks?: AfterWork[];
    /**
     * 项目转换的前置工作
     */
    beforeCompile?: PreWork[];
    /**
     * 项目转换的后续工作
     *
     * xts--[zip]
     * ux--[webpack, zip]
     * uxInspect--[webpack, zipPhone, zipWatch, zipTv]
     */
    afterCompile?: FollowWoker<O>[];
    /**
     * 配置watch时忽略的文件或者文件夹
     */
    watchIgnores?: MatchType;
    projectPath: string;
}
type FollowWoker<O> = {
    worker: FollowWork<O>;
    workerDescribe?: string;
};
type CompileParam<O = any> = {
    context: IFileLaneContext;
    config: IFileLaneConfig;
    compilerOption?: O;
    compalition?: FileLaneCompilation;
};
export type BeforeWork = (context: IFileLaneContext) => Promise<any>;
export type PreWork<O = any> = (preWorkParams: CompileParam<O>) => Promise<any>;
export type FollowWork<O = any> = (followParams: CompileParam<O>) => Promise<any>;
export type AfterWork = (context: IFileLaneContext) => Promise<any>;
export {};
