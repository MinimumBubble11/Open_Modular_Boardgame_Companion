#!/usr/bin/env node
"use strict";

var _sharedUtils = require("@aiot-toolkit/shared-utils");
var _semver = _interopRequireDefault(require("semver"));
var _aiotpack = require("@aiot-toolkit/aiotpack");
var _commander = require("@aiot-toolkit/commander");
var _AndroidUxBuilder = _interopRequireDefault(require("./builder/AndroidUxBuilder"));
var _VelaUxBuilder = _interopRequireDefault(require("./builder/VelaUxBuilder"));
var _XtsBuilder = _interopRequireDefault(require("./builder/XtsBuilder"));
var _AndroidUxStart = _interopRequireDefault(require("./starter/AndroidUxStart"));
var _VelaUxStarter = _interopRequireDefault(require("./starter/VelaUxStarter"));
var _XtsStarter = _interopRequireDefault(require("./starter/XtsStarter"));
var _DeviceUtil = _interopRequireDefault(require("./utils/DeviceUtil"));
var _VelaAvdUtils = _interopRequireDefault(require("./utils/VelaAvdUtils"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
// 支持的最低node版本
const NODE_MINIMUM_VERSION = '18.0.0';
checkVersion();
// 校验当前环境中的node
function checkVersion() {
  const currentVersion = process.versions.node;
  if (_semver.default.lt(currentVersion, NODE_MINIMUM_VERSION)) {
    _sharedUtils.ColorConsole.throw('It is detected that the current NodeJS version ', {
      word: currentVersion
    }, ' is too low, please upgrade to NodeJS version higher than ', {
      word: NODE_MINIMUM_VERSION
    });
    process.exit();
  }
}

// 配置支持的 builder 类型，新增的项目类型，需在此处加上类型
const projectMapper = {
  [_sharedUtils.ProjectType.VELA_UX]: {
    builder: _VelaUxBuilder.default,
    starter: _VelaUxStarter.default
  },
  [_sharedUtils.ProjectType.VELA_XTS]: {
    builder: _XtsBuilder.default,
    starter: _XtsStarter.default
  },
  [_sharedUtils.ProjectType.ANDDROID_UX]: {
    builder: _AndroidUxBuilder.default,
    starter: _AndroidUxStart.default
  }
};
function findBuilder() {
  const projectType = _sharedUtils.ProjectType.getProjectType(process.cwd());
  return new projectMapper[projectType].builder();
}
function build(command, description) {
  const builder = findBuilder();
  const paramList = builder?.params;
  return {
    name: command,
    description,
    paramList,
    action: async option => {
      try {
        // 获取对应的 build；如果存在，执行 build 函数，不存在，提示
        option.mode = command === 'release' ? _aiotpack.CompileMode.PRODUCTION : _aiotpack.CompileMode.DEVELOPMENT;
        const projectPath = process.cwd();
        await builder.build(projectPath, option);
      } catch (error) {
        _sharedUtils.ColorConsole.error('Build Error:', {
          word: error?.toString() || 'unknown error'
        });
      }
    }
  };
}
function findStarter(command, description) {
  const projectType = _sharedUtils.ProjectType.getProjectType(process.cwd());
  return new projectMapper[projectType].starter(command, description);
}
async function main() {
  const config = {
    name: 'aiot-toolkit',
    description: 'contains build, dev, release, etc. commands for aiot toolkit',
    version: require('../package.json').version,
    commandList: [build('build', 'build project'), build('release', 'release the project'), findStarter('start', 'start project').getCommond(), {
      name: 'getConnectedDevices',
      description: 'get all connected devices',
      action: async () => {
        try {
          const connectedDevices = await _DeviceUtil.default.getAllConnectedDevices();
          _sharedUtils.ColorConsole.info(`The connected devices are: ${connectedDevices ? connectedDevices.join(', ') : 'null'}`);
        } catch (error) {
          _sharedUtils.ColorConsole.throw(`Error: getConnectedDevices failed`);
        }
      }
    }, {
      name: 'getPlatforms',
      description: 'get available platform(s) on selected device',
      paramList: [{
        name: 'ip',
        description: 'device ip(eg 127.0.0.1)',
        type: 'string',
        enableInquirer: true
      }, {
        name: 'port',
        description: 'device port(eg 39517)',
        type: 'string',
        enableInquirer: true
      }, {
        name: 'sn',
        description: 'view the serial number of the connected device through the "adb devices" command, if it is a device connected via wifi, the format is "ip address:5555"',
        type: 'string',
        enableInquirer: true
      }],
      action: async option => {
        await _DeviceUtil.default.getAvailablePlatform(option);
      }
    }, {
      name: 'installDbgAndMkp',
      description: 'install "org.hapjs.debugger" & "org.hapjs.mockup" ',
      paramList: [{
        name: 'ip',
        description: 'device ip(eg 127.0.0.1)',
        type: 'string'
      }, {
        name: 'port',
        description: 'device ip(eg 5555)',
        type: 'string'
      }],
      action: async option => {
        try {
          const successMessage = await _DeviceUtil.default.installDbgAndMkp(option);
          _sharedUtils.ColorConsole.success(`${successMessage}`);
        } catch (error) {
          _sharedUtils.ColorConsole.throw(`installDbgAndMkp failed, errorMessage:'}`, {
            word: error?.toString() || 'unknown error'
          });
        }
      }
    }, {
      name: 'createVVD',
      description: 'create a vela virtual device',
      action: async () => {
        _VelaAvdUtils.default.createVelaVvdByInquire();
      }
    }, {
      name: 'deleteVVD',
      description: 'delete vela virtual device(s)',
      paramList: [{
        name: 'avdNames',
        description: 'avd names to delete',
        enableInquirer: true,
        type: 'checkbox',
        choices: _VelaAvdUtils.default.vvdManager.getVvdList().map(item => {
          return {
            name: item.name,
            value: item.name
          };
        })
      }],
      action: async option => {
        const {
          avdNames
        } = option;
        avdNames.forEach(avdName => {
          _VelaAvdUtils.default.vvdManager.deleteVvd(avdName);
        });
      }
    }, {
      name: 'initEmulatorEnv',
      description: 'init/reset emulator environment',
      action: async () => {
        _VelaAvdUtils.default.initEmulatorEnv();
      }
    }]
  };
  _commander.Command.registeProgram(config);
}
main();