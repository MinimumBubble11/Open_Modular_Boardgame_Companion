"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _sharedUtils = require("@aiot-toolkit/shared-utils");
var _prompts = require("@inquirer/prompts");
var _fs = _interopRequireDefault(require("fs"));
var _path = _interopRequireDefault(require("path"));
var _AdbUtils = _interopRequireDefault(require("./AdbUtils"));
var _RequestUtils = _interopRequireDefault(require("./RequestUtils"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * DeviceUtil
 */
class DeviceUtil {
  static ipRegExp = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
  static CLIENT_PORT = 39517;
  static quickapp_url = 'https://statres.quickapp.cn/quickapp/quickapptool/release/platform/';
  /**
   * 获取连接上的所有设备数组，供IDE使用
   * @returns
   */
  static getAllConnectedDevices() {
    try {
      return _AdbUtils.default.getAllConnectedDevices().then(deviceList => {
        if (deviceList.length > 0) {
          _sharedUtils.ColorConsole.info(`Devices connected via adb： ${deviceList.join(', ')}.`);
          return Promise.resolve(deviceList);
        } else {
          _sharedUtils.ColorConsole.throw(`No device is currently connected, please check the following preparations in turn：\n  1. Whether the device is started;\n  2. Whether in the same LAN WI-FI;\n  3. Whether the device can be connected to the computer via USB;`);
        }
      });
    } catch (error) {
      _sharedUtils.ColorConsole.throw('Error getting connection information of adb device');
    }
  }
  /**
   * 安装调试器、预览版
   * @param options
   * @returns
   */
  static async installDbgAndMkp(options) {
    try {
      const {
        ip = ''
      } = options;
      let connectDeviceList = [ip];
      // 1. 判断设备是否连接
      await this.connectDevice(ip);
      // 2. 获取连接的设备
      const deviceList = await _AdbUtils.default.getAllConnectedDevices();
      const finalDeviceList = deviceList.length > 0 ? await this.queryDevice(deviceList, 'Install Quickapp debugger or previewer ') : [];
      connectDeviceList = finalDeviceList ? [...finalDeviceList] : [];
      // 若connectDeviceList为空，应该warn并结束程序
      if (connectDeviceList.length <= 0) {
        _sharedUtils.ColorConsole.throw({
          word: 'No device'
        }, 'requires debugger or previewer installation');
        return Promise.reject(new Error(`No device requires debugger or previewer installation`));
      }
      // 3. 下载并获取调试器、预览器地址
      const debuggerPath = await this.downloadApk(options, true);
      const previewPath = await this.downloadApk(options, false);
      // // 4. 安装调试器
      await this.installApk(connectDeviceList, debuggerPath);
      await this.installApk(connectDeviceList, previewPath);
      return Promise.resolve('All devices successfully installed the Quickapp debugger and previewer');
    } catch (error) {
      return Promise.reject(new Error(`Failed to install , error message：${error?.toString() || 'unknown error'}`));
    }
  }
  /**
   * 如果是TV等AIOT设备，需要通过IP连接
   * 1. 若ip为空，则询问是否要连接新设备
   * 2. 无需连接新设备，返回
   * 3. 连接新设备，输入ip值（可输入多个ip，以逗号隔断）
   * 4. 判断输入值，空则输出info并返回
   * 5. 处理ip，输入每个ip设备的端口号，尝试连接，给出连接结果
   * @param ip
   */
  static async connectDevice(ip) {
    try {
      if (!ip) {
        const WIFI_TEXT = 'Yes, connect a new wifi device';
        const connectType = await (0, _prompts.select)({
          message: '(USB devices will automatically connect) Choose whether to connect to a new wifi device, and fill in its IP address later:',
          choices: [{
            value: WIFI_TEXT
          }, {
            value: 'Skip, keep connected device'
          }]
        });
        if (connectType === WIFI_TEXT) {
          const deviceIp = await (0, _prompts.input)({
            message: 'Please enter the IP address of the device under wifi(eg:192.168.1.1),make sure that the computer and the device are under the same wifi。If you need to enter multiple IPs, please separate them with ",":'
          });
          ip = deviceIp;
        } else {
          return Promise.resolve();
        }
      }
      if (ip.length === 0) {
        _sharedUtils.ColorConsole.log(`Since no ip address is entered, the connected device will be connected`);
        return Promise.resolve();
      }
      const ips = ip.trim().split(',');
      const invalidIps = ips.filter(ip => !this.ipRegExp.test(ip));
      if (invalidIps && invalidIps.length) {
        invalidIps.map(ip => {
          _sharedUtils.ColorConsole.throw(`ip: `, {
            word: ip,
            style: _sharedUtils.ColorConsole.getStyle(_sharedUtils.Loglevel.THROW)
          }, ` is invalid IP`);
        });
      } else {
        const newDeviceListPromiseArray = Array.from(ips, async ip => {
          const devicePort = await (0, _prompts.input)({
            message: `Please enter the port of the IP(${ip})`,
            default: '5555'
          });
          return _AdbUtils.default.connect(ip, devicePort).then(() => {
            _sharedUtils.ColorConsole.success(`wifi connection ip: The device with ip of "${ip}" succeeded`);
            return Promise.resolve();
          }).catch(err => {
            _sharedUtils.ColorConsole.throw(`${err}`);
          });
        });
        return Promise.all(newDeviceListPromiseArray).then(() => {
          _sharedUtils.ColorConsole.log(`All new WIFI devices are connected`);
          return Promise.resolve();
        }).catch(() => {
          // 在抛出错误前已经弹出错误日志了，故这里直接退出
          process.exit();
        });
      }
    } catch {}
  }
  /**
   * 选择一个或者多个设备
   * @param deviceList
   * @param orderText
   * @returns
   */
  static async queryDevice(deviceList) {
    let orderText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    if (!deviceList || deviceList.length === 0) {
      _sharedUtils.ColorConsole.throw(`No device is connected yet, please confirm and try again`);
      return;
    }
    const ALL_TEXT = 'All connected devices';
    const deviceListObj = deviceList.map(device => {
      return {
        value: device
      };
    });
    // 可选一台或多台设备
    const chooseDevices = await (0, _prompts.checkbox)({
      message: `Please select the device that needs to execute command "${orderText}":`,
      choices: [{
        value: ALL_TEXT
      }, ...deviceListObj]
    });
    return chooseDevices[0] === ALL_TEXT ? deviceList : chooseDevices;
  }
  /**
   * 下载apk
   * @param options
   * @param isQuickAppDebugger
   * @returns
   */
  static async downloadApk(options, isQuickAppDebugger) {
    const {
      apkVersion
    } = options;
    let fileName = '';
    let newVersion = apkVersion || 'v1100';
    if (isQuickAppDebugger) {
      fileName = `quickapp_debugger_${newVersion}.apk`;
    } else {
      fileName = `quickapp_platform_preview_release_${newVersion}.apk`;
    }
    const url = `${this.quickapp_url}${fileName}`;
    const apkPath = _path.default.join(__dirname, './apk/', fileName);
    if (_fs.default.existsSync(apkPath)) {
      // apk已下载
      _sharedUtils.ColorConsole.log(`The installation package has been downloaded, now use the cache file to install`);
      return apkPath;
    } else {
      try {
        const result = await _RequestUtils.default.downloadFile(url, fileName);
        // 打印出成功信息
        _sharedUtils.ColorConsole.success(`Success to download, ${result}`);
        return apkPath;
      } catch (error) {
        // 打印出错误
        _sharedUtils.ColorConsole.throw(`Failed to download the installation package, ${error}`);
        return '';
      }
    }
  }
  /**
   * 获取设备上的快应用框架（需要先安装调试器）
   * 1. 请求获取平台信息
   * 2. 若获取结果为空或者undefined，则等待3s再次请求
   * 3. 若获取结果不为空，但属性availablePlatforms为空，则等待3s再次请求
   * 4. 若请求次数超过3次，则结束请求
   * 5. 否则打印获取结果
   * @param options
   */
  static async getAvailablePlatform(options) {
    try {
      const {
        ip,
        port,
        sn: deviceSn
      } = options;
      let client = {
        ip,
        port
      };
      let countTime = 0;
      let data;
      const sleep = () => {
        _sharedUtils.ColorConsole.error(`Error when the device gets running platforms,request again after 3s delay`);
        return new Promise(resolve => setTimeout(resolve, 3000));
      };
      const requestPlatform = async () => {
        do {
          if (countTime > 0) {
            // 等待3s
            await sleep();
          }
          data = await _RequestUtils.default.sendReq(client, '/availablePlatforms');
        } while (++countTime < 3 && (!data || data && !JSON.parse(data).availablePlatforms));
        if (data) {
          const dataObj = JSON.parse(data);
          if (!dataObj.availablePlatforms) {
            // 请求结果不存在平台信息，报错，结束程序
            _sharedUtils.ColorConsole.throw(`The request result no avaliable platform `);
          } else {
            // 打印请求的平台信息
            const availablePlatforms = dataObj.availablePlatforms;
            _sharedUtils.ColorConsole.log(`The Quickapp engine list of device "${deviceSn}" is：${availablePlatforms.join(',')}`);
          }
        } else {
          //请求失败，结束程序
          _sharedUtils.ColorConsole.throw(`The device gets running platforms error`);
        }
      };
      // 先打开调试器，才能获取运行平台
      await _AdbUtils.default.startDebugger(deviceSn);
      await requestPlatform();
    } catch (error) {
      _sharedUtils.ColorConsole.throw(`Error getting the list of Quickapp engines on the device`);
    }
  }
  /**
   * 给设备列表中的每个设备安装apk
   * @param deviceList
   * @param apkPath
   * @returns
   */
  static async installApk() {
    let deviceList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    let apkPath = arguments.length > 1 ? arguments[1] : undefined;
    try {
      const newDeviceListPromiseArray = Array.from(deviceList, deviceSn => {
        return _AdbUtils.default.installApk(deviceSn, apkPath);
      });
      const apkName = _path.default.basename(apkPath);
      return Promise.all(newDeviceListPromiseArray).then(results => {
        let statusAll = true;
        results.forEach(res => {
          if (!res.status) {
            _sharedUtils.ColorConsole.error(res.msg);
            statusAll = false;
          }
        });
        if (statusAll) {
          _sharedUtils.ColorConsole.success(`All devices installed ${apkName}`);
        } else {
          // TODO 后续从这里抛出异常
        }
      }).catch(() => {
        _sharedUtils.ColorConsole.throw(`Installed ${apkName} failed`);
      });
    } catch (error) {}
  }
}
var _default = exports.default = DeviceUtil;