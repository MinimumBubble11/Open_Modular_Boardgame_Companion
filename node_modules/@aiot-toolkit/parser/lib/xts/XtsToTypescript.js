"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _path = _interopRequireDefault(require("path"));
var _tsMorph = require("ts-morph");
var _sharedUtils = require("@aiot-toolkit/shared-utils");
var _CommentElement = _interopRequireDefault(require("./data/element/CommentElement"));
var _ForElement = _interopRequireDefault(require("./data/element/ForElement"));
var _IfElement = _interopRequireDefault(require("./data/element/IfElement"));
var _NodeElement = _interopRequireDefault(require("./data/element/NodeElement"));
var _AttributeType = _interopRequireDefault(require("./enum/AttributeType"));
var _Framework = require("./enum/Framework");
var _AttributeUtil = _interopRequireDefault(require("./utils/AttributeUtil"));
var _TypeUtil = _interopRequireDefault(require("./utils/TypeUtil"));
var _TypescriptUtil = _interopRequireDefault(require("./utils/TypescriptUtil"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * xts 树转换为 ts 树
 *
 * 过程为
 * 1. 创建 ts 树
 * 1. 遍历 xts 树
 * 2. 遇到预期的节点时，在ts 树中创建对应的节点
 */

class XtsToTypescript {
  mapList = [];
  elementIndex = 0;
  _offsetList = [];
  tsFrameWorkImports = (() => new Set())();
  constructor(project, onLog, projectContext, filePath) {
    this.project = project;
    this.onLog = onLog;
    this.projectContext = projectContext;
    this.filePath = filePath;
    this.onLog = _sharedUtils.WrapCallback.wrapOnLog(onLog);
  }
  get context() {
    return {
      sourceFile: this._sourceFile,
      onLog: this.onLog,
      offsetList: this._offsetList
    };
  }
  translate(xtsTree, offsetList) {
    const oldFile = this.project.getSourceFile('temp.ts');
    if (oldFile) {
      this.project.removeSourceFile(oldFile);
    }
    const result = this.project.createSourceFile('temp.ts');
    this.mapList = [];
    this._offsetList = offsetList;
    this._sourceFile = xtsTree;
    this._newFile = result;

    // 循环 xtsTree，一一对应生成目标节点
    xtsTree.forEachChild(node => {
      switch (node.getKind()) {
        case _tsMorph.SyntaxKind.ClassDeclaration:
          this.translateClassNode(node, result);
          break;
        case _tsMorph.SyntaxKind.ImportDeclaration:
          this.translateFeatureImport(node, result);
          break;
        // 不在需要生成静态代理 参考 https://jira.n.xiaomi.com/browse/VELAPLATFO-21439
        // case SyntaxKind.InterfaceDeclaration:
        //   this.translateInterfaceNode(node as InterfaceDeclaration, result)
        //   break
        default:
          const nodeContent = node.getText();
          result.addStatements([nodeContent]);
          break;
      }
    });

    // 找到所有 tsframework 的类型，如果没有导入的话，将其加入导入列表
    xtsTree.transform(traversal => {
      const node = traversal.visitChildren();
      if (node.kind === _tsMorph.SyntaxKind.TypeReference) {
        if (Object.values(_Framework.tsFrameWorkExports).includes(node.getText())) {
          this.tsFrameWorkImports.add(node.getText());
        }
      }
      return node;
    });
    result.addImportDeclaration({
      moduleSpecifier: _AttributeUtil.default.getFrameworkImportFrom(this.filePath, this.projectContext.projectPath),
      namedImports: [...this.tsFrameWorkImports]
    });
    result.addStatements([`//# sourceMappingURL=index.ts.map`]);
    return {
      ast: result,
      mapList: this.mapList.concat()
    };
  }
  translateFeatureImport(node, result) {
    const list = [{
      name: '@mios.router',
      type: 'MiosRouter'
    }, {
      name: '@mios.storage',
      type: 'MiosStorage'
    }];
    const moduleSpecifier = node.getModuleSpecifier();
    const index = list.findIndex(t => moduleSpecifier.getText().includes(t.name));
    if (index > -1) {
      const newNode = result.addStatements(`const ${node.getImportClause()?.getText()} = requireFeature(${moduleSpecifier.getText()}) as ${list[index].type}`);
      this.tsFrameWorkImports.add('requireFeature');
      this.tsFrameWorkImports.add(list[index].type);
      // TODO: 细化map
      this.addMapData(node, newNode[0]);
    } else {
      const nodeContent = node.getText();
      result.addStatements([nodeContent]);
    }
  }
  addMapData(sourceNode, newNode) {
    if (!sourceNode || !newNode) {
      return;
    }
    this.mapList.push(new _sharedUtils.MapData(sourceNode.getText(), _TypescriptUtil.default.getNodePostion(sourceNode, this.context.sourceFile, this.context.offsetList), _TypescriptUtil.default.getNodePostion(newNode, this._newFile)));
  }
  getParentClassName(classNode) {
    // 根据修饰符判定父类
    // 如果有 parentClass 修饰符，则取出值，并以值为父类
    // 有1个特例是：如果是 Component 且有@main 修饰符，则父类是Page
    let result;
    const parentDecorator = classNode.getDecorator('parentClass');
    if (parentDecorator) {
      const arg = parentDecorator.getArguments()[0];
      const argText = arg?.getText();
      if (argText === _Framework.tsFrameWork.exports.Component && classNode.getDecorator('Main')) {
        result = _Framework.tsFrameWork.exports.Page;
        this.tsFrameWorkImports.add(_Framework.tsFrameWork.exports.Page);
      } else {
        // APP or ViewAspect or Component
        result = argText;
        this.tsFrameWorkImports.add(result);
      }
    }
    return result;
  }
  isPageOrComponent(t) {
    return t === _Framework.tsFrameWorkExports.Page || t === _Framework.tsFrameWorkExports.Component;
  }
  translateClassNode(sourceNode, targetFile) {
    const isNormalClassNode = _TypeUtil.default.isNormalClass(sourceNode);
    if (isNormalClassNode) {
      this.translateNormalClassNode(sourceNode, targetFile);
      return;
    }
    // 存储Property Node
    let propertyNode = [];

    // class 的类型
    const xtsClassType = this.getParentClassName(sourceNode);

    // 添加类和 interface，再遍历 sourceNode，添加成员
    // Page 和 Component 提取响应式数据的 interface
    let interefaNode;
    if (this.isPageOrComponent(xtsClassType)) {
      interefaNode = targetFile.addInterface({
        name: _Framework.HomeState.interface,
        isExported: true,
        extends: [_Framework.tsFrameWork.exports.IComponentState]
      });
      this.tsFrameWorkImports.add(_Framework.tsFrameWork.exports.IComponentState);
    }
    const xtsImplements = [];
    if (this.isPageOrComponent(xtsClassType)) xtsImplements.push(_Framework.HomeState.interface);
    const classNode = targetFile.addClass({
      name: sourceNode.getName(),
      isDefaultExport: true,
      extends: xtsClassType,
      implements: xtsImplements
    });
    this.addMapData(sourceNode.getNameNode(), classNode.getNameNode());

    // 添加构造函数
    const parameters = [];
    if (this.isPageOrComponent(xtsClassType)) {
      parameters.push({
        name: 'params',
        type: _Framework.HomeState.interface,
        hasQuestionToken: true
      });
    }
    const classConstructor = classNode.addConstructor({
      parameters,
      statements: [`super()`]
    });
    sourceNode.forEachChild(node => {
      switch (node.getKind()) {
        // 修饰符
        case _tsMorph.SyntaxKind.Decorator:
          break;
        // 函数
        case _tsMorph.SyntaxKind.MethodDeclaration:
          this.translateMemberMethod(node, classNode);
          break;
        // 成员属性
        case _tsMorph.SyntaxKind.PropertyDeclaration:
          const specialDecorator = _TypeUtil.default.getSpecialDecorator(node);
          if (specialDecorator) {
            propertyNode.push(node);
            this.translateMemberProperty(node, classNode);
            // 特殊成员添加到提取的 interface 中
            if (interefaNode) {
              const nodeType = node.getTypeNode()?.getText() || 'any';
              interefaNode.addProperty({
                hasQuestionToken: true,
                name: node.getName(),
                type: nodeType
              });
            }
          } else {
            classNode.addMember(node.getText());
          }
          break;
        case _tsMorph.SyntaxKind.Identifier:
          break;
        default:
          const nodeContent = node.getText();
          classNode.addMember(nodeContent);
          break;
      }
    });

    // 添加 updateWithParams 定义和调用
    if (this.isPageOrComponent(xtsClassType)) {
      let updateWithParamsCodeArr = ['let flag = false;'];
      propertyNode.forEach(node => {
        const name = node.getName();
        const type = node.getTypeNode()?.getText() || 'any';
        if (_TypeUtil.default.isPrimitiveType(type)) {
          updateWithParamsCodeArr = updateWithParamsCodeArr.concat([`if (params.${name} !== undefined) {`, `   const newVal = params.${name} as ${type}`, `   if (this.${name} !== newVal) {`, `      this.${name} = newVal;`, `      if(!flag)flag = true;`, `  }`, `}`]);
        } else {
          updateWithParamsCodeArr = updateWithParamsCodeArr.concat([`if (params.${name} !== undefined) {`, `  const newVal = params.${name} as ${type}`, `  this.${name} = newVal;`, `  if(!flag)flag = true;`, `}`]);
        }
      });
      updateWithParamsCodeArr.push('return flag;');
      classNode.addMethod({
        name: 'updateWithParams',
        parameters: [{
          type: _Framework.HomeState.interface,
          name: 'params'
        }],
        returnType: 'boolean',
        statements: updateWithParamsCodeArr
      });
      classConstructor.addStatements(['this.updateWithParams__(params)']);
    }
  }
  translateNormalClassNode(sourceNode, targetFile) {
    // 不在需要生成静态代理,参考 https://jira.n.xiaomi.com/browse/VELAPLATFO-21439

    const newClassNode = targetFile.addClass({
      name: sourceNode.getName(),
      // extends: 'AbstractPropertySubscriber',
      isDefaultExport: sourceNode.isDefaultExport()
    });
    this.addMapData(sourceNode.getNameNode(), newClassNode.getNameNode());
    // 记录类中所有 private 的成员属性
    // let privatePropertyList = sourceNode
    //   .getMembers()
    //   .filter((node) => node instanceof PropertyDeclaration && node.getScope() === Scope.Private)
    //   .map((node) => (node as PropertyDeclaration).getName())
    // 循环子节点
    sourceNode.forEachChild(node => {
      switch (node.getKind()) {
        // case SyntaxKind.PropertyDeclaration:
        //   if (node instanceof PropertyDeclaration) {
        //     // 1. 判断是否为私有成员属性，如果不是private，添加对应的get, set函数
        //     // 2. 如果是private，则直接添加节点
        //     const nodeScope = node.getScope()
        //     const pNode = newClassNode.addProperty(node.getStructure())
        //     if (nodeScope !== Scope.Private) {
        //       const nodeName = node.getName()
        //       const nodeType = node.getTypeNode()
        //       const nodeTypeStr = nodeType?.getText()
        //       pNode.set({
        //         name: `${nodeName}_`,
        //         scope: Scope.Private
        //       })
        //       const isSimpleTypeData = TypeUtil.isSimpleType(nodeTypeStr)
        //       if (isSimpleTypeData) {
        //         this.addGetAccesorFunction(newClassNode, nodeName, nodeTypeStr, `${nodeName}_`)
        //         this.addSetAccesorFunction(newClassNode, nodeName, nodeTypeStr, `${nodeName}_`)
        //       } else {
        //         // 复杂类型的 set 函数
        //         this.addGetAccesorFunction(newClassNode, nodeName, nodeTypeStr, `${nodeName}_`)
        //         this.addProxySetAccesorFunction(
        //           newClassNode,
        //           nodeName,
        //           nodeType as TypeReferenceNode
        //         )
        //       }
        //     }
        //     this.addMapData(node.getNameNode(), pNode.getNameNode())
        //   }
        //   break
        // case SyntaxKind.GetAccessor:
        //   this.translateGetOrSet(node as GetAccessorDeclaration, newClassNode, privatePropertyList)
        //   break
        // case SyntaxKind.SetAccessor:
        //   this.translateGetOrSet(node as SetAccessorDeclaration, newClassNode, privatePropertyList)
        //   break
        case _tsMorph.SyntaxKind.Identifier:
          break;
        default:
          const nodeContent = node.getText();
          newClassNode.addMember(nodeContent);
          break;
      }
    });
  }
  translateInterfaceNode(sourceNode, targetFile) {
    // 添加接口
    const struct = sourceNode.getStructure();
    const interfaceNode = targetFile.addInterface(struct);
    this.addMapData(sourceNode.getNameNode(), interfaceNode.getNameNode());
    //生成代理类
    const type = sourceNode.getName();
    const defaultName = 'rawValue__';
    const proxyClassNode = targetFile.addClass({
      name: `Proxy${type}`,
      extends: 'AbstractProxyValueSubscriber',
      implements: [type]
    });
    proxyClassNode.addProperty({
      name: defaultName,
      type: type,
      scope: _tsMorph.Scope.Private
    });
    // 生成代理类构造函数
    const constructor = proxyClassNode.addConstructor({
      parameters: [{
        name: 'value',
        type: type
      }, {
        name: 'owner',
        type: 'IPropertySubscriber'
      }, {
        name: 'info',
        type: 'PropertyType'
      }],
      statements: ['super(owner, info)', `this.${defaultName} = value`]
    });
    const interfaceProperties = [];
    // 循环 interface中 Property
    sourceNode.getMembers().forEach(node => {
      // 成员属性
      if (node instanceof _tsMorph.PropertySignature) {
        const name = node.getName();
        const typeNode = node.getTypeNode();
        const typeStr = typeNode ? typeNode.getText() : '';
        const returnName = `${name}_`;
        const isSimpleTypeData = _TypeUtil.default.isSimpleType(typeStr);
        if (isSimpleTypeData) {
          // 生成get函数
          this.addGetAccesorFunction(proxyClassNode, name, typeStr, returnName);
          this.addSetAccesorFunction(proxyClassNode, name, typeStr, returnName);
        } else {
          interfaceProperties.push(node);
          proxyClassNode.addProperty({
            name: `${name}_`,
            type: typeStr,
            scope: _tsMorph.Scope.Private
          });
          // 构造函数中给复杂类型赋值
          constructor.addStatements([`this.${name}_ = new Proxy${typeStr}(value.${name}, this, '${name}')`]);
          // 生成get函数
          this.addGetAccesorFunction(proxyClassNode, name, typeStr, returnName);
          this.addProxySetAccesorFunction(proxyClassNode, name, typeNode);
        }
      } else {
        // 成员函数
        const nodeContent = node.getText();
        proxyClassNode.addMember(nodeContent);
      }
    });
    // 生成set中的赋值语句
    let setValueStr = '';
    interfaceProperties.forEach(item => {
      const name = item.getName();
      setValueStr += `this.${name}_ = value.${name}`;
    });
    // getValue__、setValue__
    proxyClassNode.addMethods([{
      name: 'getValue__',
      returnType: type,
      statements: [`return this.${defaultName};`]
    }, {
      name: 'setValue__',
      parameters: [{
        type: type,
        name: 'value'
      }],
      statements: [`this.stopNotify__ = true;`, `this.${defaultName} = value;`, `${setValueStr}`, `this.stopNotify__ = false;`]
    }]);
  }
  translateGetOrSet(sourceNode, classNode, privatePropertyList) {
    let node;
    // 1. 将原本的 get set 函数添加到 classNode 上
    if (sourceNode instanceof _tsMorph.GetAccessorDeclaration) {
      node = classNode.addGetAccessor(sourceNode.getStructure());
    } else {
      node = classNode.addSetAccessor(sourceNode.getStructure());
    }
    this.addMapData(sourceNode.getNameNode(), node.getNameNode());
    // 2. 若 get set 函数类型为 private 是则直接返回
    const scope = sourceNode.getScope();
    if (scope === _tsMorph.Scope.Private) {
      return;
    }
    // 3. 判断函数对应的成员变量是否为 private 是则(get name)修改函数名为（get name_)，并添加一个新的同名函数(get name)
    // 不是则不修改函数名，也不用添加一个新的同名函数
    for (let item in privatePropertyList) {
      const matchs = privatePropertyList[item].match(/^_*(.*)$/);
      const name = matchs ? matchs[1] : '';
      const nodeName = sourceNode.getName();
      if (name === nodeName) {
        node.set({
          name: `${nodeName}_`
        });
        if (sourceNode instanceof _tsMorph.GetAccessorDeclaration) {
          const nodeType = sourceNode.getReturnTypeNode()?.getText();
          this.addGetAccesorFunction(classNode, nodeName, nodeType, `${nodeName}_`);
        } else {
          const nodeType = sourceNode.getParameter('value')?.getTypeNode()?.getText();
          this.addSetAccesorFunction(classNode, nodeName, nodeType, `${nodeName}_`);
        }
      }
    }
  }
  addGetAccesorFunction(classNode, name, type, returnName) {
    classNode.addGetAccessor({
      name,
      returnType: type,
      statements: [`this.propertyRead('${name}');`, `return this.${returnName}`]
    });
  }
  addSetAccesorFunction(classNode, name, type, returnName) {
    const statements = [`if (this.${returnName} == value) return\nthis.${returnName} = value\nthis.propertyChanged('${name}');
      `];
    classNode.addSetAccessor({
      name,
      parameters: [{
        type,
        name: 'value'
      }],
      statements: statements
    });
  }
  addProxySetAccesorFunction(classNode, name, typeNode) {
    const type = typeNode.getText();
    const statements = this.getStatements(name, typeNode);
    classNode.addSetAccessor({
      name,
      parameters: [{
        type,
        name: 'value'
      }],
      statements: statements
    });
  }
  translateMemberMethod(sourceNode, classNode) {
    const methodName = sourceNode.getName();
    if (['render'].includes(methodName)) {
      this.translateRenderMethod(sourceNode, classNode);
    } else {
      this.translateNormalMethod(sourceNode, classNode);
    }
  }
  translateRenderMethod(sourceNode, classNode) {
    const bodyChildren = _TypescriptUtil.default.getBlockChildren(sourceNode.getBody());
    const methodNode = classNode.addMethod({
      name: sourceNode.getName(),
      returnType: _Framework.tsFrameWork.exports.VTag
    });
    this.tsFrameWorkImports.add(_Framework.tsFrameWork.exports.VTag);
    this.addMapData(sourceNode.getNameNode(), methodNode.getNameNode());
    if (bodyChildren) {
      const elementList = this.splitElement(bodyChildren);
      this.translateElementList(elementList, methodNode);
    }
    if (this.elementIndex > 0) {
      methodNode.addStatements('return node_1;');
    }
  }
  translateElementList(elementList, methodNode, parentNodeName) {
    for (let i = 0; i < elementList.length; i++) {
      const element = elementList[i];
      switch (true) {
        case element instanceof _NodeElement.default:
          {
            this.translateNodeElement(element, methodNode, parentNodeName);
            break;
          }
        case element instanceof _IfElement.default:
          {
            this.translateIfElement(element, methodNode, parentNodeName);
            break;
          }
        case element instanceof _ForElement.default:
          this.translateForElement(element, methodNode, parentNodeName);
          break;
        case element instanceof _CommentElement.default:
          break;
        default:
          return this.onLog({
            message: `unexpected sourceNode type`,
            level: _sharedUtils.Loglevel.THROW
          });
      }
    }
  }
  translateForElement(sourceNode, methodNode, parentNodeName) {
    const {
      target,
      keyFunction,
      renderArguments,
      renderElementList
    } = sourceNode;
    const forFun = methodNode.addStatements(`this.renderFor__()`)[0];
    const express = forFun.getExpression();

    // 渲染函数的参数固定为2个，且优化使用源码中的参数名称
    const renderArgumentsList = new Array(2).fill(undefined).map((item, index) => {
      if (renderArguments && renderArguments[index]) {
        return renderArguments[index].getText();
      }
      return `__${index}`;
    });
    // 添加 序号、目标数据 render、key
    const [, targetNode, renderNode] = express.addArguments([`'${++this.elementIndex}'`, target.getText(), `(${renderArgumentsList.join(', ')}, parent?: ${_Framework.tsFrameWork.exports.VTag}) => {}`, keyFunction ? keyFunction.getText() : 'undefined', parentNodeName ? `${parentNodeName}` : 'undefined']);
    this.tsFrameWorkImports.add(_Framework.tsFrameWork.exports.VTag);
    this.addMapData(target, targetNode);
    if (renderElementList) {
      const renderFun = renderNode;
      // 添加render 的内容
      this.translateElementList(renderElementList, renderFun, 'parent');
    }
  }
  translateIfElement(sourceNode, methodNode, parentNodeName) {
    const {
      expression,
      elseElement,
      elements
    } = sourceNode;
    const isElse = sourceNode.isElse;
    if (isElse) {
      // 如果是 else, 只渲染自身的元素
      this.translateElementList(elements, methodNode, 'parent');
    } else {
      // 添加renderIf
      const renderFun = methodNode.addStatements([`this.renderIf__()`])[0];
      const express = renderFun.getExpression();
      // 添加序号
      express.addArgument(`'${++this.elementIndex}'`);
      // 添加if 条件
      express.addArgument(`() => ${expression.getText()}`);

      // 添加if 自身的元素
      const renderElementFunNode = express.addArgument(`(parent?: ${_Framework.tsFrameWork.exports.VTag}) => {}`);
      this.translateElementList(elements, renderElementFunNode, 'parent');
      // 递归添加 else
      if (elseElement) {
        const elseFunNode = express.addArgument(`(parent?: ${_Framework.tsFrameWork.exports.VTag}) => {}`);
        this.translateIfElement(elseElement, elseFunNode, 'parent');
        this.tsFrameWorkImports.add(_Framework.tsFrameWork.exports.VTag);
      } else {
        express.addArgument('undefined');
      }

      // 添加父节点
      if (parentNodeName) {
        express.addArgument(parentNodeName);
      }
    }
  }
  translateNodeElement(sourceNode, methodNode, parentNodeName) {
    const {
      expressList,
      children
    } = sourceNode;
    // 从expressList获取所有表达式的名称和值，第1项做为tag
    let callList = expressList.map(item => _TypescriptUtil.default.splitExpression(item)).flat();
    const tag = callList[0];
    const attributeList = callList.slice(1);
    const index = ++this.elementIndex;
    const nodeName = `node_${index}`;
    const stateMap = new Map();
    function createVariable(name) {
      stateMap.set(_AttributeUtil.default.createVarName(name, index), methodNode.addVariableStatement({
        declarations: [{
          name: _AttributeUtil.default.createVarName(name, index),
          initializer: '{}'
        }]
      }));
    }
    for (const key in _AttributeType.default.ALL_LIST) {
      const name = _AttributeType.default.toString(_AttributeType.default.ALL_LIST[key]);
      createVariable(name);
    }

    // 在函数体中添加元素
    const statements = methodNode.addStatements([`const ${nodeName} = this.renderTag__('${index}', '${tag.name.getText().toLowerCase()}', {});`]);

    // renderTag__ 的第三个参数
    const express = statements[0];
    const initValue = express.getDeclarations()[0].getInitializer();

    // 获取第3个参数，准备给其添加属性
    const option = initValue.getArguments()[2];
    const dir = _path.default.dirname(this.filePath);
    const root = this.projectContext.projectPath;
    // 如果有初始值，添加 attr 属性，并把放到 attr.value 中
    if (tag.value && tag.value.length) {
      if (tag.value.length > 1) {
        this.onLog({
          message: `The argument contains a maximum of 1`,
          level: _sharedUtils.Loglevel.ERROR,
          position: _TypescriptUtil.default.getNodePostion(tag.name, this.context.sourceFile, this.context.offsetList)
        });
      } else {
        const attr = stateMap.get(_AttributeUtil.default.createVarName(_AttributeType.default.toString(_AttributeType.default.ATTRIBUTE), index))?.getDeclarations()[0];
        let initializer = tag.value[0].getText();
        // 如果是图片相关的 value 需要转化
        if (_AttributeType.default.ImageComponet.includes(tag.name.getText())) {
          initializer = _AttributeUtil.default.transformSrc(initializer, dir, root);
        }
        if (_AttributeUtil.default.isDynamicValue(tag.value[0])) {
          _AttributeUtil.default.assignProp(option, {
            name: `hasDynamicAttr`,
            initializer: 'true'
          });
        }
        ;
        attr.getInitializer().addPropertyAssignment({
          name: 'value',
          initializer
        });
      }
    }
    this.addMapData(tag.name, initValue.getExpression());

    // 根据属性名，分别添加到 attr、style、event 中
    if (attributeList && attributeList.length) {
      // 给attributeList排序，以便按照 attr, event, style 顺序添加属性，防止节点位置错乱
      // 例如：[style1, event1, style2], 先添加style1, event1，位置正确；然后添加style2，实际代码会把 event1 往下挤一行，此时 event1 位置错误
      const sortedList = attributeList.concat().sort((a, b) => {
        const typeA = _AttributeUtil.default.getAttributeType(a.name.getText());
        const typeB = _AttributeUtil.default.getAttributeType(b.name.getText());
        return _AttributeType.default.ALL_LIST.indexOf(typeA) - _AttributeType.default.ALL_LIST.indexOf(typeB);
      });
      sortedList.forEach(item => {
        const {
          attributeItem,
          isDynamic,
          type
        } = _AttributeUtil.default.addAttribute(item, stateMap, index, dir, root, this.pushXtsImport.bind(this));
        if (isDynamic && (_AttributeType.default.isStyle(type) || type === _AttributeType.default.toString(_AttributeType.default.ATTRIBUTE))) {
          _AttributeUtil.default.assignProp(option, {
            name: `hasDynamic${_sharedUtils.StringUtil.capitalizeFirstLetter(type)}`,
            initializer: String(isDynamic)
          });
        }
        this.addMapData(item.value[0], attributeItem.getInitializer());
      });
    }

    /** 遍历子节点后，将空的属性删除掉 */
    for (const [name, stateMent] of stateMap) {
      if (stateMent.getDeclarations()[0].getInitializer()?.getText() === '{}') {
        stateMent.remove();
      } else {
        option.addPropertyAssignment({
          name: _AttributeUtil.default.reverseVarName(name),
          initializer: name
        });
      }
    }

    // 如果有父元素，则 addChild
    if (parentNodeName) {
      initValue.addArgument(parentNodeName);
    }

    // 如果有子元素，递归
    if (children && children.length) {
      this.translateElementList(children, methodNode, nodeName);
    }
    return callList;
  }

  /**
   *
   * @param nodeList
   * @returns
   */
  splitElement(nodeList) {
    const result = [];
    const typeList = [_CommentElement.default, _ForElement.default, _IfElement.default, _NodeElement.default];
    let i = 0;
    while (i < nodeList.length) {
      const node = nodeList[i];
      const matchType = typeList.find(item => item.match(node));
      if (matchType) {
        const collectResult = matchType.collect(this.context, nodeList, i, this.splitElement.bind(this));
        result.push(collectResult.element);
        i += collectResult.offset;
      } else {
        this.onLog({
          message: `no matchType`,
          level: _sharedUtils.Loglevel.ERROR,
          position: _TypescriptUtil.default.getNodePostion(node, this.context.sourceFile, this.context.offsetList)
        });
      }
    }
    return result;
  }
  translateNormalMethod(sourceNode, classNode) {
    // 添加方法
    const struct = sourceNode.getStructure();
    const methodNode = classNode.addMethod(struct);

    // 遍历新旧函数的标识符，记录对应关系
    const sourceIdentifiers = sourceNode.getDescendantsOfKind(_tsMorph.SyntaxKind.Identifier);
    const newIdentifiers = methodNode.getDescendantsOfKind(_tsMorph.SyntaxKind.Identifier);
    sourceIdentifiers.forEach((item, index) => {
      this.addMapData(item, newIdentifiers[index]);
    });
  }
  translateMemberProperty(sourceNode, classNode) {
    const name = sourceNode.getName();
    const typeNode = sourceNode.getTypeNode();
    const type = typeNode?.getText();
    const initValue = sourceNode.getInitializer()?.getText();
    const privateName = `${name}`;

    // 在构造函数中插入赋值
    if (initValue) {
      const constructorNode = classNode.getConstructors()[0];
      const initializerStr = sourceNode.getInitializer()?.getText();

      // 不在需要生成静态代理 参考 https://jira.n.xiaomi.com/browse/VELAPLATFO-21439
      // 1. 区分数据类型，生成 initializerStr ：简单数据赋值，Map、Set赋值，interface和类赋值,Array赋值
      // 2. Array类型需要给多层数组添加typedArr_ctors
      // 3. 添加到构造函数中
      // const isSimpleTypeData = TypeUtil.isSimpleType(type)
      // let initializerStr = ''
      // let typedArrCtors_ = ''
      // initializerStr = initializerData ? initializerData : ''
      // if (isSimpleTypeData) {
      // } else {
      //   const { typeArguments, typedArrCtorsStr } = this.translateComplexInitalizer(sourceNode)
      //   initializerStr = typeArguments
      //   typedArrCtors_ = typedArrCtorsStr
      // }
      // if (constructorNode) {
      //   typedArrCtors_ && constructorNode.addStatements(`${typedArrCtors_}`)
      //   constructorNode.addStatements(`this.${privateName} = ${initializerStr || ''}`)
      // }
      constructorNode.addStatements(`this.${privateName} = ${initializerStr || ''};`);
    }

    // 生成私有属性
    const privateNode = classNode.addProperty({
      name: privateName,
      type: type
      // scope: Scope.Private
    });
    this.addMapData(sourceNode.getNameNode(), privateNode.getNameNode());
    // 不在需要生成静态代理,参考 https://jira.n.xiaomi.com/browse/VELAPLATFO-21439
    // 生成 get set
    // this.addGetAccesorFunction(classNode, name, type, privateName)
    // isSimpleTypeData
    //   ? this.addSetAccesorFunction(classNode, name, type, privateName)
    //   : this.addProxySetAccesorFunction(classNode, name, typeNode as TypeReferenceNode)
  }
  /**
   * 处理代理类的构造函数赋值
   * 需要区分Array,Map,Set和Interface,Class
   * @param sourceNode
   * @returns
   */
  translateComplexInitalizer(sourceNode) {
    const name = sourceNode.getName();
    const typeNode = sourceNode.getTypeNode();
    const initializerData = sourceNode.getInitializer()?.getText();
    let typeArguments = '';
    let typeStr = '';
    let typedArrCtorsStr = '';
    let typedArrCtors = '[]';
    if (typeNode instanceof _tsMorph.TypeReferenceNode) {
      typeStr = typeNode.getTypeName().getText();
      const typeArgumentNodes = typeNode.getTypeArguments();
      let typeArgsArray = [];
      typeArgumentNodes.forEach(node => {
        typeArgsArray.push(node.getText());
        // 多层嵌套
        if (node instanceof _tsMorph.TypeReferenceNode) {
          typedArrCtorsStr = this.translateMultiLayerArray(node);
        }
      });
      typeArguments = typeArgsArray.join(', ');
    } else if (typeNode instanceof _tsMorph.ArrayTypeNode) {
      // string[][]嵌套
      typeStr = 'Array';
      const typeArrayNode = typeNode.getElementTypeNode();
      typeArguments = typeArrayNode.getText();
      if (typeArrayNode instanceof _tsMorph.ArrayTypeNode) {
        typedArrCtorsStr = this.translateMultiLayerArray(typeArrayNode);
      }
    }
    if (typedArrCtorsStr) {
      typedArrCtors = `${name}_ctors`;
      typedArrCtorsStr = `const ${typedArrCtors}= [\n${typedArrCtorsStr}\n];`;
    }
    typeArguments = typeArguments ? `new Typed${typeStr}Proxy<${typeArguments}>(${initializerData}, this, ${name}, ${typedArrCtors})` : `new Proxy${typeStr}(${initializerData}, this, '${name}')`;
    return {
      typeArguments,
      typedArrCtorsStr
    };
  }
  /**
   * 处理多层数组在构造函数中的代理和赋值
   * @param sourceNode
   * @returns
   */
  translateMultiLayerArray(sourceNode) {
    let typedArrCtors1 = '';
    let typedArrCtors2 = '';
    let typeArguments = '';
    let typeName = '';
    let typeStr = '';
    if (sourceNode instanceof _tsMorph.ArrayTypeNode) {
      // 例如节点为string[][][]
      const typeNode = sourceNode.getElementTypeNode();
      typeArguments = typeNode.getText();
      typeName = sourceNode.getText();
      typeStr = 'Array';
      if (typeNode instanceof _tsMorph.ArrayTypeNode) {
        typedArrCtors2 = this.translateMultiLayerArray(typeNode);
      }
    } else {
      // 例如节点为Array<Array<string>>
      typeName = sourceNode.getText();
      typeStr = sourceNode.getTypeName().getText();
      const typeArgumentNodes = sourceNode.getTypeArguments();
      let typeArgsArray = [];
      typeArgumentNodes.forEach(node => {
        typeArgsArray.push(node.getText());
        if (node instanceof _tsMorph.TypeReferenceNode) {
          typedArrCtors2 += this.translateMultiLayerArray(node);
        }
      });
      typeArguments = typeArgsArray.join(', ');
    }
    typedArrCtors1 = `
    function(items:${typeName}, owner: IPropertySubscriber, info: PropertyType, proxyCtors: Function[]): Object {
      return new Typed${typeStr}Proxy<${typeArguments}>(items, owner, info, proxyCtors);
    }`;
    return `${typedArrCtors1}\n${typedArrCtors2}`;
  }
  getStatements(name, typeNode) {
    const isProp = false;
    const resultStatements = [];
    const isInterface = _TypeUtil.default.isCustomType(typeNode);
    const type = typeNode?.getText();
    if (isProp) {
      resultStatements.push(`if (this.stopUpdateProps__) return`);
    }
    if (isInterface) {
      const interfaceStatements = [`const oldValue = this.${name}_ as Proxy${type};`, `if (oldValue == value || oldValue.getValue__() == value) return;`, `if (value instanceof Proxy${type}) {`, `  oldValue.unSubscribe(this, '${name}');`, `  (value as Proxy${type}).subscribe(this, '${name}');`, `  this.${name}_ = value;`, `} else {`, `  oldValue.setValue__(value);`, `}`, `this.propertyChanged('${name}');`];
      resultStatements.push(...interfaceStatements);
    } else {
      const privateName = `${name}_`;
      const otherStatements = [`const oldValue = this.${privateName};`, `if (oldValue == value) return;`, `const oldProxy = oldValue as Object as IProxyValueSubscriber;`, `if (oldProxy.getValue__() == value) return;`, `if ($__.isProxyValueSubscriber(value)) {`, `oldProxy.unSubscribe(this, '${name}');`, `(value as Object as IProxyValueSubscriber).subscribe(this, '${name}');`, `this.${privateName} = value;`, `} else {`, `oldProxy.setValue__(value);`, `}`, `this.propertyChanged('${name}');`];
      resultStatements.push(...otherStatements);
    }
    return resultStatements;
  }
  pushXtsImport(target) {
    if (Object.values(_Framework.tsFrameWorkExports).includes(target)) {
      this.tsFrameWorkImports.add(target);
    }
  }
}
var _default = exports.default = XtsToTypescript;