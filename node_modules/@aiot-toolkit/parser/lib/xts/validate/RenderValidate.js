"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _sharedUtils = require("@aiot-toolkit/shared-utils");
var _tsMorph = require("ts-morph");
var _render = _interopRequireDefault(require("../config/render.json"));
var _TypescriptUtil = _interopRequireDefault(require("../utils/TypescriptUtil"));
var _ComponentValidate = _interopRequireDefault(require("./ComponentValidate"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * 校验render内容
 * RenderValidate
 */
class RenderValidate {
  /**
   * 检查节点表达式
   * @param elementList
   * @param startIndex
   * @param sourceFile
   * @returns
   */
  validateNodeElement(elementList, startIndex, context) {
    const {
      sourceFile,
      offsetList,
      onLog
    } = context;
    const node1 = elementList[startIndex];
    // 1. 校验node1，必需为表达式
    if (node1 instanceof _tsMorph.ExpressionStatement) {
      // 2. 检查node1是否为this.renderer函数
      if (this.checkNodeIsThisExpression(node1)) {
        this.validateRenderer(context, node1);
      } else {
        // 3. 组件校验
        new _ComponentValidate.default().componentValidate(node1, context);
      }
    } else {
      onLog({
        message: `entry node must be expression`,
        level: _sharedUtils.Loglevel.ERROR,
        position: _TypescriptUtil.default.getNodePostion(node1, sourceFile, offsetList)
      });
    }
    // 4. startIndex + 2存在节点
    if (elementList.length > startIndex + 3) {
      const node2 = elementList[startIndex + 1];
      const node3 = elementList[startIndex + 2];
      if (node2.getKind() === _tsMorph.SyntaxKind.Block && node3.getKind() === _tsMorph.SyntaxKind.DotToken) {
        const node4 = elementList[startIndex + 3];
        if (node4 instanceof _tsMorph.ExpressionStatement) {
          // 5. 组件校验
          new _ComponentValidate.default().componentValidate(node4, context);
        } else {
          onLog({
            message: 'after docToken must be expression',
            level: _sharedUtils.Loglevel.ERROR,
            position: _TypescriptUtil.default.getNodePostion(node4, sourceFile, offsetList)
          });
        }
      }
    }
    return [];
  }
  /**
   * 检查使用的@renderer函数
   * a. 获取函数调用的函数名
   * b. 找到特殊类，匹配方法名
   *  b1. 未匹配到则报错，没有在class中找到该方法
   *  b2. 匹配到则判断修饰符，有修饰符则通过，没有则报错，方法应该用@renderer修饰
   * @param sourceFile
   * @param element
   * @returns
   */
  validateRenderer(context, element) {
    // 必须在特殊类中找到方法，且方法修饰符列表中存在@Renderer
    const {
      sourceFile,
      onLog,
      offsetList
    } = context;
    const propertyAccessExpression = this.getExpressionOfCallExpression(element);
    if (propertyAccessExpression instanceof _tsMorph.PropertyAccessExpression) {
      const rendererFuncName = propertyAccessExpression.getName();
      const classList = sourceFile.getClasses();
      const specialClass = classList.find(cItem => cItem.getDecorator('parentClass'));
      if (specialClass) {
        const spClassMethod = specialClass.getMethod(rendererFuncName);
        if (spClassMethod) {
          const decorator = spClassMethod.getDecorator('Renderer');
          decorator === undefined && onLog({
            message: `@Renderer modifier dose not exist`,
            level: _sharedUtils.Loglevel.ERROR,
            position: _TypescriptUtil.default.getNodePostion(element, sourceFile, offsetList)
          });
        } else {
          // 方法名找不到
          onLog({
            message: `${rendererFuncName} function dose not exist`,
            level: _sharedUtils.Loglevel.ERROR,
            position: _TypescriptUtil.default.getNodePostion(element, sourceFile, offsetList)
          });
        }
      }
    } else {
      onLog({
        message: `${element.getText()} error`,
        level: _sharedUtils.Loglevel.ERROR,
        position: _TypescriptUtil.default.getNodePostion(element, sourceFile, offsetList)
      });
    }
    return [];
  }
  /**
   * 检查ForEach结构
   * 1. 检查ForEach配置规则
   *  a. 不存在配置信息报错
   * 2. 存在配置，循环参数列表argumentList，列表项argumentList[i]
   *  a. 从rules中寻找j, rules[j].paramIndex === i
   *    b. 不存在则报错，没有对应的参数配置
   *    c. 存在则检查argumentList[i]===undefined
   *      c1. 不等则检查argumentList[i]的kind 是否等于 rules[j].type，不相等就报错，相等就通过
   *      c2. 相等则判断isRequired，true则报错, 否则通过
   * @returns
   */
  validateForEach(context, element, argumentList) {
    const {
      onLog,
      sourceFile,
      offsetList
    } = context;
    const forEachIndex = _render.default.findIndex(item => new RegExp(item.name).test('ForEach'));
    if (forEachIndex !== -1) {
      const rules = _render.default[forEachIndex].rule;
      argumentList.forEach((arguNode, index) => {
        const ruleIndex = rules.findIndex(item => item.paramIndex === index);
        if (ruleIndex !== -1) {
          const rule = rules[ruleIndex];
          const arguNodeKind = arguNode !== undefined ? arguNode.getKindName() : '';
          const arguIsRequired = rule.isRequired === undefined ? true : rule.isRequired;
          // 实参为无效参数
          if (!arguNodeKind) {
            // 若为必需参数，则实参必须传值
            arguIsRequired && onLog({
              message: `The ${index + 1}th parameter in ForEach() must exist`,
              level: _sharedUtils.Loglevel.ERROR,
              position: _TypescriptUtil.default.getNodePostion(element, sourceFile, offsetList)
            });
          }
          // 实参为有效参数
          if (arguNodeKind && arguNodeKind !== rule.type) {
            // 实参类型错误
            onLog({
              message: `The ${index + 1}th parameter in ForEach() must be ${rule.type}`,
              level: _sharedUtils.Loglevel.ERROR,
              position: _TypescriptUtil.default.getNodePostion(arguNode, sourceFile, offsetList)
            });
          }
        } else {
          onLog({
            message: `ForEach() has no corresponding ${index + 1}th parameter configuration`,
            level: _sharedUtils.Loglevel.ERROR,
            position: _TypescriptUtil.default.getNodePostion(element, sourceFile, offsetList)
          });
        }
      });
      if (rules.length > argumentList.length) {
        const rule = rules.find(item => item.paramIndex === argumentList.length);
        rule === undefined && onLog({
          message: `The config rules.length is ${rules.length}, but not find paramIndex`,
          level: _sharedUtils.Loglevel.ERROR,
          position: _TypescriptUtil.default.getNodePostion(element, sourceFile, offsetList)
        });
        const ruleIsRequired = rule?.isRequired === undefined ? true : rule.isRequired;
        ruleIsRequired && onLog({
          message: `The ${argumentList.length + 1}th parameter in ForEach() must exist`,
          level: _sharedUtils.Loglevel.ERROR,
          position: _TypescriptUtil.default.getNodePostion(element, sourceFile, offsetList)
        });
      }
    } else {
      onLog({
        message: `There is no configuration content about ForEach()`,
        level: _sharedUtils.Loglevel.ERROR,
        position: _TypescriptUtil.default.getNodePostion(element, sourceFile, offsetList)
      });
    }
    return [];
  }
  /**
   * 从表达式语句中获取函数调用表达式的属性访问表达式
   * ExpressionStatement--->this.squareText("A")
   * CallExpression--->this.squareText("A")
   * PropertyAccessExpression--->this.squareText
   * @param node
   * @returns
   */
  getExpressionOfCallExpression(node) {
    const callExpression = node.getExpression();
    if (callExpression instanceof _tsMorph.CallExpression) {
      const expression = callExpression.getExpression();
      if (expression instanceof _tsMorph.PropertyAccessExpression || expression instanceof _tsMorph.Identifier) {
        return expression;
      }
    }
    return undefined;
  }
  /**
   * 检查表达式是否为this.function
   * @param node
   * @returns
   */
  checkNodeIsThisExpression(node) {
    const propertyAccessExpression = this.getExpressionOfCallExpression(node);
    if (propertyAccessExpression instanceof _tsMorph.PropertyAccessExpression) {
      const expression = propertyAccessExpression.getExpression();
      return expression.getKind() === _tsMorph.SyntaxKind.ThisKeyword;
    }
    return false;
  }
  /**
   * 检查节点是否为ForEach
   * @param node
   * @returns
   */
  checkNodeIsForEach(node) {
    if (node instanceof _tsMorph.ExpressionStatement) {
      const identifier = this.getExpressionOfCallExpression(node);
      if (identifier instanceof _tsMorph.Identifier) {
        return identifier.getText() === 'ForEach';
      }
    }
    return false;
  }
}
var _default = exports.default = RenderValidate;