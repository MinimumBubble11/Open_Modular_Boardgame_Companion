import { ExpressionStatement, Identifier, Node, PropertyAccessExpression, ts } from 'ts-morph';
import IContext from '../interface/IContext';
import IRenderValidate from '../interface/validate/IRenderValidate';
/**
 * 校验render内容
 * RenderValidate
 */
declare class RenderValidate implements IRenderValidate {
    /**
     * 检查节点表达式
     * @param elementList
     * @param startIndex
     * @param sourceFile
     * @returns
     */
    validateNodeElement(elementList: Node<ts.Node>[], startIndex: number, context: IContext): Error[];
    /**
     * 检查使用的@renderer函数
     * a. 获取函数调用的函数名
     * b. 找到特殊类，匹配方法名
     *  b1. 未匹配到则报错，没有在class中找到该方法
     *  b2. 匹配到则判断修饰符，有修饰符则通过，没有则报错，方法应该用@renderer修饰
     * @param sourceFile
     * @param element
     * @returns
     */
    validateRenderer(context: IContext, element: ExpressionStatement): Error[];
    /**
     * 检查ForEach结构
     * 1. 检查ForEach配置规则
     *  a. 不存在配置信息报错
     * 2. 存在配置，循环参数列表argumentList，列表项argumentList[i]
     *  a. 从rules中寻找j, rules[j].paramIndex === i
     *    b. 不存在则报错，没有对应的参数配置
     *    c. 存在则检查argumentList[i]===undefined
     *      c1. 不等则检查argumentList[i]的kind 是否等于 rules[j].type，不相等就报错，相等就通过
     *      c2. 相等则判断isRequired，true则报错, 否则通过
     * @returns
     */
    validateForEach(context: IContext, element: Node<ts.Node>, argumentList: Node<ts.Node>[]): Error[];
    /**
     * 从表达式语句中获取函数调用表达式的属性访问表达式
     * ExpressionStatement--->this.squareText("A")
     * CallExpression--->this.squareText("A")
     * PropertyAccessExpression--->this.squareText
     * @param node
     * @returns
     */
    getExpressionOfCallExpression(node: ExpressionStatement): PropertyAccessExpression | Identifier | undefined;
    /**
     * 检查表达式是否为this.function
     * @param node
     * @returns
     */
    checkNodeIsThisExpression(node: ExpressionStatement): boolean;
    /**
     * 检查节点是否为ForEach
     * @param node
     * @returns
     */
    checkNodeIsForEach(node: Node<ts.Node>): boolean;
}
export default RenderValidate;
