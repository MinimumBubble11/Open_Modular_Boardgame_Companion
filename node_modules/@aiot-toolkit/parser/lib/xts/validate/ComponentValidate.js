"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _sharedUtils = require("@aiot-toolkit/shared-utils");
var _componentList = _interopRequireDefault(require("../config/componentList"));
var _AttributeUtil = _interopRequireDefault(require("../utils/AttributeUtil"));
var _TypescriptUtil = _interopRequireDefault(require("../utils/TypescriptUtil"));
var _AttibuteValidate = _interopRequireDefault(require("./AttibuteValidate"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * 组件校验
 * ComponentValidate
 */
class ComponentValidate {
  TRANSLATE_TYPE = {
    StringLiteral: 'string',
    NumbericLiteral: 'number',
    ObjectLiteralExpression: 'object'
  };
  componentValidate(element, context) {
    const {
      sourceFile,
      onLog,
      offsetList
    } = context;
    const expressionList = _TypescriptUtil.default.splitExpression(element).flat();
    if (expressionList.length > 0) {
      const expressionNode = expressionList[0];
      const expressionName = expressionNode.name?.getText();
      const expressionValue = expressionNode.value[0];
      const compIndex = _componentList.default.findIndex(comp => comp.name === expressionName);
      if (compIndex !== -1) {
        const componentNode = _componentList.default[compIndex];
        // 检查组件值
        if (expressionValue) {
          const subType0 = componentNode.type ? componentNode.type[0].subType : '';
          // 组件规定不能传值时传值，报错
          !subType0 && onLog({
            message: `Component ${expressionName} has no value attibute`,
            level: _sharedUtils.Loglevel.ERROR,
            position: _TypescriptUtil.default.getNodePostion(element, sourceFile, offsetList)
          });

          // 组件值为静态数据时，进行类型检查
          if (!_AttributeUtil.default.isDynamicValue(expressionValue) && subType0 !== this.TRANSLATE_TYPE[expressionValue.getKindName()]) {
            onLog({
              message: `The static type of value of Component ${expressionName} must be ${subType0}`,
              level: _sharedUtils.Loglevel.ERROR,
              position: _TypescriptUtil.default.getNodePostion(element, sourceFile, offsetList)
            });
          }
        }
        // 遍历属性，进行属性校验
        for (let i = 1; i < expressionList.length; i++) {
          new _AttibuteValidate.default().validate(expressionList[i], context, expressionName);
        }
      } else {
        // 检查自定义组件
        this.customComponentValidate(element, context);
      }
    }
    return [];
  }
  /**
   * 自定义组件校验
   * @param element
   * @param sourceFile
   * @returns
   */
  customComponentValidate(element, context) {
    const {
      onLog,
      sourceFile,
      offsetList
    } = context;
    const expressionList = _TypescriptUtil.default.splitExpression(element).flat();
    if (expressionList.length > 1) {
      onLog({
        message: `Custom Component ${expressionList[0].name?.getText()} are not allowed to have attributes`,
        level: _sharedUtils.Loglevel.WARN,
        position: _TypescriptUtil.default.getNodePostion(element, sourceFile, offsetList)
      });
    }
    return [];
  }
}
var _default = exports.default = ComponentValidate;