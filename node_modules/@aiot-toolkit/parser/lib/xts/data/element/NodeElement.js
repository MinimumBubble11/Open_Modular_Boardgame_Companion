"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _tsMorph = require("ts-morph");
var _TypescriptUtil = _interopRequireDefault(require("../../utils/TypescriptUtil"));
var _ElementBase = _interopRequireDefault(require("./ElementBase"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * 节点元素
 *
 * @example Row()
 */
class NodeElement extends _ElementBase.default {
  /**
   * 表达式列表。一个表达式，可能包含多个节点；例如 a().width().height()是1个表达式，但包含3个节点
   *
   * @see 单个节点，请参考： './IExpressNode.ts'
   */
  expressList = [];

  /**
   * 子元素
   */
  children = [];
  getFullText() {
    return '';
  }

  /**
   * 从指定位置开始，收集1个节点元素
   *
   * ### 收集过程如下
   * 1. 第1个节点必须是表达式，否则报错
   * 2. 如果第2个节点是 block，则2是子元素；否则收集结束。
   * 3. 如果第3个节点是.，则第4也应该是表达式(否则报错），此时：4也作为元素的属性；如果第3个不是点，收集结束
   * @param nodeList 源节点列表
   * @param startIndex 开始位置
   * @returns
   */
  static collect(context, nodeList, startIndex, collectChildren) {
    const {
      sourceFile
    } = context;
    let offset = 0;
    const element = new NodeElement();
    const node1 = nodeList[startIndex];
    const node2 = nodeList[startIndex + 1];
    const node3 = nodeList[startIndex + 2];
    const node4 = nodeList[startIndex + 3];

    // 校验node
    // new RenderValidate().validateNodeElement(nodeList, startIndex, context)
    // node1
    element.expressList.push(node1);
    offset++;
    if (node2 && node2.getKind() === _tsMorph.SyntaxKind.Block) {
      offset++;
      const children = _TypescriptUtil.default.getBlockChildren(node2);
      if (children) {
        element.children = collectChildren(children);
      }

      // node3 和 node4
      if (node3 && node3.getKind() === _tsMorph.SyntaxKind.DotToken) {
        offset++;
        if (node4 && node1.getKind() === _tsMorph.SyntaxKind.ExpressionStatement) {
          offset++;
          element.expressList.push(node4);
        } else {
          _TypescriptUtil.default.throwError(`node must be ExpressionStatement`, node4, sourceFile);
        }
      }
    }
    return {
      offset,
      element
    };
  }
  static match(node) {
    return node.getKind() === _tsMorph.SyntaxKind.ExpressionStatement;
  }
}
var _default = exports.default = NodeElement;