"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _sharedUtils = require("@aiot-toolkit/shared-utils");
var _tsMorph = require("ts-morph");
var _ParserUtil = _interopRequireDefault(require("../../../../utils/ParserUtil"));
var _ElementConfig = _interopRequireDefault(require("../../../config/vela/ElementConfig"));
var _ElementConfigUtil = _interopRequireDefault(require("../../../utils/ElementConfigUtil"));
var _VelaContext = _interopRequireDefault(require("../VelaContext"));
var _TemplateUtil = _interopRequireDefault(require("../utils/TemplateUtil"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * CfTranslate
 */
class CfTranslate {
  KEY = 'for';
  constructor(options) {
    this.options = options;
    this.templateUtil = new _TemplateUtil.default(_VelaContext.default, options, new _ElementConfigUtil.default(_ElementConfig.default));
  }
  match(node) {
    return Boolean(_TemplateUtil.default.getAttribute(node, this.KEY));
  }
  translate(node, childrenExpression, identifiers, extraParams) {
    const {
      onLog,
      filePath
    } = this.options;
    const attribute = _TemplateUtil.default.getAttribute(node, this.KEY);
    const tid = _TemplateUtil.default.getAttribute(node, 'tid');
    if (attribute) {
      const {
        itemNode,
        indexNode,
        listNode
      } = CfTranslate.extractForNodes({
        ...attribute,
        nameLocation: _TemplateUtil.default.parse5LocationToPosition(node.sourceCodeLocation?.attrs?.[this.KEY])
      }, this.options);
      if (!listNode) {
        onLog({
          filePath,
          position: _TemplateUtil.default.parse5LocationToPosition(node.sourceCodeLocation?.attrs?.[this.KEY]),
          level: _sharedUtils.Loglevel.THROW,
          message: [{
            word: 'list'
          }, `value Lost, example: for="list"`]
        });
        return childrenExpression;
      }
      const itemName = itemNode.escapedText;
      const indexName = indexNode.escapedText;
      const listName = listNode.getText();
      const modifiers = this.getModifiers(node);
      const opts = {
        exp: this.genExp(listName, [...identifiers, itemName, indexName], tid?.value, attribute),
        modifiers
      };
      if (indexNode) {
        opts.key = `"${indexName}"`;
      }
      if (itemNode) {
        opts.value = `"${itemName}"`;
      }
      return this.templateUtil.createWrapCallExpression({
        name: '__cf__',
        opts,
        elementExpression: `function(${indexName}, ${itemName}, ${extraParams || ''}){
          return [${childrenExpression}]
        }`
      });
    }
    return childrenExpression;
  }
  getModifiers(node) {
    return _TemplateUtil.default.createDecoratorData(node, 'for', 'exp');
  }
  genExp(listName, identifiers, tid, attribute) {
    const {
      onLog,
      filePath
    } = this.options;
    const listCode = this.templateUtil.translateAttributeValue(this.options, {
      name: attribute?.name || '',
      nameLocation: attribute?.nameLocation,
      value: _TemplateUtil.default.toDynamicValue(listName)
    }, identifiers, Boolean(tid));
    if (!tid) {
      return listCode;
    } else {
      if (_TemplateUtil.default.isDynamicValue(tid)) {
        onLog({
          level: _sharedUtils.Loglevel.THROW,
          filePath,
          message: [{
            word: tid
          }, `tid expecting a static string，actually a dynamic value`],
          position: attribute?.nameLocation
        });
      }
      return `function() {
        return {
          __list__: ${listCode},
          __tid__: ${this.templateUtil.translateAttributeValue(this.options, {
        name: attribute?.name || '',
        nameLocation: attribute?.nameLocation,
        value: tid
      }, identifiers)}
        }
      }`;
    }
  }

  /**
   * 从 for 节点摘取 ： index item list
   *
   * @example
   * (item, index) in data  摘取
   * itemNode=item
   * indexNode=index
   * listNode=data
   *
   * @param attribute
   * @param options
   * @returns
   */
  static extractForNodes(attribute, options) {
    let code = attribute.value;
    const emptyResult = {
      listNode: undefined,
      indexNode: _tsMorph.ts.factory.createIdentifier('$idx'),
      itemNode: _tsMorph.ts.factory.createIdentifier('$item')
    };
    const DEMO_VALUES = ['for="list"', 'for="item in list"', 'for="(index, item) in list"'].map((item, index) => {
      return {
        word: `\r\n${index + 1}. ${item}`,
        style: _sharedUtils.ColorConsole.getStyle(_sharedUtils.Loglevel.SUCCESS)
      };
    });
    if (!code || typeof code !== 'string') {
      return emptyResult;
    }
    const {
      onLog,
      filePath
    } = options;
    code = _TemplateUtil.default.toStaticValue(code);
    // 使用 ts-morph 解析 for 值(别用 babel，会报错)
    const ast = _ParserUtil.default.createSourceFile(code);
    const statements = ast.getStatements();
    // 如果超出1个 statements
    if (statements.length > 1) {
      onLog({
        level: _sharedUtils.Loglevel.THROW,
        message: [`Unsupported for Value: `, {
          word: code
        }, `, Example value: `, ...DEMO_VALUES],
        filePath,
        position: attribute.nameLocation
      });
      return emptyResult;
    }
    const statement = statements[0];
    const expression = statement.getExpression();
    let listNode;
    let indexNode = _tsMorph.ts.factory.createIdentifier('$idx');
    let itemNode = _tsMorph.ts.factory.createIdentifier('$item');
    const validateListNode = node => {
      return [_tsMorph.Identifier, _tsMorph.CallExpression, _tsMorph.PropertyAccessExpression, _tsMorph.BinaryExpression, _tsMorph.ArrayLiteralExpression, _tsMorph.LiteralExpression, _tsMorph.ObjectLiteralExpression, _tsMorph.ElementAccessExpression].findIndex(item => node instanceof item) >= 0;
    };

    // 二元表达式： form="(item,index) in list" 或 for="item in list"
    if (expression instanceof _tsMorph.BinaryExpression && expression.getOperatorToken().getText() === 'in') {
      const binaryExpression = expression;
      const left = binaryExpression.getLeft();

      // 处理左侧
      // ParenthesizedExpression: (index, item)
      if (left instanceof _tsMorph.ParenthesizedExpression) {
        const leftExpression = left.getExpression();
        // 左侧二元表达式：(index, item)
        // 左侧标识符：item
        // 其它情况报错
        if (leftExpression instanceof _tsMorph.BinaryExpression) {
          const index = leftExpression.getLeft();
          const item = leftExpression.getRight();
          // 如果左右都是标识符，符合预期；
          if (item instanceof _tsMorph.Identifier && index instanceof _tsMorph.Identifier) {
            indexNode = index.compilerNode;
            itemNode = item.compilerNode;
          } else {
            if (!(item instanceof _tsMorph.Identifier)) {
              onLog({
                level: _sharedUtils.Loglevel.THROW,
                message: [`Unsupported for->item Value: `, {
                  word: item.getText()
                }, `, Expected Value Is Identifier`],
                filePath,
                position: attribute.nameLocation
              });
            }
            if (!(index instanceof _tsMorph.Identifier)) {
              onLog({
                level: _sharedUtils.Loglevel.THROW,
                message: [`Unsupported for->index Value: `, {
                  word: index.getText()
                }, `, Expected Value Is Identifier`],
                filePath,
                position: attribute.nameLocation
              });
            }
          }
        } else if (leftExpression instanceof _tsMorph.Identifier) {
          const item = leftExpression;
          indexNode = item.compilerNode;
        } else {
          onLog({
            level: _sharedUtils.Loglevel.THROW,
            message: [`Unsupported for-->index/item Value: `, {
              word: left.getText()
            }, `, Expected Value Is Similar: `, ...['item', '(index, item)'].map((item, index) => {
              return {
                word: `\r\n${index + 1}. ${item}`,
                style: _sharedUtils.ColorConsole.getStyle(_sharedUtils.Loglevel.SUCCESS)
              };
            })],
            filePath,
            position: attribute.nameLocation
          });
        }
      }
      // for="item in list"
      else if (left instanceof _tsMorph.Identifier) {
        itemNode = left.compilerNode;
      } else {
        onLog({
          level: _sharedUtils.Loglevel.THROW,
          message: [`Unsupported for-->index/item Value: `, {
            word: left.getText()
          }, `, Expected Value Is Similar: `, ...['item', '(index, item)'].map((item, index) => {
            return {
              word: `\r\n${index + 1}. ${item}`,
              style: _sharedUtils.ColorConsole.getStyle(_sharedUtils.Loglevel.SUCCESS)
            };
          })],
          filePath,
          position: attribute.nameLocation
        });
      }

      // 处理右侧：应当是标识符，不是则报错
      const right = binaryExpression.getRight();
      if (validateListNode(right)) {
        listNode = right.compilerNode;
      } else {
        onLog({
          level: _sharedUtils.Loglevel.THROW,
          message: [`Unsupported for->list Value: `, {
            word: right.getText()
          }, `, Expected Value Is Similar: `, ...['list', 'list()'].map((item, index) => {
            return {
              word: `\r\n${index + 1}. ${item}`,
              style: _sharedUtils.ColorConsole.getStyle(_sharedUtils.Loglevel.SUCCESS)
            };
          })],
          filePath,
          position: attribute.nameLocation
        });
      }
    }
    // Identifier: for="list"
    // CallExpression: for="list()"
    // PropertyAccessExpression: for="data.list"
    else if (validateListNode(expression)) {
      listNode = expression.compilerNode;
    }
    // 其它情况报错
    else {
      onLog({
        level: _sharedUtils.Loglevel.THROW,
        message: [`Unsupported for Value: `, {
          word: code
        }, `, Example value: `, ...DEMO_VALUES],
        filePath,
        position: attribute.nameLocation
      });
    }
    return {
      itemNode,
      indexNode,
      listNode
    };
  }
}
var _default = exports.default = CfTranslate;