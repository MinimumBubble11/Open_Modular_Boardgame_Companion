"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _sharedUtils = require("@aiot-toolkit/shared-utils");
var _tsMorph = require("ts-morph");
var _ElementConfig = _interopRequireDefault(require("../../config/vela/ElementConfig"));
var _TemplateNodeType = _interopRequireDefault(require("../../enum/TemplateNodeType"));
var _ElementConfigUtil = _interopRequireDefault(require("../../utils/ElementConfigUtil"));
var _VelaContext = _interopRequireDefault(require("./VelaContext"));
var _TemplateUtil = _interopRequireDefault(require("./utils/TemplateUtil"));
var _CbTranslate = _interopRequireDefault(require("./wrap/CbTranslate"));
var _CfTranslate = _interopRequireDefault(require("./wrap/CfTranslate"));
var _CiTranslate = _interopRequireDefault(require("./wrap/CiTranslate"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const STATIC_NAME = 'static';

/**
 * TemplateToTypescript
 */
class TemplateToTypescript {
  project = (() => new _tsMorph.Project({
    useInMemoryFileSystem: true,
    manipulationSettings: {
      indentationText: _tsMorph.IndentationText.TwoSpaces
    }
  }))();
  _mapList = [];
  elementConfigUtil = (() => new _ElementConfigUtil.default(_ElementConfig.default))();
  /**
   *
   * @param importList 组件列表
   */
  constructor(options, compilerOption, importList) {
    this.options = options;
    this.compilerOption = compilerOption;
    this.importList = importList;
    this.templateUtil = new _TemplateUtil.default(_VelaContext.default, options, this.elementConfigUtil);
  }

  /**
   *
   * @param sourceTree
   * @param offsetList
   * @returns
   *
   * @see [解析流程](../doc/ux解析流程.md)
   */
  translate(sourceTree,
  // eslint-disable-next-line
  offsetList) {
    this._target = this.project.createSourceFile('temp.ts');
    this._mapList = [];
    const {
      childNodes
    } = sourceTree;
    if (childNodes.length) {
      childNodes.forEach(item => this.translateNode(item));
    } else {
      this._target.addStatements('aiot.__ce__("div", {})');
    }
    return {
      targetTree: this._target,
      mapList: this._mapList
    };
  }
  translateNode(node) {
    if (_TemplateUtil.default.isElement(node)) {
      this._target.addStatements(this.createNodeExpression(node, ['require']));
    }
  }

  /**
   * 生成节点表达式
   * @param node
   * @returns
   */
  createNodeExpression(node, identifiers) {
    // 1. 获取所有属性，并提取数据
    const infomation = this.extractionAttributeInfomation(node);
    // 2. 生成元素表达式
    const elementExpression = this.createElementExpression(node, infomation, identifiers);
    // 3. 生成包裹函数
    return this.createElementWrap(node, elementExpression, infomation, identifiers);
  }

  /**
   * 预处理属性
   * 1. 特定元素和特定属性处理
   *    a. 允许设置文字的元素：如果子元素无节点元素， “文本子元素”做为 value 属性. 例如 `<Text>这里全是文字，没有带 tag 的节点</Text>`
   *    b. 特定元素的特定属性：如果是静态路径，加上 require
   * 2. 去除特殊属性
   * 3. 添加特殊属性
   *    a. 添加static: 存在static属性 && 存在动态属性
   * 4. 属性拆分为属性名和修饰符, 并提取修饰符
        a. static 修饰符：如果元素存在 static 属性，则排除全部属性的 static 修饰符
        b. 特殊属性不生成修饰符：[if elif else]--修饰符生成到 ci 中; for-修饰符生成到 cf 中
        c. 其它情况：生成对象 {[属性名]:{修饰符名:true}}
   * 5. 事件、逻辑属性强制设置为动态属性
   * @param node
   * @returns
   */
  preprocessingProperties(node, extractionInformation) {
    const {
      allowTextChildren
    } = this.elementConfigUtil;
    const unusedAttributes = ['if', 'for', 'elif', 'else', STATIC_NAME, 'tid'];
    const {
      attrs,
      childNodes,
      nodeName
    } = node;
    let result = attrs.map(item => {
      return {
        ...item,
        nameLocation: _TemplateUtil.default.parse5LocationToPosition(node.sourceCodeLocation?.attrs?.[item.name])
      };
    });
    // 1.a
    if (allowTextChildren(nodeName) && !childNodes.some(item => _TemplateUtil.default.isElement(item))) {
      const children = childNodes.filter(item => item.nodeName === _TemplateNodeType.default.TEXT);
      const value = this.templateUtil.getTextContent(node, this.elementConfigUtil);
      if (value) {
        result.push({
          name: 'value',
          value,
          nameLocation: _TemplateUtil.default.parse5LocationToPosition(children[0].sourceCodeLocation)
        });
      }
    }

    // 1.b
    this.templateUtil.convertResourcePath(nodeName, result, this.compilerOption);

    // 2
    result = result.filter(item => {
      const {
        attributeName
      } = _TemplateUtil.default.parseAttributeName(item.name);
      return !unusedAttributes.includes(attributeName);
    });

    // 3
    const {
      hasDynamicValue,
      hasStaticAttribute
    } = extractionInformation;
    if (hasStaticAttribute && hasDynamicValue) {
      result.push({
        name: STATIC_NAME,
        value: true
      });
    }

    // 4
    // ```
    // modifiers:{
    //   attr:{x:true, y:true, z:true}
    // }
    // ```
    const excludesAttributes = ['if', 'for', 'elif', 'else'];
    const modifiers = {};
    result.forEach(item => {
      const {
        name
      } = item;
      const {
        attributeName,
        decorator
      } = _TemplateUtil.default.parseAttributeName(name);
      item.name = attributeName;

      // 4.a
      const effectDecorator = hasStaticAttribute ? decorator?.filter(item => item !== STATIC_NAME) : decorator;

      // 4.b
      if (effectDecorator?.length && !excludesAttributes.includes(attributeName)) {
        const modiferName = attributeName;
        modifiers[modiferName] = Object.fromEntries(effectDecorator.map(item => [item, true]));
      }
    });
    if (Object.keys(modifiers).length > 0) {
      result.push({
        name: 'modifiers',
        value: modifiers
      });
    }

    // 5
    result.forEach(item => {
      const {
        name,
        value
      } = item;
      if (value && this.templateUtil.isForceDynamicAttribute(node.tagName, name) && !_TemplateUtil.default.isDynamicValue(value)) {
        item.value = _TemplateUtil.default.toDynamicValue(value);
      }
    });
    return result;
  }

  /**
   * 创建元素表达式
   *
   * 此方法只创建节点本身的函数
   *
   * 示例：aiot.__ce__("div", {}, [children])
   *
   * 1. 如果是#text 节点，做为<span>文字内容</span> 返回
   * 2. 其它按普通元素处理
   * @param node
   * @returns
   */
  createElementExpression(node, extractionInformation, identifiers) {
    const {
      docHelp
    } = this.options;
    const {
      childNodes,
      nodeName,
      sourceCodeLocation
    } = node;
    if (_TemplateUtil.default.isText(node)) {
      return this.templateUtil.createElementCallExpression(this.options, {
        callerName: '__ce__',
        tag: {
          name: 'span',
          location: _TemplateUtil.default.parse5LocationToPosition(sourceCodeLocation?.startTag)
        },
        attributes: [{
          name: 'value',
          value: this.templateUtil.getTextContent(node, this.elementConfigUtil)
        }],
        identifiers,
        children: ''
      });
    }
    const name = this.getCallExpressionName(node);
    const allowTextChildren = this.elementConfigUtil.allowTextChildren(nodeName);

    // 如果不允许有文本子节点，但是存在，则提示
    if (!allowTextChildren) {
      const textChildren = childNodes.filter(item => _TemplateUtil.default.isText(item) && item.value.trim());
      if (textChildren.length) {
        this.options.onLog({
          level: _sharedUtils.Loglevel.WARN,
          message: [{
            word: nodeName
          }, `unsupport text as child, replace as`, {
            word: `<text>${this.templateUtil.getTextContent(textChildren[0], this.elementConfigUtil)}</text>`
          }, docHelp?.createWidgetReferenceMessage({
            componentName: 'text'
          })],
          filePath: this.options.filePath,
          position: _TemplateUtil.default.parse5LocationToPosition(textChildren[0].sourceCodeLocation)
        });
      }
    }
    let result = '';
    // 提取标识符，用于创建节点函数
    const currentIdentifiers = this.getIdentifiersFromNode(node);
    const allIdentifiers = [...(identifiers || []), ...currentIdentifiers];
    const hasElementChildren = childNodes?.some(item => _TemplateUtil.default.isElement(item));
    const childrenList = childNodes ? childNodes.filter(item => {
      // 当前元素
      // 1. “允许文本子节点，且有普通元素”，则分别处理普通子元素和文本子元素，例如: `<text>aaa<span>abc</span></text>`，需要分别处理 aaa和 <span>abc</span>
      // 2. “只有文本元素”，则无需单独处理，因为文本元素已做为当前元素的 value 属性，例如: `<text>123</text>`, 无需单独处理123
      if (allowTextChildren && hasElementChildren) {
        return _TemplateUtil.default.isElement(item) || _TemplateUtil.default.isText(item) && item.value.trim();
      }
      return _TemplateUtil.default.isElement(item);
    }).map(item => this.createNodeExpression(item, allIdentifiers)) : [];
    let children = childrenList.join(',\r\n');
    if (name) {
      const attributes = this.preprocessingProperties(node, extractionInformation);
      children = `[${children}]`;
      result = this.templateUtil.createElementCallExpression(this.options, {
        callerName: name,
        tag: {
          name: nodeName,
          location: _TemplateUtil.default.parse5LocationToPosition(sourceCodeLocation?.startTag)
        },
        attributes: attributes.map(item => {
          return {
            ...item,
            nameLocation: item.nameLocation || _TemplateUtil.default.parse5LocationToPosition(sourceCodeLocation?.attrs?.[item.name])
          };
        }),
        children,
        identifiers: allIdentifiers,
        importList: this.importList
      });
    } else {
      result = children;
    }
    return result;
  }

  /**
   * 从节点中提取标识符列表
   *
   * 例如从 <div for="(item, index) in data"/> 提取 item ,index
   *
   * 目前只有一种情况：for
   * @param element
   */
  getIdentifiersFromNode(node) {
    const result = [];
    // for
    const NAME = 'for';
    const forAttribute = _TemplateUtil.default.getAttribute(node, NAME);
    if (forAttribute) {
      const {
        itemNode,
        indexNode
      } = _CfTranslate.default.extractForNodes(forAttribute, this.options);
      [itemNode, indexNode].forEach(item => {
        if (item) {
          result.push(item.escapedText.toString());
        }
      });
    }
    return result;
  }

  /**
   * 获取函数调用表达式的名称
   * 1. 无：block**
   * 1. ✓cc: 自定义组件
   * 1. ✓cdc: (is/remotewidget) + component
   * 1. ✓ ce: 一般情况
   * @returns
   */
  getCallExpressionName(node) {
    const {
      tagName,
      attrs
    } = node;
    let result = '';
    if (tagName === 'block') {
      result = '';
    } else if (this.isCustomeComponent(tagName)) {
      result = `cc`;
    } else if (tagName === 'component' && attrs.find(item => ['is', 'remotewidget'].includes(item.name))) {
      result = 'cdc';
    } else {
      result = 'ce';
    }
    return result ? `__${result}__` : '';
  }

  /**
   * 是否是自定义组件
   * @param componentName 组件名称
   * @returns
   */
  isCustomeComponent(componentName) {
    const {
      importList
    } = this;
    return importList?.map(item => item.toLowerCase()).includes(componentName.toLowerCase());
  }

  /**
   * 生成包裹元素
   * 1. 文字：无包裹内容
   * 2. 通过block-cb, for-cf,  if-ci 检查是否有包裹层
   * @param node
   * @param elementExpression
   * @returns
   */
  createElementWrap(node, elementExpression, infomation, identifiers) {
    // 1
    if (_TemplateUtil.default.isText(node)) {
      return elementExpression;
    }
    const translateList = [new _CbTranslate.default(this.options, infomation), new _CfTranslate.default(this.options), new _CiTranslate.default(this.options)];
    const params = this.compilerOption?.enableProtobuf ? ['aiot'].join(',') : '';
    let result = elementExpression;
    for (let item of translateList) {
      if (item.match(node)) {
        result = item.translate(node, result, identifiers, params);
      }
    }
    return result;
  }

  /**
   * 提取节点属性信息
   *
   * 1. 根据属性提示属性信息
   * 2. 对于文本类元素，是否有动态属性，还需要检查文本内容。 例如：<text>{{aa}}</text> 也应判定为有动态值
   * @param node
   * @returns
   */
  extractionAttributeInfomation(node) {
    const {
      allowTextChildren
    } = this.elementConfigUtil;
    const result = {
      hasDynamicValue: false,
      hasStaticAttribute: false,
      hasStaticDecorator: false,
      hasEvent: false
    };
    const {
      attrs,
      nodeName
    } = node;
    if (attrs && attrs.length) {
      for (let item of attrs) {
        const {
          value,
          name
        } = item;
        const {
          decorator,
          attributeName
        } = _TemplateUtil.default.parseAttributeName(name);
        // 是否有动态属性，不考虑 if/for
        if (!result.hasDynamicValue && !['if', 'for'].includes(attributeName.toLowerCase())) {
          result.hasDynamicValue = _TemplateUtil.default.isDynamicValue(value);
        }
        if (!result.hasStaticAttribute) {
          result.hasStaticAttribute = attributeName.toLowerCase() === STATIC_NAME;
        }
        if (!result.hasStaticDecorator) {
          result.hasStaticDecorator = attributeName !== STATIC_NAME && Boolean(decorator?.includes(STATIC_NAME));
        }
        if (!result.hasEvent) {
          result.hasEvent = _TemplateUtil.default.isEventAttribute(attributeName);
        }
        // 如果所有条件都确认，停止提取以提高性能
        if (!Object.values(result).includes(false)) {
          break;
        }
      }
    }

    // 对于文本元素，是否有动态属性还需要检查文本内容
    if (!result.hasDynamicValue && allowTextChildren(nodeName)) {
      const textNode = node.childNodes.filter(item => item.nodeName === _TemplateNodeType.default.TEXT);
      const hasDynamicValue = textNode.some(item => _TemplateUtil.default.isDynamicValue(item.value));
      result.hasDynamicValue = hasDynamicValue;
    }
    return result;
  }
}
var _default = exports.default = TemplateToTypescript;