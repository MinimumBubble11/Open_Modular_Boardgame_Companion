"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _sharedUtils = require("@aiot-toolkit/shared-utils");
var _generator = _interopRequireDefault(require("@babel/generator"));
var traverse = _interopRequireWildcard(require("@babel/traverse"));
var types = _interopRequireWildcard(require("@babel/types"));
var _TemplateNodeType = _interopRequireDefault(require("../../../enum/TemplateNodeType"));
var _TemplateValueParser = _interopRequireWildcard(require("../../../parser/TemplateValueParser"));
var _BabelUtil = _interopRequireDefault(require("../../../utils/BabelUtil"));
var _AttributeConfig = _interopRequireWildcard(require("./AttributeConfig"));
var babelParser = _interopRequireWildcard(require("@babel/parser"));
var _fs = _interopRequireDefault(require("fs"));
var _path = _interopRequireDefault(require("path"));
var _UxUtil = _interopRequireDefault(require("../../../utils/UxUtil"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * TemplateUtil
 */
class TemplateUtil {
  static DYNAMIC_REG = '{{([\\s\\S]*?)}}';
  constructor(context, option, elementConfigUtil) {
    this.context = context;
    this.option = option;
    this.elementConfigUtil = elementConfigUtil;
  }

  /**
   * 属性列表转换为字典格式
   *
   * @param obj
   * @returns
   */
  attributesToObject(options, attributes, identifiers, params) {
    if (!attributes || !Array.isArray(attributes)) {
      return {};
    }
    const dataSetStart = 'data-';

    /**
     * 重命名 dataset 属性
     *
     * 1. 去掉data-
     * 2. -字母 转换为大写字母
     *
     * > data-aa-bbb 格式 转换成 aaBbb
     * @param value
     * @returns
     */
    const renameDatasetAttribute = value => {
      return value.substring(dataSetStart.length).replace(/-([a-z])/g, function (s, m) {
        return m.toUpperCase();
      });
    };
    const separateModelValue = params?.separateModelValue;
    const nameToCamel = params?.nameToCamel;
    const result = {};
    attributes.forEach(item => {
      const {
        name
      } = item;
      const attributeName = this.translateAttributeName(item.name);
      const effectAttributeName = nameToCamel ? _sharedUtils.StringUtil.hyphenedToCamel(attributeName) : attributeName;
      const attributeValue = this.translateAttributeValue(options, item,
      // 事件属性，evt 做为已定义的参数, 因为旧项目很多类似这样的代码
      // `onclick="fun(evt.value)"`
      TemplateUtil.isEventAttribute(name) ? [...identifiers, 'evt'] : identifiers);
      switch (true) {
        case name.startsWith(dataSetStart):
          if (!result.dataset) {
            result.dataset = {};
          }
          result.dataset[renameDatasetAttribute(attributeName)] = attributeValue;
          break;
        case TemplateUtil.isEventAttribute(name):
          if (!result.events) {
            result.events = {};
          }
          result.events[attributeName] = attributeValue;
          break;
        case separateModelValue && TemplateUtil.isModelAttribute(name):
          if (!result.models) {
            result.models = {};
          }
          result.models[effectAttributeName] = item.value;
          break;
        default:
          result[effectAttributeName] = attributeValue;
          break;
      }
    });
    return result;
  }

  /**
   * 转换属性名称
   * 1. 配置中有别名，使用别名
   * 2. 如果是@， on开头，则取@ on后面的文本
   * 3. 原名称
   * @param name
   */
  translateAttributeName(name) {
    const config = _AttributeConfig.default[name];
    if (config?.aliasName) {
      return config.aliasName;
    }
    if (TemplateUtil.isEventAttribute(name)) {
      return TemplateUtil.translateEventName(name);
    }
    return name;
  }

  /**
   * 转换属性值
   * 1. 无内容=true
   * 2. 非字符串，直接返回结果
   * 3. 属性值转换为 js 代码
   *    a. 如果有单独的配置，则使用配置转换
   *    b. 否则，如果是动态值，则分为事件和其它动态值
   *    c. 否则，返回源内容
   * @param attribute
   * @returns
   */
  translateAttributeValue(options, attribute, identifiers) {
    let disabledWrap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    let {
      name,
      value,
      valueUnset
    } = attribute;
    const config = _AttributeConfig.default[name];

    // 1
    if (!value) {
      return valueUnset ? true : "''";
    }
    // 2
    if (typeof value !== 'string') {
      return value;
    }

    //  3
    let {
      result,
      dynamic,
      nodeCount
    } = this.translateTemplateValue(value, identifiers, options, attribute);

    // 3.a
    if (config && config.translate) {
      result = config.translate({
        result,
        dynamic,
        nodeCount
      });
    }
    // 3.b
    else if (dynamic) {
      if (TemplateUtil.isEventAttribute(name)) {
        result = (0, _AttributeConfig.eventAttributeTranslate)(options, result, attribute);
      } else {
        result = (0, _AttributeConfig.defaultAttributeTranslate)(result, disabledWrap);
      }
    }
    // 3.c
    return result;
  }

  /**
   * 解析模板值
   *
   * 1. 使用TemplateValueParser.parse 解析出结果列表
   * 2. 循环结果列表
   *    a. 代码：部分标识符加上前缀
   *    b. 文字：加上引号
   * 3. 使用+连接各项结果
   *
   * @param source 模板值的原始内容: a{{b}}c
   * @param identifiers 已存在的标识符. 存在于此参数中的标识符，不加前缀
   * @param options
   * @param ownerNode source 模板值所属的属性节点:  for="forvalue", 表示for 这个节点
   *
   * @returns
   */
  translateTemplateValue(source, identifiers, options, ownerNode) {
    const {
      onLog,
      filePath
    } = options;
    const nameLocation = ownerNode?.nameLocation;

    /**
     * 遍历标识符，如果满足以下条件，不加前缀
     * a. 节点名称在参数的标签符中
     * b. 全局定义: console
     * c. 在局部作用域定义: `const a = 0;  log(a)` 中的 a
     * d. 是调用链且是静态值: `data.x` 的 x. *注意*：data[x] 中的 x 是动态值, data[x] --> this.data[this.x]
     * e. 是对象的属性: `{x:**}` 的 x
     * @param code
     * @returns
     */
    const translateJsCode = code => {
      const {
        dataInstanceValue
      } = this.context;
      const expression = babelParser.parseExpression(code);
      if (types.isStringLiteral(expression)) {
        return code;
      }
      const ast = types.file(types.program([types.expressionStatement(expression)]));
      const bodyNode = ast?.program.body[0];
      if (ast) {
        traverse.default(ast, {
          Identifier(path) {
            const name = path.node.name;

            // a
            if (identifiers.includes(name)) {
              return;
            }

            // b
            if (globalThis[name]) {
              return;
            }

            // c
            if (path.scope.hasBinding(name)) {
              return;
            }

            // d
            if (types.isMemberExpression(path.parent) && path.parent.property === path.node) {
              const {
                computed
              } = path.parent;
              if (!computed) {
                return;
              }
            }

            // e
            if (_BabelUtil.default.isObjectKeyIdentifier(path.node, path.parent)) {
              return;
            }
            path.node.name = `${dataInstanceValue}.${name}`;
          }
        });
        return (0, _generator.default)(bodyNode.expression, {
          minified: true,
          concise: true
        }).code;
      }
      return '';
    };
    try {
      const valueList = new _TemplateValueParser.default().parse(source);
      const expressionList = valueList.map(item => {
        if (item.type === _TemplateValueParser.TemplateValueType.CHAR) {
          return JSON.stringify(item.value);
        } else {
          const code = translateJsCode(item.value);
          // 如果有多个表达式，则用括号包裹；防止出现前两个表达式混在一起
          // 例如: 'a' + b < 0 ? true : false， 会先计算出 'a' + b，再判断
          return valueList.length > 1 ? `(${code})` : code;
        }
      });
      return {
        result: expressionList.join(' + ') || `''`,
        dynamic: valueList.some(item => item.type === _TemplateValueParser.TemplateValueType.CODE),
        nodeCount: valueList.length
      };
    } catch (error) {
      onLog({
        level: _sharedUtils.Loglevel.THROW,
        message: error.message,
        filePath,
        position: nameLocation
      });
      return {
        result: '',
        dynamic: true,
        nodeCount: 0
      };
    }
  }
  createWrapCallExpression(struct) {
    const {
      name,
      opts,
      elementExpression
    } = struct;
    const {
      globalInstance,
      dataInstance,
      dataInstanceValue
    } = this.context;
    return `${globalInstance}.${name}(${_sharedUtils.StringUtil.objectToString({
      [dataInstance]: dataInstanceValue,
      __opts__: opts
    })}, ${elementExpression})`;
  }

  /**
   * 创建元素调用表达式
   * ```
   * aiot.__ce__(
   *  "div",
   *  {name:'div1'},
   *  children
   * )
   * ```
   * @param struct
   * @returns
   */
  createElementCallExpression(options, struct) {
    const {
      validateElement,
      getElementConfig
    } = this.elementConfigUtil;
    const {
      callerName,
      tag,
      attributes,
      children,
      identifiers,
      importList
    } = struct;
    const {
      onLog
    } = options;
    if (!validateElement(options, tag, attributes, importList)) {
      onLog({
        filePath: options.filePath,
        position: tag.location,
        level: _sharedUtils.Loglevel.THROW,
        message: `validateElement ${tag} error`
      });
      return `validateElement ${tag} error`;
    }
    const elementConfig = getElementConfig(tag.name);
    const effectTag = elementConfig?.aliasName || tag.name;
    const {
      globalInstance,
      dataInstance,
      dataInstanceValue
    } = this.context;
    const result = `${globalInstance}.${callerName}("${effectTag}", ${_sharedUtils.StringUtil.objectToString({
      [dataInstance]: dataInstanceValue,
      __opts__: this.attributesToObject(options, attributes, identifiers, {
        nameToCamel: true
      })
    })}, ${children})`;
    return result;
  }

  /**
   * 获取节点指定名称的属性
   *
   * 此方法会排除修饰符，例如<div for.static="123" />；使用getAttribute(node, "for") 仍可取到值
   *
   * @param node
   * @param name
   * @returns
   */
  static getAttribute(node, name) {
    const {
      attrs
    } = node;
    const target = attrs.find(item => TemplateUtil.parseAttributeName(item.name).attributeName.toLowerCase() === name);
    if (target) {
      return {
        ...target,
        nameLocation: TemplateUtil.parse5LocationToPosition(node.sourceCodeLocation?.attrs?.[target.name])
      };
    }
  }

  /**
   * 解析属性名为名称、修饰符
   *
   * 以 attr.x.y.z="123"为例
   * + 属性名使用.分隔为数组 [attr, x, y, z]
   * + 第0项为属性名，1-最后一项为修饰符名
   * @param name
   * @returns
   */
  static parseAttributeName(name) {
    if (!name) {
      return {
        attributeName: ''
      };
    }
    const list = name.split('.');
    return {
      attributeName: list[0],
      decorator: list.length > 1 ? list.slice(1) : undefined
    };
  }

  /**
   * 判断是否强制为动态值
   * 1. 事件属性
   * 2. if  for
   * 3. 配置值
   * @param nodeName 节点名称
   * @param attributeName 属性名称
   * @returns
   */
  isForceDynamicAttribute(nodeName, attributeName) {
    const {
      getElementConfig
    } = this.elementConfigUtil;
    const forceDynamicList = ['if', 'for'];
    let result = TemplateUtil.isEventAttribute(attributeName) || forceDynamicList.includes(attributeName.toLowerCase());
    if (!result) {
      const config = getElementConfig(nodeName)?.attributes?.[attributeName];
      if (config && config.forceDynamic) {
        result = true;
      }
    }
    return result;
  }
  static parse5LocationToPosition(location) {
    if (!location) {
      return;
    }
    return {
      pos: 0,
      end: 0,
      startLine: location.startLine,
      startColumn: location.startCol,
      endLine: location.endLine,
      endColumn: location.endCol
    };
  }
  static translateEventName(name) {
    return name.replace(/^(@|on)(.*)$/, '$2');
  }
  static isText(node) {
    return node.nodeName === _TemplateNodeType.default.TEXT;
  }

  /**
   * 是否为节点元素
   *
   * @example <span></span>
   * @param node
   * @returns
   */
  static isElement(node) {
    return ![_TemplateNodeType.default.COMMENT, _TemplateNodeType.default.DOCUMENT_TYPE, _TemplateNodeType.default.TEMPLATE, _TemplateNodeType.default.TEXT].includes(node.nodeName);
  }
  static isDynamicValue(value) {
    return new RegExp(this.DYNAMIC_REG).test(value);
  }
  static isEventAttribute(name) {
    return name.startsWith('@') || name.startsWith('on');
  }

  /**
   * 是否是 model 指令的属性
   * @param name
   * @returns
   */
  static isModelAttribute(name) {
    return name.startsWith('model:');
  }

  /**
   * 解析model 指令属性的名称为： {modelName: '', modelValue: ''}
   *
   * 例如 `model:abcde="xyz"` 解析为 `{modelName: 'abcde', modelValue:'xyz'}`
   * @param name
   */
  parseModelAttribute(node) {
    const {
      name,
      value
    } = node;
    if (TemplateUtil.isModelAttribute(name)) {
      const [, modelName] = name.split(':');
      const modelValue = this.translateTemplateValue(TemplateUtil.toDynamicValue(value), [], this.option, node);
      return {
        modelName,
        modelValue: modelValue.result
      };
    }
    return;
  }

  /**
   * 值转换为动态值
   *
   * 如果已经是动态值，则不做修改
   * @param value
   * @returns
   */
  static toDynamicValue(value) {
    if (this.isDynamicValue(value)) {
      return value;
    }
    return `{{${value}}}`;
  }

  /**
   * 值转换为静态值
   *
   * 已经是静态值，不做修改
   * @param value
   * @returns
   */
  static toStaticValue(value) {
    if (this.isDynamicValue(value)) {
      return value.replace(new RegExp(this.DYNAMIC_REG), '$1');
    }
    return value;
  }

  /**
   * 创建修饰符数据
   *
   *
   * @example createDecoratorData(node, 'if', 'shown')
   *
   * 如果 node 有 if 属性, 例如<div if.static1.static2="aaa" />，则创建属性名为shown的修改符对象
   * ```
   * {
   *   shown:{static1: true,static2: true}
   * }
   * ```
   * @param node
   * @param attributeName
   * @param decoratorName
   * @returns
   */
  static createDecoratorData(node, attributeName, decoratorName) {
    const attribute = TemplateUtil.getAttribute(node, attributeName);
    if (attribute) {
      const {
        decorator
      } = TemplateUtil.parseAttributeName(attribute?.name);
      if (decorator) {
        return {
          [decoratorName]: Object.fromEntries(decorator.map(item => [item, true]))
        };
      }
    }
    return undefined;
  }

  /**
   * 条件列表转换为表达式
   *
   * 转换规则为：前置条件全部取反 && 自身条件
   *
   * @param condition
   * @returns
   */
  genIfConditionList(condition, identifiers) {
    const {
      preConditions,
      selfCondition
    } = condition;
    const result = (preConditions?.map(item => this.translateTemplateValue(TemplateUtil.toDynamicValue(item.value), identifiers, this.option, item).result).map(item => {
      return `!(${item})`;
    }) || []).concat(selfCondition ? [this.translateTemplateValue(TemplateUtil.toDynamicValue(selfCondition.value), identifiers, this.option, selfCondition).result] : []).map(item => `(${item})`).join(' && ');
    return result;
  }

  /**
   * 获取 `if` 的条件列表
   *
   * 1. selfCondition=需要取节点身的条件
   * 2. preConditions=前置节点的条件--当前节点是 elif   else 时，需要取前置节点
   * @param node
   * @param options
   * @returns
   */
  static getIfCoditionList(node, options) {
    const ifAttribute = TemplateUtil.getAttribute(node, 'if');

    // 如果有 if 属性，直接返回 if 的值
    if (ifAttribute) {
      return {
        selfCondition: ifAttribute
      };
    }
    const {
      onLog,
      filePath
    } = options;

    // 如果是 elif、else，向前搜索同级节点（遇到 if 属性停止），并返回值列表
    const elIfAttribute = TemplateUtil.getAttribute(node, 'elif');
    const elseAttribute = TemplateUtil.getAttribute(node, 'else');
    const effectAttribute = elIfAttribute || elseAttribute;
    if (effectAttribute) {
      const result = [];
      const {
        parentNode
      } = node;
      if (parentNode) {
        const childNodes = parentNode.childNodes.filter(item => _TemplateNodeType.default.isEffectElement(item));
        // 获取当前节点所在的位置，并向前搜索，对于循环到的项
        // 异常情况
        //  1. 非空文本元素，报错
        //  2. 无if elif，报错
        //  3. 循环到第0项，无 if 属性，报错
        //  4. 同时有 if elif else，报错
        //  5. 正常情况
        //     a. 遇到 if，停止循环
        //     b. 每一项的if 或 elif 属性值放到结果列表中
        const nodeIndex = childNodes.findIndex(item => item === node);
        if (nodeIndex >= 1) {
          for (let i = nodeIndex - 1; i >= 0; i--) {
            const item = childNodes[i];
            // 1
            if (_TemplateNodeType.default.isUnEmptyText(item)) {
              const textNode = item;
              onLog({
                filePath,
                position: TemplateUtil.parse5LocationToPosition(textNode.sourceCodeLocation),
                level: _sharedUtils.Loglevel.THROW,
                message: [`Expected Node Element But Actually Text:`, {
                  word: textNode.value
                }]
              });
              break;
            }
            const element = item;
            const itemIf = TemplateUtil.getAttribute(element, 'if');
            const itemElIf = TemplateUtil.getAttribute(element, 'elif');
            const itemElse = TemplateUtil.getAttribute(element, 'else');
            // 2
            if (!itemIf && !itemElIf) {
              onLog({
                filePath,
                position: TemplateUtil.parse5LocationToPosition(element.sourceCodeLocation?.startTag),
                level: _sharedUtils.Loglevel.THROW,
                message: [{
                  word: element.nodeName
                }, `missing if or elif attribute`]
              });
            }

            // 3
            if (i === 0 && !itemIf) {
              onLog({
                level: _sharedUtils.Loglevel.THROW,
                filePath,
                position: TemplateUtil.parse5LocationToPosition(element.sourceCodeLocation?.startTag),
                message: [`the first element requires`, {
                  word: 'if'
                }, `attribute`]
              });
              return;
            }

            // 4
            if ([itemIf, itemElIf, itemElse].filter(item => Boolean(item)).length > 1) {
              onLog({
                position: TemplateUtil.parse5LocationToPosition(item.sourceCodeLocation),
                filePath,
                level: _sharedUtils.Loglevel.THROW,
                message: [`if/elif/else can only have one`, {
                  word: element.nodeName
                }]
              });
              return;
            }
            if (itemIf) {
              result.push(itemIf);
            } else if (itemElIf) {
              result.push(itemElIf);
            }
            // 5
            if (itemIf) {
              break;
            }
          }
        } else {
          onLog({
            filePath,
            position: TemplateUtil.parse5LocationToPosition(childNodes[0].sourceCodeLocation),
            level: _sharedUtils.Loglevel.THROW,
            message: [{
              word: 'elif/else'
            }, 'cannot be used as the first item']
          });
          return;
        }
        // 元素自身的属性放到最后
        return {
          preConditions: result,
          selfCondition: ifAttribute || elIfAttribute
        };
      }
    }
  }

  /**
   * 元素的属性转换为资源路径
   * 1. 属性本身无需转换，不处理
   * 2. 是动态值、绝对路径，不处理
   * 3. 如果是静态值
   *    3.1. 如果文件在src中，转换为相对src的路径: 例如project/src/assets/a/b.png 转换为 /assets/a/b.png
   *    3.2. 否则修改为 require()
   */
  convertResourcePath(nodeName, attrs, compilerOption) {
    const shouldDic = {
      img: {
        src: true
      },
      video: {
        src: true
      },
      maml: {
        src: true
      },
      lottie: {
        source: true
      }
    };

    // 1
    if (!shouldDic[nodeName]) {
      return;
    }
    const targetAttrs = attrs.filter(item => Boolean(shouldDic[nodeName][item.name]));
    if (!targetAttrs.length) {
      return;
    }
    const {
      filePath,
      projectPath,
      onLog
    } = this.option;
    const {
      sourceRoot
    } = compilerOption;
    targetAttrs.forEach(item => {
      const {
        value
      } = item;
      // 2
      if (TemplateUtil.isDynamicValue(value) || _UxUtil.default.isAbsoluteResource(value)) {
        return;
      }
      //#region 3

      const srcPath = _path.default.join(projectPath, sourceRoot);
      const resourcePath = _path.default.resolve(_path.default.dirname(filePath), value);
      // 3.1
      if (resourcePath.startsWith(srcPath)) {
        item.value = resourcePath.slice(srcPath.length).split(_path.default.win32.sep).join(_path.default.posix.sep);
      }
      // 3.2
      else {
        item.value = `{{require('${value}')}}`;
      }
      if (!_fs.default.existsSync(resourcePath)) {
        onLog({
          level: _sharedUtils.Loglevel.THROW,
          message: [{
            word: `${value}`
          }, {
            word: `[absourcePath: ${resourcePath}]`
          }, `文件不存在`],
          filePath,
          position: item.nameLocation
        });
      }

      //#endregion
    });
  }

  /**
   * 获取节点中的文字内容
   *
   * 1. 如果是文字元素，返回 value
   * 1. 循环子元素列表
   *    1. 如果子元素是文本，直接返回内容
   *    2. 否则，如果子元素允许文本，则递归获取结果
   * 2. 文字中连续的特定符号[\r\n\t ]
   *    1. 首尾的替换为空字符串
   *    2. 其它替换为1个空格
   *
   * @example
   * `
   *    a
   *    b
   *
   * ` --> `a b
   *
   * @param node
   */
  getTextContent(node, elementConfig) {
    let result = '';
    if (TemplateUtil.isText(node)) {
      result = node.value;
    } else {
      const {
        childNodes
      } = node;
      childNodes.forEach(item => {
        if (item.nodeName === _TemplateNodeType.default.TEXT) {
          result += item.value;
        } else if (elementConfig.allowTextChildren(item.nodeName)) {
          result += this.getTextContent(item, elementConfig);
        }
      });
    }
    result = result.replace(/(^[\r\n\t ]+)|([\r\n\t ]+$)|[\r\n\t ]+/g, (match, p1, p2) => {
      if (p1 || p2) {
        return '';
      }
      return ' ';
    });
    return result;
  }
}
var _default = exports.default = TemplateUtil;