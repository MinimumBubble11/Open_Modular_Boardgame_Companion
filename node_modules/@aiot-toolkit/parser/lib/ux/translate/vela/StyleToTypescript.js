"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _sharedUtils = require("@aiot-toolkit/shared-utils");
var _StyleSelectorType = require("../../enum/StyleSelectorType");
var _StyleUtil = _interopRequireDefault(require("../../utils/StyleUtil"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * StyleToTypescript
 */
class StyleToTypescript {
  constructor(options, compilerOption) {
    this.options = options;
    this.compilerOption = compilerOption;
  }
  translate(sourceTree,
  // eslint-disable-next-line
  offsetList) {
    const styleList = sourceTree.styleContent;
    const cssResult = this.translateNodes(styleList);
    let compressCssResult = [];
    // 是否压缩css属性名
    if (this.compilerOption.optimizeCssAttr) {
      compressCssResult = _StyleUtil.default.compressStyleAttributeName(cssResult);
      return {
        targetTree: compressCssResult,
        mapList: []
      };
    }
    return {
      targetTree: cssResult,
      mapList: []
    };
  }
  translateNodes(sourceNodes) {
    let resultList = [];
    for (const styleNode of sourceNodes) {
      const {
        type: nodeType
      } = styleNode;
      let translateList = [];
      if (nodeType === _StyleSelectorType.IRuleTypes.RULE) {
        translateList = this.translateRule(styleNode);
      }
      if (nodeType === _StyleSelectorType.IRuleTypes.AT_RULE) {
        if ('block' in styleNode) {
          translateList = this.translateNoPreludeAtRule(styleNode);
        } else {
          translateList = this.translateAtrule(styleNode);
        }
      }
      // 遍历返回的列表，寻找是否存在相同选择器，若存在则合并属性，重复属性也需要合并
      resultList = _StyleUtil.default.mergeSelectorList(resultList, translateList);
    }
    return resultList;
  }
  translateRule(sourceNode) {
    const {
      prelude,
      block,
      position
    } = sourceNode;
    const targetNodes = [];
    // 记录selector列表
    let selectorList = [];
    // 记录block样式列表
    let blockResult = {};
    if (prelude) {
      selectorList = this.translateNormalPrelude(prelude, position);
    }
    if (block) {
      blockResult = _StyleUtil.default.translateBlock(block, this.options);
      Object.keys(blockResult).forEach(item => {
        blockResult[item] = _StyleUtil.default.translateToNormalValue(blockResult[item]);
      });
    }
    selectorList.forEach(item => {
      targetNodes.push([item, blockResult]);
    });
    return targetNodes;
  }
  translateNormalPrelude(sourceNodes, position) {
    let targetNodeList = [];
    let targetNode = [];
    sourceNodes.map(node => {
      targetNode = [];
      for (let i = 0; i < node.length; i++) {
        const selector = node[i];
        const {
          type,
          name
        } = selector;
        // 选择器类型转为数字
        const selectorIndex = (0, _StyleSelectorType.findSelectorIndex)(type);
        if (type === _StyleSelectorType.Selector.COMBINATOR) {
          // 其他非逗号的组合符都报错，比如空选择器、>、~等
          // >和空格暂时不报错，报warn
          if (name !== ',') {
            if (name === ' ') {
              this.addThorwLog(type, name, position, 'Descendant Selector');
            } else {
              this.addThorwLog(type, name, position);
            }
          }
          continue;
        }
        // 通配符选择器报错
        if (selectorIndex === 2 && name === '*') {
          this.addThorwLog(type, name, position, 'Universal Selector');
          continue;
        }
        if (selectorIndex !== -1) {
          targetNode.push([selectorIndex, name]);
        } else {
          this.addThorwLog(type, name, position);
        }
      }
      targetNodeList.push(targetNode);
    });
    return targetNodeList;
  }
  /**
   * 选择器类型报错，添加thorwLog
   * @param type
   * @param name
   */
  addThorwLog(type, name, position, info) {
    const {
      onLog,
      filePath
    } = this.options;
    const logLevel = name === ' ' || name === '>' ? _sharedUtils.Loglevel.WARN : _sharedUtils.Loglevel.THROW;
    const message = info ? [`### StyleToTypescript ### Selector type unsupport`, {
      word: info
    }] : [`### StyleToTypescript ### Selector type unsupport`, {
      word: type
    }, ',name:', {
      word: name
    }];
    onLog({
      filePath,
      position,
      level: logLevel,
      message
    });
  }
  translateAtrule(sourceNode) {
    let targetNodes = [];
    switch (sourceNode.name) {
      case _StyleSelectorType.AtruleSelector.KEYFRAMES:
        targetNodes = this.translateKeyframes(sourceNode);
        break;
      case _StyleSelectorType.AtruleSelector.MEDIA:
        targetNodes = this.translateMedia(sourceNode);
        break;
      default:
        // 未知类型的Atrule节点
        this.options.onLog({
          filePath: this.options.filePath,
          position: sourceNode.position,
          level: _sharedUtils.Loglevel.ERROR,
          message: ['Atrule node of unknown type (', {
            word: sourceNode.type
          }, ')']
        });
        break;
    }
    return targetNodes;
  }
  translateNoPreludeAtRule(sourceNode) {
    const targetNodes = [];
    const {
      onLog,
      filePath
    } = this.options;
    let {
      block,
      name,
      position
    } = sourceNode;
    const index = (0, _StyleSelectorType.findSelectorIndex)(name);
    // 处理属性
    let blockResult = _StyleUtil.default.translateBlock(block, this.options);
    if (name === _StyleSelectorType.AtruleSelector.FONTFACE) {
      blockResult['fontFamily'] = _StyleUtil.default.translateToNormalValue(blockResult['fontFamily']);
      const fontFamily = blockResult['fontFamily'];
      if (typeof fontFamily === 'string') {
        name = fontFamily;
      } else {
        // 此处只能为string
        onLog({
          filePath,
          position,
          level: _sharedUtils.Loglevel.THROW,
          message: '### StyleToTypescript ### fontFamily property is not a string'
        });
      }
      blockResult['fontName'] = fontFamily;
      blockResult['fontSrc'] = blockResult['src'];
      blockResult = {
        fontface: blockResult
      };
    }
    targetNodes.push([[[index, name]], blockResult]);
    return targetNodes;
  }
  translateMedia(sourceNode) {
    const targetNodes = [];
    const {
      prelude,
      rules
    } = sourceNode;
    // 转换prelude
    const preludeResult = this.translateMediaPrelude(prelude);
    // 转换rules
    const rulesResult = this.translateNodes(rules);
    rulesResult.map(rule => {
      targetNodes.push([{
        condition: preludeResult
      }, ...rule]);
    });
    return targetNodes;
  }
  translateKeyframes(sourceNode) {
    const {
      name,
      prelude,
      rules
    } = sourceNode;
    const targetNodes = [];
    // 转换prelude
    const preludeResult = prelude[0][0]['name'];
    const selectorIndex = (0, _StyleSelectorType.findSelectorIndex)(_StyleSelectorType.AtruleSelector.KEYFRAMES);
    // 转换rules
    const styleList = [];
    rules.forEach(rule => {
      if (rule.type === _StyleSelectorType.IRuleTypes.RULE) {
        const styleObject = _StyleUtil.default.translateKeyFramesRule(rule, this.options);
        styleList.push(styleObject);
      }
    });
    targetNodes.push([[[selectorIndex, preludeResult]], {
      [name]: JSON.stringify(styleList)
    }]);
    return targetNodes;
  }
  /**
   * vela快应用：按照运行时要求，只补全第一个MediaQuery节点缺少的媒体类型
   * @param sourceNodes
   * @returns
   */
  translateMediaPrelude(sourceNodes) {
    const firstMediaQuery = sourceNodes[0];
    // 补全
    if (_StyleUtil.default.isMediaFeature(firstMediaQuery[0])) {
      sourceNodes[0].unshift({
        type: 'Identifier',
        name: 'screen'
      }, {
        type: 'Identifier',
        name: 'and'
      });
    }
    return sourceNodes.map(node => node.map(item => item.name).join(' ')).join(',');
  }
}
var _default = exports.default = StyleToTypescript;