"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _sharedUtils = require("@aiot-toolkit/shared-utils");
var _lodash = _interopRequireDefault(require("lodash"));
var _ParserUtil = _interopRequireDefault(require("../../../utils/ParserUtil"));
var _ElementConfig = _interopRequireDefault(require("../../config/android/ElementConfig"));
var _TemplateNodeType = _interopRequireDefault(require("../../enum/TemplateNodeType"));
var _ElementConfigUtil = _interopRequireDefault(require("../../utils/ElementConfigUtil"));
var _TemplateUtil = _interopRequireDefault(require("../vela/utils/TemplateUtil"));
var _AndroidContext = _interopRequireDefault(require("./AndroidContext"));
var _ForTranslate = _interopRequireDefault(require("./attributeTranslate/ForTranslate"));
var _IfTranslate = _interopRequireDefault(require("./attributeTranslate/IfTranslate"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * TemplateToTypescript
 */
class TemplateToTypescript {
  _mapList = [];
  elementUtil = (() => new _ElementConfigUtil.default(_ElementConfig.default))();
  constructor(options, compilerOption, importList) {
    this.options = options;
    this.compilerOption = compilerOption;
    this.importList = importList;
    this.templateUtil = new _TemplateUtil.default(_AndroidContext.default, options, this.elementUtil);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  translate(sourceTree, offsetList) {
    this._target = _ParserUtil.default.createSourceFile('', this.options.filePath + '.template');
    this._mapList = [];
    const {
      childNodes
    } = sourceTree;
    if (childNodes.length) {
      childNodes.forEach(item => this.translateNoe(item));
    } else {
      this._target.addStatements('{}');
    }
    return {
      targetTree: this._target,
      mapList: this._mapList
    };
  }

  /**
   * 创建节点对象
   *
   * 1. 创建对象
   * 2. 把对象的属性依次加到sourceFile中，并记录位置
   * 3.
   * @param node
   */
  translateNoe(node) {
    if (_TemplateUtil.default.isElement(node)) {
      const targetNode = this.createTargetNode(node, ['require']);
      this.addTargetNodeToCode(targetNode);
    }
  }

  /**
   * 产物节点添加到代码中，并记录位置映射关系
   *
   * 1. 循环非 children 的属性，依次添加到产物树，并记录位置映射关系
   * 2. 如果 children有值，递归处理 children
   *
   * 此函数修改 this._target 和 this._mapList
   * @param node
   */
  addTargetNodeToCode(node) {
    const str = _sharedUtils.StringUtil.objectToString(node);
    this._target.addStatements(str);
  }

  /**
   * 创建节点（此函数生成节点，不修改产物树）
   *
   * 1. 元素处理
   *    a. 创建节点
   * 2. 普通属性生成: **属性名需要转成驼峰**
   * 3. 特殊属性处理
   *    a. classList、style、events, 单独赋值
   *    b. dataset 放到attr 中
   *    c. 如果有 id 属性，id在attr同级也要设置
   *    d. for  if 单独处理
   *    e. models 属性转换后放到 events , attr 中
   *
   * 4. 递归子元素生成 children
   * @param node 元素节点
   * @param existingIdentifiers 已存在的标识符列表
   */
  createTargetNode(node, existingIdentifiers) {
    const {
      tagName,
      childNodes
    } = node;
    const translateList = [new _ForTranslate.default(this.options), new _IfTranslate.default(this.options)];
    const elementConfig = this.elementUtil.getElementConfig(tagName);
    const effectType = elementConfig?.aliasName || tagName;
    // 1.a
    const result = {
      type: `'${effectType}'`,
      attr: {}
    };
    const attributes = this.preprocessingProperties(node);
    const attributeObject = this.templateUtil.attributesToObject(this.options, attributes, existingIdentifiers, {
      separateModelValue: true
    });
    const {
      classList,
      events,
      style,
      dataset,
      models,
      ...otherAttrs
    } = attributeObject;
    // 2
    for (const key in otherAttrs) {
      result.attr[_sharedUtils.StringUtil.hyphenedToCamel(key)] = otherAttrs[key];
    }
    // 3.a
    result.classList = classList;
    result.style = style;
    result.events = events;

    // 3.b
    if (dataset) {
      for (let key in dataset) {
        const value = dataset[key];
        const name = `data${key[0].toUpperCase()}${key.substring(1)}`;
        result.attr[name] = value;
      }
    }

    // 3.c
    const outSideAttributeList = ['id', 'is'];
    outSideAttributeList.forEach(item => {
      if (otherAttrs[item]) {
        result[item] = otherAttrs[item];
      }
    });

    // 3.d
    translateList.forEach(item => {
      if (item.match(node)) {
        const attribute = item.translate(node, existingIdentifiers);
        if (attribute) {
          _lodash.default.merge(result, attribute);
        }
      }
    });

    // 3.e
    if (models) {
      const {
        events,
        attr
      } = this.translateModels(node, models);
      result.events = {
        ...result.events,
        ...events
      };
      result.attr = {
        ...result.attr,
        ...attr
      };
    }
    const effectChildNodes = childNodes.filter(item => _TemplateUtil.default.isElement(item));
    // 4
    if (effectChildNodes.length) {
      result.children = [];
      effectChildNodes.forEach(item => {
        result.children?.push(this.createTargetNode(item, existingIdentifiers));
      });
    }
    return result;
  }

  /**
   * 转换 model 数据
   * 1. 自定义组件转换为
   *    events[update:NAME] = function(evt){ VALUE = evt.detail}
   *    attr[驼峰名称(NAME)] = function(){ return VALUE }
   * 2. 普通组件转换为
   *    events['change'] = function(evt){ VALUE = evt.target.NAME}
   * @param node
   * @param models
   * @returns
   */
  translateModels(node, models) {
    const result = {
      events: {},
      attr: {}
    };
    for (let key in models) {
      const value = models[key];
      const modelResult = this.templateUtil.parseModelAttribute({
        name: key,
        value
      });
      if (modelResult) {
        const isCustomComponent = this.importList.findIndex(item => item.name.toLowerCase() === node.tagName.toLowerCase()) >= 0;
        const {
          modelName,
          modelValue
        } = modelResult;
        if (isCustomComponent) {
          result.events[`update:${modelName}`] = `function(evt){ ${modelValue} = evt.detail}`;
          result.attr[_sharedUtils.StringUtil.hyphenedToCamel(modelName)] = `function(){ return ${modelValue} }`;
        } else {
          result.events['change'] = `function(evt){ ${modelValue} = evt.target.${modelName}}`;
        }
      }
    }
    return result;
  }

  /**
   * 预处理属性
   * 1. 特定元素和特定属性处理
   *    a. 特定元素：文本子元素做为 value 属性
   *    b. 特定元素的特定属性：如果是静态路径，加上 require
   * 2. 去除特殊属性
   * 3. 事件、逻辑属性强制设置为动态属性
   * @param node
   */
  preprocessingProperties(node) {
    const {
      allowTextChildren
    } = this.elementUtil;
    const unusedAttributes = ['if', 'elif', 'else', 'for'];
    const {
      tagName,
      attrs,
      childNodes
    } = node;
    let result = attrs.map(item => {
      return {
        ...item,
        nameLocation: _TemplateUtil.default.parse5LocationToPosition(node.sourceCodeLocation?.attrs?.[item.name])
      };
    });

    // 1.a
    const childrenName = allowTextChildren(tagName);
    if (childrenName) {
      const children = childNodes.filter(item => item.nodeName === _TemplateNodeType.default.TEXT);
      const value = children.map(item => item.value).join('');
      if (value) {
        result.push({
          name: childrenName === true ? 'value' : childrenName,
          value,
          nameLocation: _TemplateUtil.default.parse5LocationToPosition(children[0].sourceCodeLocation)
        });
      }
    }
    // 1.b
    this.templateUtil.convertResourcePath(tagName, result, this.compilerOption);

    // 2
    result = result.filter(item => {
      const {
        attributeName
      } = _TemplateUtil.default.parseAttributeName(item.name);
      return !unusedAttributes.includes(attributeName);
    });

    // 3
    result.forEach(item => {
      const {
        name,
        value
      } = item;
      if (value && this.templateUtil.isForceDynamicAttribute(node.tagName, name) && !_TemplateUtil.default.isDynamicValue(value)) {
        item.value = _TemplateUtil.default.toDynamicValue(value);
      }
    });
    return result;
  }
}
var _default = exports.default = TemplateToTypescript;