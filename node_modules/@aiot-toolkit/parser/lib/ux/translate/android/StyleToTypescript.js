"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _sharedUtils = require("@aiot-toolkit/shared-utils");
var _StyleSelectorType = require("../../enum/StyleSelectorType");
var _StyleSelectorName = _interopRequireDefault(require("../../enum/android/StyleSelectorName"));
var _StyleUtil = _interopRequireDefault(require("../../utils/StyleUtil"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * StyleToTypescript
 */
class StyleToTypescript {
  constructor(options, compilerOption) {
    this.options = options;
    this.compilerOption = compilerOption;
  }
  translate(sourceTree,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  offsetList) {
    const styleList = sourceTree.styleContent;
    const cssResult = this.translateNodes(styleList);
    return {
      targetTree: cssResult,
      mapList: []
    };
  }

  /**
   * 转换节点列表
   *
   * 1. 对于任一节点，根据类型做不同的转换
   * 2. 转换结果和已有的结果进行合并
   * @param nodes
   * @returns
   */
  translateNodes(nodes) {
    const result = {};
    for (const node of nodes) {
      let currentResult = {};
      switch (node.type) {
        case _StyleSelectorType.IRuleTypes.RULE:
          currentResult = this.translateRule(node);
          break;
        case _StyleSelectorType.IRuleTypes.AT_RULE:
          currentResult = this.translateAtRule(node);
          break;
        default:
          // error todo
          break;
      }
      if (Object.keys(currentResult).length > 0) {
        this.mergeStyle(result, currentResult);
      }
    }
    return result;
  }

  /**
   * 合并样式
   *
   * 1. media: 合并数组
   * 2. 其它（fontface, keyframes,  普通样式）：合并对象
   * @param currentStyle
   * @param newStyle
   * @returns
   */
  mergeStyle(currentStyle, newStyle) {
    for (const styleName in newStyle) {
      switch (styleName) {
        // 1
        case _StyleSelectorName.default.MEDIA:
          currentStyle[styleName] = [...(currentStyle[styleName] || []), ...(newStyle[styleName] || [])];
          break;
        // 2
        default:
          currentStyle[styleName] = {
            ...currentStyle[styleName],
            ...newStyle[styleName]
          };
      }
    }
  }

  /**
   * 转换@ 开头的样式
   *
   * @param node
   * @returns
   */
  translateAtRule(node) {
    const {
      name
    } = node;
    switch (name) {
      case _StyleSelectorType.AtruleSelector.KEYFRAMES:
        return this.translateKeyFrames(node);
      case _StyleSelectorType.AtruleSelector.FONTFACE:
        return this.translateFontFace(node);
      case _StyleSelectorType.AtruleSelector.MEDIA:
        return this.translateMedia(node);
      default:
        // error todo
        return {};
    }
  }

  /**
   * 转换keyframe
   * @param node
   * @returns
   */
  translateKeyFrames(node) {
    const result = {
      [_StyleSelectorName.default.KEYFRAMES]: {}
    };
    const {
      prelude,
      rules
    } = node;
    const name = prelude.map(node => node.map(item => this.getPreludeName(item)).join('')).join('');
    const value = rules.map(item => {
      return _StyleUtil.default.translateKeyFramesRule(item, this.options);
    });
    result[_StyleSelectorName.default.KEYFRAMES][name] = value;
    return result;
  }

  /**
   * 转换  @font-face
   *
   * 1. 以font-family 为key
   * 2. 额外生成fontName=fontFamily   fontSrc=src
   *
   * @param node
   * @returns
   */
  translateFontFace(node) {
    const {
      block,
      position
    } = node;
    const {
      onLog,
      filePath
    } = this.options;
    const value = _StyleUtil.default.translateBlock(block, this.options);
    const name = value.fontFamily;
    const src = Array.isArray(value.src) ? value.src : [value.src];
    if (!name) {
      onLog({
        level: _sharedUtils.Loglevel.THROW,
        filePath,
        position,
        message: 'font-face must have font-family'
      });
      return {
        [_StyleSelectorName.default.FONT_FACE]: {}
      };
    }
    return {
      [_StyleSelectorName.default.FONT_FACE]: {
        [name]: {
          ...value,
          src,
          fontName: value.fontFamily,
          fontSrc: src
        }
      }
    };
  }

  /**
   * 转换 @media
   *
   * 1. 以"@MEDIA"为键
   * 2. 以条件为 `condition` 的值
   * 3. 递归 translateNodes 转换其中的内容
   * @param node
   * @returns
   */
  translateMedia(node) {
    const {
      prelude,
      rules
    } = node;
    const mediaType = prelude[0][0].type === 'Identifier' ? prelude[0][0].name : 'screen';
    const condition = prelude.map(rules => {
      let ruleList = rules;
      // 如果缺少媒体类型，则加上媒体类型，例如 `screen and`
      if (_StyleUtil.default.isMediaFeature(rules[0])) {
        ruleList = [{
          type: 'Identifier',
          name: mediaType
        }, {
          type: 'Identifier',
          name: 'and'
        }, ...rules];
      }
      return ruleList.map(item => {
        return this.getPreludeName(item);
      }).join(' ');
    }).join(' or ');
    const value = this.translateNodes(rules);
    return {
      [_StyleSelectorName.default.MEDIA]: [{
        condition,
        ...value
      }]
    };
  }

  /**
   * 转换常规样式
   * ```
   * .a .b {
   *   color: red;
   * }
   * ```
   * @param node
   * @returns
   */
  translateRule(node) {
    const {
      prelude,
      block
    } = node;
    const result = {};

    // 根据二维数组生成多项
    // .a .b, .c .d{}  需要生成  .a .b{}   .c .d{}
    const blockResult = _StyleUtil.default.translateBlock(block, this.options);
    if (Object.keys(blockResult).length) {
      prelude.forEach(preludeItem => {
        // 选择器名称，不包含伪类
        const name = preludeItem.filter(item => item.type !== _StyleSelectorType.Selector.PSEUDO_CLASS_SELECTOR).map(item => this.getPreludeName(item)).join('');
        // 如果存在伪类选择器，则提取出来，并加到属性名称的后面
        const pseudoName = preludeItem.filter(item => item.type === _StyleSelectorType.Selector.PSEUDO_CLASS_SELECTOR).map(item => this.getPreludeName(item)).join('');
        let block = {};
        for (const key in blockResult) {
          const value = blockResult[key];
          const name = pseudoName ? `${key}${pseudoName}` : key;
          block[name] = this.translateCssValue(value);
        }
        result[name] = block;
      });
    }
    return result;
  }
  translateCssValue(value) {
    if (typeof value === 'object') {
      if (Array.isArray(value)) {
        // example: `animation-name: X GO, Color, scaleX`  --> `animationName: "X GO, Color, scaleX"`,
        return value.map((item, index) => {
          const nextItem = value[index + 1];
          if (item !== ',' && (!nextItem || nextItem === ',')) {
            return item;
          }
          return `${item} `;
        }).join('');
      } else {
        // example: `transform: scale(1) rotate(180deg)` --> `transform: '{"scaleX":1,"scaleY":1,"rotate":"180deg"}'`,
        return JSON.stringify(value);
      }
    }
    return value;
  }
  getPreludeName(node) {
    const {
      type,
      name
    } = node;
    switch (type) {
      case _StyleSelectorType.Selector.CLASS_SELECTOR:
        return `.${name}`;
      case _StyleSelectorType.Selector.ID_SELECTOR:
        return `#${name}`;
      case _StyleSelectorType.Selector.PSEUDO_CLASS_SELECTOR:
        return `:${name}`;
      default:
        return name;
    }
  }
}
var _default = exports.default = StyleToTypescript;