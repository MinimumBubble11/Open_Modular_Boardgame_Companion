"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _sharedUtils = require("@aiot-toolkit/shared-utils");
var _cssTree = require("css-tree");
var _fsExtra = _interopRequireDefault(require("fs-extra"));
var _lodash = _interopRequireDefault(require("lodash"));
var _path = _interopRequireDefault(require("path"));
var _CompressConfig = require("../config/CompressConfig");
var _StyleSelectorType = require("../enum/StyleSelectorType");
var _StyleAttributeConfig = require("../config/vela/StyleAttributeConfig");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * StyleUtil
 */
class StyleUtil {
  /**
   * 判断节点是否为declaration节点
   * @param node
   * @returns
   */
  static isDeclaration(node) {
    return node.type === 'Declaration';
  }

  /**
   * 判断节点是否为Identifier类型
   * @param node
   * @returns
   */
  static isIdentifier(node) {
    return node.type === 'Identifier';
  }

  /**
   * 判断节点是否为SelectorList类型
   * @param node
   * @returns
   */
  static isSelectorList(node) {
    return node.type === 'SelectorList';
  }

  /**
   * 判断节点是否为AtrulePrelude类型
   * @param node
   * @returns
   */
  static isAtrulePrelude(node) {
    return node.type === 'AtrulePrelude';
  }

  /**
   * 判断节点是否为MediaFeature类型
   * @param node
   * @returns
   */
  static isMediaFeature(node) {
    return node.type === 'MediaFeature';
  }
  /**
   * 判断节点是否为MediaQuery类型
   * @param node
   * @returns
   */
  static isMediaQuery(node) {
    return node.type === 'MediaQuery';
  }

  /**
   * 判断节点是否为MediaQueryList类型
   * @param node
   * @returns
   */
  static isMediaQueryList(node) {
    return node.type === 'MediaQueryList';
  }

  /**
   * 生成节点的name
   * 1. 节点存在name且存在value时，nodeName = generate(node)生成css代码
   * 2. 节点存在name且没有value时，nodeName = node.name
   * 3. 节点存在value且没有name时，nodeName = node.value
   *
   * 例如：#title为存在name且没有value的情况，应返回node.name返回;
   * 例如：50% {}时，节点存在value没有name,应返回node.value
   * @param node
   * @returns
   */
  static generateNodename(node) {
    let nodeName = '';
    if (node && 'name' in node && node.name) {
      if ('value' in node && node.value) {
        nodeName = (0, _cssTree.generate)(node);
      } else {
        nodeName = StyleUtil.isIdentifier(node.name) ? (0, _cssTree.generate)(node.name) : node.name;
      }
    } else {
      if ('value' in node && node.value) {
        nodeName = typeof node.value === 'string' ? node.value : (0, _cssTree.generate)(node.value);
      }
    }
    return nodeName;
  }
  /**
   * 处理 @media 媒体查询条件
   * 1. 循环MediaQueryList节点的子节点（MediaQuery节点）
   * 2. 检查每个MediaQuery节点的媒体类型
   *
   * @param node
   * @returns
   */
  static parseMediaQueryList(options, node, styleMapUtil) {
    let resultList = [];
    // 1.
    const nodeChildrens = Array.isArray(node.children) ? node.children : node.children.toArray();
    for (let index = 0; index < nodeChildrens.length; index++) {
      const nodeC = nodeChildrens[index];
      const nodeCPreludes = [];
      // 2.
      StyleUtil.checkMediaType(options, nodeC, styleMapUtil);
      // MediaQuery节点
      if (StyleUtil.isMediaQuery(nodeC)) {
        if ('children' in nodeC) {
          const nodeCChildrens = Array.isArray(nodeC.children) ? nodeC.children : nodeC.children.toArray();
          nodeCChildrens.forEach(childNode => {
            // 处理 除法
            // example: {type: "MediaFeature", name: "min-width", value: {type: "Ratio", left: "30", right: "1"}}
            // generate结果：(min-width: 30/1)
            if (StyleUtil.isMediaFeature(childNode) && childNode.value?.type === 'Ratio') {
              const value = eval((0, _cssTree.generate)(childNode.value));
              childNode.value = {
                type: 'Number',
                value: value.toString()
              };
            }
            nodeCPreludes.push({
              type: childNode.type,
              name: (0, _cssTree.generate)(childNode)
            });
          });
        }
        resultList.push(nodeCPreludes);
      } else {
        // 报错， MediaQueryList中出现除MediaQuery类型外的其他类型
        options.onLog({
          level: _sharedUtils.Loglevel.ERROR,
          position: node.loc ? styleMapUtil.transfromLocToPosition(node.loc) : undefined,
          message: ['Unexpected types (', {
            word: nodeC.type || (0, _cssTree.generate)(nodeC)
          }, ') other than', {
            word: 'MediaQuery'
          }, 'are appearing in the', {
            word: 'MediaQueryList'
          }, '.']
        });
      }
    }
    return resultList;
  }

  /**
   * 处理css中资源引入
   * 1. 判断是否为绝对路径
   *  1.1 资源路径为绝对路径时
   *  1.2 资源路径为非绝对路径时，拼接路径为一个绝对路径
   * 2. 判断由第一步生成的绝对路径是否在指定路径外
   *  2.1 资源在指定路径外，复制资源到指定文件夹下，返回修改后的路径
   *  2.2 资源在指定路径内，返回相对路径
   *
   */
  static handleDynamicAssets(options, compilerOption, assetsPath, collectImageResource, position) {
    // 判断url值是否为网址等
    const reg = /^\w+:\/\//;
    if (reg.test(assetsPath)) {
      return assetsPath;
    }
    const {
      projectPath,
      filePath,
      onLog
    } = options;
    const rootDir = compilerOption.sourceRoot;
    const targetPath = _path.default.resolve(projectPath, rootDir);
    let isOutside = false;
    let assetsAbsolutePath = '';

    // 判断输入路径是否在指定路径外
    const isOutsideTargetPath = filePath => {
      const relativePath = _path.default.relative(targetPath, filePath);
      return relativePath.startsWith('..');
    };
    if (!assetsPath) {
      // 警告，路径值不存在
      onLog({
        filePath,
        level: _sharedUtils.Loglevel.WARN,
        position,
        message: 'url value is null'
      });
      return '';
    }
    // 1.
    assetsAbsolutePath = _path.default.isAbsolute(assetsPath) ? assetsPath : _path.default.join(_path.default.dirname(filePath), assetsPath);
    if (!_fsExtra.default.existsSync(assetsAbsolutePath)) {
      if (_fsExtra.default.existsSync(_path.default.join(targetPath, assetsPath))) {
        return assetsPath;
      } else {
        onLog({
          filePath,
          level: _sharedUtils.Loglevel.ERROR,
          position,
          message: ['The absolute path ', {
            word: `(${assetsAbsolutePath})`
          }, 'to the current value ', {
            word: `(${assetsPath})`
          }, 'does not exist']
        });
        return '';
      }
    }
    isOutside = isOutsideTargetPath(assetsAbsolutePath);

    // 2.
    if (isOutside) {
      return collectImageResource(assetsAbsolutePath);
    } else {
      const relativePath = _path.default.relative(targetPath, assetsAbsolutePath);
      // 在结果前加上'/'
      return _path.default.join(_path.default.posix.sep, relativePath).split(_path.default.sep).join(_path.default.posix.sep);
    }
  }

  /**
   * 转换相对路径为 “相对项目源码目录的绝对路径”
   *
   * 例如：有文件`project/src/page/a.so`，则将 `./a.so` 转换为 `/page/a.so`
   * @param reslovePath 路径值， 例如  `require('./a.so'), 则此值为 `./a.so`
   * @param options
   * @param compilerOption
   * @returns
   */
  static getRelativePath(reslovePath, options, compilerOption) {
    const {
      projectPath,
      filePath
    } = options;
    let rootDir = compilerOption.sourceRoot;
    if (filePath && !_path.default.isAbsolute(reslovePath)) {
      // 目标文件绝对路径
      const absolutePath = _path.default.join(_path.default.dirname(filePath), reslovePath);
      // 项目根目录和目标文件的相对路径
      const relativePath = _path.default.relative(_path.default.resolve(projectPath, rootDir), absolutePath);
      // 在结果前加上'/'
      reslovePath = _path.default.join(_path.default.sep, relativePath).split(_path.default.sep).join(_path.default.posix.sep);
    }
    return reslovePath;
  }
  static checkParserError(error, fallbackNode) {
    const mediaLevel4OperatorList = ['>', '>=', '<', '<='];
    const mediaLevel4OperatorRegex = /[><]=?/;
    if (error.offset) {
      const errorWord = error.source?.[error.offset] || '';
      // 排除media中写level4运算符的报错问题
      if (mediaLevel4OperatorList.includes(errorWord) || mediaLevel4OperatorRegex.test(fallbackNode.value)) {
        return false;
      }
    }
    return true;
  }

  /**
   * 收集解析错误
   * @param error
   * @param fallbackNode
   * @returns
   */
  static collectParserError(error, fallbackNode) {
    // 检查错误解析是否为需要输出
    if (StyleUtil.checkParserError(error, fallbackNode)) {
      let parserError;
      let {
        message,
        name
      } = error;
      let {
        loc
      } = fallbackNode;
      parserError = {
        message: name,
        details: message,
        startLine: loc?.start?.startLine || 0,
        startCol: loc?.start?.startCol || 0,
        startOffset: loc?.start?.offset || 0,
        endLine: loc?.start?.startLine || 0,
        endCol: loc?.start?.startCol || 0,
        endOffset: loc?.end?.offset || 0,
        source: 'value' in fallbackNode ? fallbackNode.value : ''
      };
      return parserError;
    } else {
      return;
    }
  }

  /**
   * 收集CSS语法错误
   * @param errors
   * @returns
   */
  static collectSyntaxError(errors) {
    let syntaxErrors = [];
    for (let i = 0; i < errors.length; i++) {
      let {
        message,
        details,
        loc,
        css
      } = errors[i];
      if (message.includes('Unknown property') && _StyleAttributeConfig.STYLE_ATTRIBUTE_LIST.includes(_sharedUtils.StringUtil.hyphenedToCamel(errors[i].property)) || message.includes('Invalid value for `@media` prelude')) {
        continue;
      }
      syntaxErrors.push({
        message,
        details,
        startLine: loc?.start?.line || errors[i].line || 0,
        startCol: loc?.start?.column || errors[i].column || 0,
        startOffset: loc?.start?.offset || errors[i].offset || 0,
        endLine: loc?.start?.line || 0,
        endCol: loc?.start?.column || 0,
        endOffset: loc?.end?.offset || 0,
        source: css
      });
    }
    return syntaxErrors;
  }

  /**
   * 相同选择器时融合样式
   * 1. 遍历待融合列表，如果元素长度为3，判断选择器列表是否在存储列表中存在
   * 2. 存在相同选择器列表时，再判断condition是否一致，都一致表示为相同选择器
   * 3. 如果元素长度为2,判断选择器列表是否在存储列表中存在，是则表示为相同选择器
   * 4. 如果元素长度为1,则提示样式内容为空，去掉该选择器
   * @param compareList 存储融合结果的样式列表
   * @param candidateList 待融合的样式列表
   * @returns
   */
  static mergeSelectorList(compareList, candidateList) {
    let resultList = [...compareList];
    candidateList.map(candidateNode => {
      if (candidateNode.length > 1) {
        let candidateSelectorList;
        let candidateCondition = {};
        let candidatePropertys;
        // 长度大于1,小于3时,表示节点上没有条件对象
        const candidateOffset = candidateNode.length > 2 ? 1 : 0;
        candidateCondition = candidateOffset === 0 ? {} : candidateNode[candidateOffset - 1];
        candidateSelectorList = candidateNode[candidateOffset];
        candidatePropertys = candidateNode[candidateOffset + 1];
        // 在结果列表中寻找与待融合节点选择器相同的节点
        const compareResult = resultList.findIndex(compareNode => {
          if (compareNode.length === candidateNode.length) {
            let compareSelectorList;
            let compareCondition = {};
            // 长度大于1,小于3时,表示节点上没有条件对象
            const compareOffset = compareNode.length > 2 ? 1 : 0;
            // 比较条件对象
            compareCondition = candidateOffset === 0 ? {} : compareNode[compareOffset - 1];
            if (StyleUtil.isConditionStyleItem(compareCondition) && StyleUtil.isConditionStyleItem(candidateCondition) && compareCondition.condition !== candidateCondition.condition) {
              // 无重复节点，作为独立选择器存在，比较下一个节点
              return false;
            }
            // 比较选择器列表
            compareSelectorList = compareNode[compareOffset];
            if (compareSelectorList.length === candidateSelectorList.length) {
              for (let i in compareSelectorList) {
                if (compareSelectorList[i][0] !== candidateSelectorList[i][0] || compareSelectorList[i][1] !== candidateSelectorList[i][1]) {
                  return false;
                }
              }
              // 选择器比较结果一致
              const comparePropertys = compareNode[compareOffset + 1];
              for (let key in candidatePropertys) {
                comparePropertys[key] = candidatePropertys[key];
              }
              candidateNode[compareOffset + 1] = comparePropertys;
              return true;
            } else {
              return false;
            }
          }
          return false;
        });
        if (compareResult === -1) {
          // 独立选择器
          resultList.push(candidateNode);
        } else {
          // 非独立选择器
          resultList[compareResult][candidateOffset + 1] = candidateNode[candidateOffset + 1];
        }
      }
    });
    return resultList;
  }

  /**
   * 判断StyleItem类型的节点是否有"condition"属性
   * @param conditionNode
   * @returns
   */
  static isConditionStyleItem(conditionNode) {
    return 'condition' in conditionNode && typeof conditionNode['condition'] === 'string';
  }

  /**
   * 转换百分号
   * @param unit
   * @returns
   */
  static translatePercentage(unit) {
    return unit === 'Percentage' ? '%' : unit;
  }
  static isTransformItemNode(obj) {
    return obj && 'name' in obj && 'param' in obj;
  }

  /**
   * 压缩css属性名
   * 1. 取出转换结果中的每一组样式（ 选择器 + 样式对象）styleNode
   *  一般样式的格式为：
   *  [
   *    [[]],
   *    {}
   *  ]
   *  1.1 @meida的样式不需要压缩 (condition + 选择器 + 样式对象)
   *  [
   *    {},
   *    [[]],
   *    {}
   *  ]
   * 2. 从styleNode中取出样式对象 AttrObj
   * 3. 遍历样式对象，找到属性对应的压缩值
   * 4. 替换属性名和属性值
   * @param sourceNodes
   * @returns
   */
  static compressStyleAttributeName(sourceNodes) {
    const cloneNodes = _lodash.default.cloneDeep(sourceNodes);
    // 1.
    cloneNodes.forEach(styleNode => {
      if (styleNode.length > 1) {
        // 2.
        const AttrObj = styleNode[1];
        if (!Array.isArray(AttrObj)) {
          // 3.
          for (const attr in AttrObj) {
            const compressAttr = _CompressConfig.cssAttrMap[attr];
            if (compressAttr) {
              // 4.
              AttrObj[compressAttr] = AttrObj[attr];
              delete AttrObj[attr];
            }
          }
        }
      }
    });
    return cloneNodes;
  }

  /**
   * 检查每一个MediaQuery的MediaType
   * 1. 判断节点是否为MediaQuery类型，非MediaQuery暂不处理
   * 2. 取出节点的所有子节点
   * 3. MediaType应该只出现在前两个Identifier节点中
   *  3.1 @media screen and...时，screen在第一个Identifier节点上
   *  3.2 @media not|only screen and...时，screen在第二个Identifier节点上
   *  3.3 @media not {}
   * 4. 校验MediaType是否合法
   *
   */
  static checkMediaType(options, node, styleMapUil) {
    const {
      onLog,
      filePath,
      projectType
    } = options;
    let mediaTypeName = '';
    // 1.
    if (node.type === 'MediaQuery') {
      if ('children' in node) {
        // 2.
        const childList = Array.isArray(node.children) ? node.children : node.children.toArray();
        for (let i = 0; i < childList.length; i++) {
          const childNode = childList[i];
          // 3.
          if (i < 2 && childNode.type === 'Identifier') {
            if (childNode.name !== 'not' && childNode.name !== 'only') {
              mediaTypeName = childNode.name;
              break;
            }
          } else {
            break;
          }
        }
      }
    }
    // 4.
    if (mediaTypeName) {
      if ((0, _StyleSelectorType.isMeidaType)(mediaTypeName)) {
        if (!(0, _StyleSelectorType.isSupportMediaType)(mediaTypeName, projectType)) {
          // 报错
          onLog({
            level: _sharedUtils.Loglevel.ERROR,
            filePath: filePath,
            position: node.loc ? styleMapUil.transfromLocToPosition(node.loc) : undefined,
            message: [`Unsupported media type `, {
              word: `${mediaTypeName}`
            }]
          });
        }
      } else {
        // 报错
        onLog({
          level: _sharedUtils.Loglevel.ERROR,
          filePath: filePath,
          position: node.loc ? styleMapUil.transfromLocToPosition(node.loc) : undefined,
          message: [{
            word: `'${mediaTypeName}'`
          }, `is not a media type`]
        });
      }
    }
  }

  /**
   * 转换 keyframe 的规则项
   *
   * @param rule 规则项。 示例
   * ```css
   * from {
   *  width: 100px;
   *  color: red;
   * }
   * ```
   * @param options
   * @returns
   */
  static translateKeyFramesRule(rule, options) {
    const {
      onLog,
      filePath
    } = options;
    const {
      prelude,
      block,
      position
    } = rule;
    // 记录block样式列表
    let result = {
      time: NaN
    };
    if (prelude) {
      const firstName = prelude[0][0]['name'];
      switch (true) {
        case !isNaN(Number(firstName)):
          result.time = Number(firstName);
          break;
        case firstName === 'from':
          result.time = 0;
          break;
        case firstName === 'to':
          result.time = 100;
          break;
        default:
          onLog({
            level: _sharedUtils.Loglevel.THROW,
            message: `${firstName} is not a valid time value`,
            filePath,
            position
          });
          break;
      }
    }
    if (block) {
      const blockResult = this.translateBlock(block, options);
      Object.keys(blockResult).forEach(item => {
        blockResult[item] = StyleUtil.translateToNormalValue(blockResult[item]);
      });
      Object.assign(result, blockResult);
    }
    return result;
  }

  /**
   * 转换样式块
   * @param sourceNodes 样式块. 示例
   * ```css
   * {
   *    color: red;
   *    font-size: 12px
   * }
   * ```
   * @param options
   * @returns
   */
  static translateBlock(sourceNodes, options) {
    let targetList = {};
    for (const sourceNode of sourceNodes) {
      const {
        name,
        value: valueNode
      } = sourceNode;
      // 属性校验
      const config = _StyleAttributeConfig.STYLE_ATTRIBUTE_CONFIG[name];
      if (config?.validate) {
        const validateResult = config.validate(sourceNode);
        if (validateResult.message.length > 0) {
          const {
            onLog,
            filePath
          } = options;
          onLog({
            filePath: filePath,
            level: validateResult.level,
            position: sourceNode.position,
            message: [`Attribute verification failed,`, ...validateResult.message]
          });
        }
      }
      if (config?.translate) {
        targetList = {
          ...targetList,
          ...config.translate(sourceNode)
        };
      } else {
        targetList[name] = StyleUtil.translateValueNode(valueNode);
      }
    }
    return targetList;
  }

  /**
   * sourceNode为数组，且数组元素只会是一种类型
   * 1. ComplexValueType类型
   * 2. SimpleValueType类型
   * 无论哪种类型，转换后还是数组
   * @param sourceNode
   * @returns
   */
  static translateValueNode(sourceNode) {
    // 1.
    if ('name' in sourceNode[0]) {
      let targeValue = {};
      sourceNode.map(node => {
        node = node;
        const {
          name,
          param
        } = node;
        targeValue[name] = param.map(p => p.value).join('');
      });
      return targeValue;
    } else {
      // 2.
      return sourceNode.map(node => {
        // 如果是数字值且无单位，则转换为数字： 例如 opaticy: 1
        node = node;
        const numberValue = parseFloat(node.value);
        const result = node.value + this.translatePercentage(node.unit);
        return !isNaN(numberValue) && !node.unit ? numberValue : result;
      });
    }
  }
  /**
   * 属性值目前存储在数组中，该函数将数组中的值转换为字符串、数字
   * animation-name属性值为 ['GO','Color','scaleX'] --> "GO, Color, scaleX"
   * opacity属性值为 [1] --> 数字1
   * transform属性值为对象`transform: scale(1) rotate(180deg)` --> `transform: '{"scaleX":1,"scaleY":1,"rotate":"180deg"}'`
   * @param value
   * @returns
   */
  static translateToNormalValue(value) {
    if (typeof value === 'object') {
      if (Array.isArray(value)) {
        // 例如opacity数字值
        if (value.length === 1) {
          return value[0];
        } else {
          // 例如animation-name属性值
          return value.join(' ');
        }
      } else {
        // 例如transform属性值,
        return JSON.stringify(value);
      }
    }
    return value;
  }
}
var _default = exports.default = StyleUtil;