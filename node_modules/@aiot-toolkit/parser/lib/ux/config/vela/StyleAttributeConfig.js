"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.STYLE_ATTRIBUTE_LIST = exports.STYLE_ATTRIBUTE_CONFIG = void 0;
var _sharedUtils = require("@aiot-toolkit/shared-utils");
var _ExtendedBoxStyle = _interopRequireDefault(require("../../translate/vela/utils/ExtendedBoxStyle"));
var _UxUtil = _interopRequireDefault(require("../../utils/UxUtil"));
var _cssTree = _interopRequireDefault(require("css-tree"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const REGEXP_NAME = /^([a-zA-Z_]+[a-zA-Z0-9]*\s*,\s*)*[a-zA-Z_]+[a-zA-Z0-9]*$/;

// 长度单位
const cssLengthUnits = ['px', '%', 'dp'];
// 角度单位
const cssAngleUnits = ['deg'];
// radial-gradient
const SHARP = ['ellipse', 'circle'];
const SIZE = ['farthest-corner', 'closest-side', 'closest-corner', 'farthest-side', '0'];
const POSITION = ['left', 'right', 'top', 'bottom', 'center'];
const STYLE_ATTRIBUTE_CONFIG = exports.STYLE_ATTRIBUTE_CONFIG = {
  // boxModel
  transition: {
    // csstree-validator可校验
    // 扩展转换
    translate: sourceNode => {
      return _ExtendedBoxStyle.default.extendBoxStyle(sourceNode);
    }
  },
  transitionProperty: {
    // csstree-validator可校验
    // 按照1.0，值无需进行特殊转换
  },
  transitionDelay: {
    // csstree-validator可校验
    // 按照1.0，值无需进行特殊转换
  },
  transitionDuration: {
    // csstree-validator可校验
    // 按照1.0，值无需进行特殊转换
  },
  transitionTimingFunction: {
    // csstree-validator可校验
    // 按照1.0，值无需进行特殊转换
  },
  width: {
    // csstree-validator可校验
    // 按照1.0，值无需进行特殊转换
  },
  height: {
    // csstree-validator可校验
    // 按照1.0，值无需进行特殊转换
  },
  minHeight: {
    // csstree-validator可校验
    // 按照1.0，值无需进行特殊转换
  },
  minWidth: {
    // csstree-validator可校验
    // 按照1.0，值无需进行特殊转换
  },
  maxHeight: {
    // csstree-validator可校验
    // 按照1.0，值无需进行特殊转换
  },
  maxWidth: {
    // csstree-validator可校验
    // 按照1.0，值无需进行特殊转换
  },
  padding: {
    translate: function (sourceNode) {
      return _ExtendedBoxStyle.default.extendBoxStyle(sourceNode);
    }
  },
  paddingLeft: {
    // csstree-validator可校验
    // 按照1.0，值无需进行特殊转换
  },
  paddingRight: {
    // csstree-validator可校验
    // 按照1.0，值无需进行特殊转换
  },
  paddingTop: {
    // csstree-validator可校验
    // 按照1.0，值无需进行特殊转换
  },
  paddingBottom: {
    // csstree-validator可校验
    // 按照1.0，值无需进行特殊转换
  },
  margin: {
    translate: function (sourceNode) {
      return _ExtendedBoxStyle.default.extendBoxStyle(sourceNode);
    }
  },
  marginLeft: {
    // csstree-validator可校验
    // 按照1.0，值无需进行特殊转换
  },
  marginRight: {
    // csstree-validator可校验
    // 按照1.0，值无需进行特殊转换
  },
  marginTop: {
    // csstree-validator可校验
    // 按照1.0，值无需进行特殊转换
  },
  marginBottom: {
    // csstree-validator可校验
    // 按照1.0，值无需进行特殊转换
  },
  border: {
    translate: function (sourceNode) {
      return _ExtendedBoxStyle.default.extendBoxStyle(sourceNode);
    }
  },
  borderLeft: {
    // csstree-validator可校验
    translate: function (sourceNode) {
      return _ExtendedBoxStyle.default.extendBoxStyle(sourceNode);
    }
  },
  borderRight: {
    // csstree-validator可校验
    translate: function (sourceNode) {
      return _ExtendedBoxStyle.default.extendBoxStyle(sourceNode);
    }
  },
  borderTop: {
    // csstree-validator可校验
    translate: function (sourceNode) {
      return _ExtendedBoxStyle.default.extendBoxStyle(sourceNode);
    }
  },
  borderBottom: {
    // csstree-validator可校验
    translate: function (sourceNode) {
      return _ExtendedBoxStyle.default.extendBoxStyle(sourceNode);
    }
  },
  borderWidth: {
    translate: function (sourceNode) {
      return _ExtendedBoxStyle.default.extendBoxStyle(sourceNode);
    }
  },
  borderLeftWidth: {
    // csstree-validator可校验
    // 按照1.0，值无需进行特殊转换
  },
  borderTopWidth: {
    // csstree-validator可校验
    // 按照1.0，值无需进行特殊转换
  },
  borderRightWidth: {
    // csstree-validator可校验
    // 按照1.0，值无需进行特殊转换
  },
  borderBottomWidth: {
    // csstree-validator可校验
    // 按照1.0，值无需进行特殊转换
  },
  borderColor: {
    translate: function (sourceNode) {
      return _ExtendedBoxStyle.default.extendBoxStyle(sourceNode);
    }
  },
  borderLeftColor: {
    // csstree-validator可校验
    // 按照1.0，值无需进行特殊转换
  },
  borderTopColor: {
    // csstree-validator可校验
    // 按照1.0，值无需进行特殊转换
  },
  borderRightColor: {
    // csstree-validator可校验
    // 按照1.0，值无需进行特殊转换
  },
  borderBottomColor: {
    // csstree-validator可校验
    // 按照1.0，值无需进行特殊转换
  },
  borderStyle: {
    // csstree-validator可校验
    // 按照1.0，值无需进行特殊转换
  },
  borderRadius: {
    // csstree-validator可校验
    // 按照1.0，值无需进行特殊转换
  },
  borderBottomLeftRadius: {
    // csstree-validator可校验
    // 按照1.0，值无需进行特殊转换
  },
  borderBottomRightRadius: {
    // csstree-validator可校验
    // 按照1.0，值无需进行特殊转换
  },
  borderTopLeftRadius: {
    // csstree-validator可校验
    // 按照1.0，值无需进行特殊转换
  },
  borderTopRightRadius: {
    // csstree-validator可校验
    // 按照1.0，值无需进行特殊转换
  },
  indicatorSize: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validateLengthNode(sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  indicatorTop: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validateLengthNode(sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  indicatorRight: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validateLengthNode(sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  indicatorBottom: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validateLengthNode(sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  indicatorLeft: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validateLengthNode(sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  filter: {
    // csstree-validator可校验，但校验细节不如1.0仔细
    // 值需进行特殊转换
    translate: function (sourceNode) {
      const {
        name,
        value
      } = sourceNode;
      const targetNode = {};
      const paramResult = {};
      value.forEach(v => {
        if ('param' in v) {
          const {
            name: vName,
            param
          } = v;
          paramResult[vName] = param.map(p => p.value).join(', ');
        } else {
          // filter: none
          targetNode[name] = v.value;
        }
      });
      targetNode[name] = Object.keys(paramResult).length > 0 ? JSON.stringify(paramResult) : '';
      return targetNode;
    }
  },
  overflow: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  // flexbox
  flex: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  flexGrow: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  flexShrink: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  flexBasis: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  flexDirection: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  flexWrap: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  justifyContent: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  alignItems: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  alignContent: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  alignSelf: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  // position
  position: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  top: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  bottom: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  left: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  right: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  zIndex: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  // common
  opacity: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  background: {
    // csstree-validator可校验,但与1.0校验原理不同，目前按照1.0逻辑进行校验
    /**
     * 验证属性值每个参数的格式
     * @param sourceNode
     * @returns
     */
    validate: sourceNode => {
      let validateInfo = {
        level: _sharedUtils.Loglevel.WARN,
        message: []
      };
      const {
        value,
        name: attributeName
      } = sourceNode;
      /**
       * 创建线性渐变背景的函数
       * 参数分为两类：direction渐变的方向、color-stop渐变颜色的位置
       * @param valueStr
       * @returns
       */
      const validLinearGradient = sourceNode => {
        let validInfo = {
          level: _sharedUtils.Loglevel.WARN,
          message: []
        };
        const valueList = sourceNode.param;
        // 记录是否进入color-stop模式
        let colorStop = false;
        // 校验direction|angle（非必要参数）
        let directionCheck = false;
        for (let i = 0; i < valueList.length; i++) {
          switch (valueList[i].type) {
            case 'Identifier':
              if (i === 0 && valueList[i].value === 'to') {
                directionCheck = true;
              } else {
                if (directionCheck) {
                  // 校验direction中仅能出现下述字符串
                  if (!['left', 'right', 'top', 'bottom'].includes(valueList[i].value)) {
                    // 值内容不在指定范围内
                    validInfo.message = [`the value`, {
                      word: `'${valueList[i].value}'`
                    }, 'of attribute', {
                      word: attributeName
                    }, `is incorrect`];
                  }
                } else {
                  if (!colorStop) {
                    const colorResult = validColor(valueList[i].value);
                    if (colorResult.message.length > 0) {
                      // 颜色值校验报错
                      validInfo.message = [`the color value`, {
                        word: `'${valueList[i].value}'`
                      }, 'of attribute', {
                        word: attributeName
                      }, `is incorrect. `, ...colorResult.message];
                    } else {
                      colorStop = true;
                    }
                  } else {
                    // 是Identifier，但是没有进入颜色校验
                    validInfo.message = [`the value`, {
                      word: `'${valueList[i].value}'`
                    }, 'of attribute', {
                      word: attributeName
                    }, `is the correct format`];
                  }
                }
              }
              break;
            case 'Dimension':
              // 10dp 10px 10deg
              if (i === 0 && valueList[i].value.endsWith('deg')) {
                directionCheck = false;
              } else {
                if (!colorStop) {
                  // 非颜色起止状态中出现维度值
                  validInfo.message = [`the value`, {
                    word: `'${valueList[i].value}'`
                  }, 'of attribute', {
                    word: attributeName
                  }, `should appear after the color value or direction`];
                }
              }
              break;
            case 'Operator':
              if (directionCheck) {
                directionCheck = false;
              }
              if (colorStop) {
                colorStop = false;
              }
              break;
            case 'Percentage':
              // 50%
              if (!colorStop) {
                // 非颜色起止状态，出现百分比报错
                validInfo.message = [`the value`, {
                  word: `'${valueList[i].value}'`
                }, 'of attribute', {
                  word: attributeName
                }, `should appear after the color value`];
              }
              break;
            case 'Number':
              if (colorStop) {
                if (valueList[i].value !== '0') {
                  validInfo.message = [`the value`, {
                    word: `'${valueList[i].value}'`
                  }, 'of attribute', {
                    word: attributeName
                  }, `missing unit`];
                }
              } else {
                // 非颜色起止状态，出现百分比报错
                validInfo.message = [`the value`, {
                  word: `'${valueList[i].value}'`
                }, 'of attribute', {
                  word: attributeName
                }, `should appear after the color value`];
              }
              break;
            case 'Function':
            // rgba()
            case 'Hash':
              // #ffffff
              if (!colorStop) {
                const colorResult = validColor(valueList[i].value);
                if (colorResult.message.length > 0) {
                  // 颜色值校验报错
                  validInfo.message = [`the color value`, {
                    word: `'${valueList[i].value}'`
                  }, 'of attribute', {
                    word: attributeName
                  }, `is incorrect. `, ...colorResult.message];
                } else {
                  colorStop = true;
                }
              } else {
                // 是Hash值，但是已经是颜色校验状态
                validInfo.message = [`the hash value`, {
                  word: `'${valueList[i].value}'`
                }, 'of attribute', {
                  word: attributeName
                }, `is the correct format`];
              }
              break;
            default:
              // 出现未处理类型参数
              validInfo.message = [`the value`, {
                word: `'${valueList[i].value}'`
              }, 'of attribute', {
                word: attributeName
              }, `is unexpected`];
              break;
          }
        }
        return validInfo;
      };
      /**
       * 创建径向渐变背景的函数
       * 参数分为四类：
       *  1. sharp 圆的类型，可选参数
       *    1.1 ellipse
       *    1.2 circle
       *  2. size 渐变尺寸，可选参数
       *    2.1 [farthest-corner、closest-side、closest-corner、farthest-side]
       *    2.2 50% 60px
       *    2.3 30%
       * 3. position 渐变位置，可选参数
       *    3.1 at [center、top、left、right、bottom]
       *    3.2 at 30% 20%
       *    3.3 at center top
       *  4. color 渐变颜色
       * @param sourceNode
       * @returns
       */
      const validRadialGradient = sourceNode => {
        let validInfo = {
          level: _sharedUtils.Loglevel.WARN,
          message: []
        };
        const valueList = sourceNode.param;
        const valueStr = valueList.map(v => v.value).join(' ');
        const firstValue = valueList[0];
        let startColorIndex = 0;
        if (validColor(firstValue.value).message.length > 1) {
          // 非颜色值，对第一个operator前的值进行sharp size at position校验
          startColorIndex = valueList.findIndex(item => item.type === 'Operator');
          const sharpSizeValueList = valueList.slice(0, startColorIndex);
          let checkState = 0;
          sharpSizeValueList.forEach(item => {
            let haveError = false;
            switch (item.type) {
              case 'Identifier':
                if (SHARP.includes(item.value)) {
                  if (checkState < 1) {
                    checkState = 1;
                  } else {
                    // 报错，sharp位置错误
                    haveError = true;
                  }
                } else if (SIZE.includes(item.value)) {
                  if (checkState < 2) {
                    checkState = 2;
                  } else {
                    // 报错，size位置错误
                    haveError = true;
                  }
                } else if (item.value === 'at') {
                  checkState = 3;
                } else if (POSITION.includes(item.value)) {
                  if (checkState !== 3) {
                    // 报错，position值的位置错误
                    haveError = true;
                  }
                } else {
                  // 报错，未考虑到的值
                  haveError = true;
                }
                break;
              case 'Dimension':
              case 'Percentage':
                if (checkState < 3) {
                  // 该值表示size
                  checkState = 2;
                }
                break;
              default:
                // 报错
                haveError = true;
                break;
            }
            if (haveError) {
              validInfo.message = [`the value`, {
                word: `'${item.value}'`
              }, 'of attribute', {
                word: attributeName
              }, `in radial-gradient`, {
                word: `(${valueStr})`
              }, `is incorrect`];
            }
          });
        }
        // 校验颜色节点
        let checkColor = false;
        for (let i = startColorIndex + 1; i < valueList.length; i++) {
          switch (valueList[i].type) {
            case 'Identifier':
            case 'Hash':
            case 'Function':
              if (!checkColor) {
                const colorResult = validColor(valueList[i].value);
                if (colorResult.message.length > 1) {
                  // 颜色值错误，该位置应为颜色值
                  validInfo.message = [`the value in radial-gradient`, {
                    word: `(${valueStr})`
                  }, 'of attribute', {
                    word: attributeName
                  }, `should be color. `, ...colorResult.message];
                } else {
                  checkColor = true;
                }
              } else {
                // 报错，已经进入了校验颜色状态
                validInfo.message = [`the params format of function radial-gradient`, {
                  word: `(${valueStr})`
                }, 'of attribute', {
                  word: attributeName
                }, `is wrong`];
              }
              break;
            case 'Operator':
              checkColor = false;
              break;
            case 'Dimension':
            case 'Percentage':
              if (checkColor) {
                // 一个颜色后面只能出现一个宽度设置
                checkColor = false;
              } else {
                // 报错，在非校验颜色状态时出现宽度设置，颜色设置有误
                validInfo.message = [`the params format of function radial-gradient`, {
                  word: `(${valueStr})`
                }, 'of attribute', {
                  word: attributeName
                }, `is wrong`];
              }
              break;
            case 'Number':
              if (valueList[i].value !== '0') {
                validInfo.message = [`the value`, {
                  word: `'${valueList[i].value}'`
                }, 'of attribute', {
                  word: attributeName
                }, `in radial-gradient`, {
                  word: `(${valueStr})`
                }, `missing unit`];
              }
              break;
            default:
              // 报错，出现非预期类型值
              validInfo.message = [`the value`, {
                word: `'${valueList[i].value}'`
              }, 'of attribute', {
                word: attributeName
              }, `is unexpected`];
              break;
          }
        }
        return validInfo;
      };
      if ('name' in value[0]) {
        for (let i = 0; i < value.length; i++) {
          if ('value' in value[i] && value[i].value === ',') {
            // 链接符，无需处理
            continue;
          }
          const v = value[i];
          if (v.name.indexOf('-gradient') >= 0) {
            // 校验参数格式，例如：校验linear-gradient(red, blue)中的参数格式是否正确
            const validResult = v.name.indexOf('linear') >= 0 ? validLinearGradient(v) : validRadialGradient(v);
            // length > 0,说明校验有报错，否则该值校验成功
            if (validResult.message.length > 0) {
              //有错误
              validateInfo.message.push(...validResult.message);
            }
          } else {
            // 不支持的写法
            validateInfo.message = [`the function name`, {
              word: `'${v.name}'`
            }, 'of attribute', {
              word: attributeName
            }, `is unexpected`];
          }
        }
      } else {
        // 解析格式错误
        validateInfo.message = [`Error parsing the value of`, {
          word: `'${attributeName}'`
        }];
      }
      return validateInfo;
    },
    // 值生成
    translate: sourceNode => {
      let targetNode = {};
      const {
        value,
        name
      } = sourceNode;
      const valueResult = [];
      const generateLinearGradient = sourceNode => {
        let targetNode = {
          type: '',
          directions: ['to', 'bottom'],
          // 默认从上到下
          values: []
        };
        const {
          name,
          param
        } = sourceNode;
        let directionState = 0;
        let colorStop = [];
        let directions = [];
        targetNode.type = _sharedUtils.StringUtil.hyphenedToCamel(name);
        for (let i = 0; i < param.length; i++) {
          if (i === 0 && (param[i].value === 'to' || param[i].value.endsWith('deg'))) {
            directions = [param[i].value];
            directionState = 1;
            continue;
          }
          if (param[i].type === 'Operator') {
            if (directionState === 1) {
              directionState = 2;
            }
            if (colorStop.length > 0) {
              ;
              targetNode.values.push(colorStop.join(' '));
              colorStop = [];
            }
            continue;
          }
          if (directionState === 0 || directionState === 2) {
            colorStop.push(param[i].value);
          } else {
            directions.push(param[i].value);
          }
          if (i === param.length - 1 && colorStop) {
            ;
            targetNode.values.push(colorStop.join(' '));
          }
        }
        if (directions.length > 0) {
          targetNode.directions = directions;
        }
        return targetNode;
      };
      const generateRadialGradient = sourceNode => {
        let targetNode = {
          type: '',
          size: ['farthest-corner'],
          directions: ['center'],
          // 默认center
          values: []
        };
        const {
          name,
          param
        } = sourceNode;
        targetNode.type = _sharedUtils.StringUtil.hyphenedToCamel(name);
        // 拆分出sharp size at position，第一个operator前的值
        let startColorIndex = param.findIndex(item => item.type === 'Operator');
        let positionState = false;
        let sizeStr = '';
        for (let i = 0; i < startColorIndex; i++) {
          if (SIZE.includes(param[i].value)) {
            sizeStr = param[i].value;
          } else if (param[i].value === 'at') {
            positionState = true;
          } else if (POSITION.includes(param[i].value)) {
            ;
            targetNode.directions.push(param[i].value);
          } else if (param[i].type === 'Dimension' || param[i].type === 'Percentage') {
            if (positionState) {
              ;
              targetNode.directions.push(param[i].value);
            } else {
              sizeStr = sizeStr + ' ' + param[i].value;
            }
          }
        }
        if (sizeStr) {
          targetNode.size = [sizeStr];
        }
        // color节点
        let colorStr = '';
        for (let i = startColorIndex + 1; i < param.length; i++) {
          if (param[i].type === 'Operator') {
            ;
            targetNode.values.push(colorStr);
            colorStr = '';
          } else {
            colorStr += param[i].value;
          }
          if (i === param.length - 1 && colorStr) {
            ;
            targetNode.values.push(colorStr);
          }
        }
        return targetNode;
      };
      if ('name' in value[0]) {
        for (let i = 0; i < value.length; i++) {
          if ('value' in value[i] && value[i].value === ',') {
            // 链接符，无需处理
            continue;
          }
          const v = value[i];
          if (v.name.indexOf('-gradient') >= 0) {
            // 分类生成节点内容
            const generateResult = v.name.indexOf('linear') >= 0 ? generateLinearGradient(v) : generateRadialGradient(v);
            valueResult.push(generateResult);
          }
        }
      }
      targetNode[name] = JSON.stringify({
        values: valueResult
      });
      return targetNode;
    }
  },
  backgroundColor: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  backgroundImage: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  backgroundSize: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  backgroundRepeat: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  backgroundPosition: {
    // csstree-validator可校验
    // 转换扩展，待实现translate
  },
  display: {
    /**
     * sourceNode 示例：
     * {
     *  name: 'display',
     *  value: [{
     *    unit: '',
     *    value: 'flex'
     *  }]
     * }
     * @param sourceNode
     * @returns
     */
    validate: function (sourceNode) {
      const supportValues = ['flex', 'none'];
      const {
        name,
        value
      } = sourceNode;
      let validateInfo = {
        level: _sharedUtils.Loglevel.WARN,
        message: []
      };
      if (Array.isArray(value) && value.length === 1) {
        if ('value' in value[0]) {
          if (!supportValues.includes(value[0].value)) {
            validateInfo.message = [`the value of attibute '${name}' is `, {
              word: `'${value[0].value}'`
            }, `, please change to a valid value.`];
          }
        } else {
          // value[0]结构异常，当前value结构为
          validateInfo.message = [`'display' value structure is abnormal. The current value structure is`, {
            word: JSON.stringify(value[0])
          }];
        }
      } else {
        // 转换结果有问题，value内容如下
        validateInfo.message = [`There is a problem with the 'display' attribute conversion, the value content is as follows`, {
          word: JSON.stringify(value)
        }];
      }
      return validateInfo;
    }
  },
  visibility: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  objectFit: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  altObjectFit: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return enumValidate(['fill', 'contain', 'cover', 'none', 'scale-down'], sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  boxShadow: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  backgroundBlendMode: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  textShadow: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  // mask
  maskImage: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  maskPosition: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  maskComposite: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  maskSize: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  maskRepeat: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  // text
  lines: {
    translate: function (sourceNode) {
      const targetNode = {};
      const {
        name,
        value
      } = sourceNode;
      if (Array.isArray(value) && value.length === 1 && 'value' in value[0]) {
        targetNode[name] = parseFloat(value[0].value);
      }
      return targetNode;
    }
  },
  color: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  fontSize: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  fontStyle: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  fontWeight: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  textDecoration: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  textAlign: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  lineHeight: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  textOverflow: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  textIndent: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  // animation
  transform: {
    translate: function (sourceNode) {
      const targetNode = {};
      const {
        name,
        value
      } = sourceNode;
      let paramList = [];
      targetNode[name] = {};
      const translateTransformItem = valueNode => {
        let translateReultNode = {};
        if ('name' in valueNode) {
          const {
            name: valueName,
            param
          } = valueNode;
          if (param.length === 0) {
            param[0] = {
              value: '',
              type: ''
            };
          }
          switch (valueName) {
            case 'translate':
            case 'scale':
              // 过滤操作符
              paramList = param.filter(p => {
                return p.type !== 'Operator';
              }).map(v => v.value);
              translateReultNode = {
                [`${valueName}X`]: paramList[0],
                [`${valueName}Y`]: paramList.length >= 2 ? paramList[1] : valueName === 'translate' ? '0px' : paramList[0]
              };
              break;
            default:
              paramList = param.map(v => v.value);
              translateReultNode = {
                [valueName]: paramList.length > 1 ? paramList.join('') : paramList[0]
              };
              break;
          }
          targetNode[name] = {
            ...targetNode[name],
            ...translateReultNode
          };
        } else {
          // 报错，格式错误，或者先符合validate的条件再转换
        }
      };
      value.map(v => {
        translateTransformItem(v);
      });
      targetNode[name] = JSON.stringify(targetNode[name]);
      return targetNode;
    }
  },
  transformOrigin: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  animationName: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  animationDuration: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  animationTimingFunction: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  pageAnimationName: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validName(sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  pageTransformOrigin: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validPosition(sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  animationDelay: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  animationIterationCount: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  animationFillMode: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  animationDirection: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  // custom
  placeholderColor: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validColorNode(sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  selectedColor: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validColorNode(sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  textColor: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validColorNode(sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  timeColor: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validColorNode(sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  textHighlightColor: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validColorNode(sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  strokeWidth: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  progressColor: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validColorNode(sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  indicatorColor: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validColorNode(sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  indicatorSelectedColor: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validColorNode(sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  slideWidth: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validateLengthNode(sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  slideMargin: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validateLengthNode(sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  resizeMode: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return enumValidate(['cover', 'contain', 'stretch', 'center'], sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  columns: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  columnSpan: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  maskColor: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validColorNode(sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  blockColor: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validColorNode(sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  mylocation: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validMyLocation(sourceNode);
    },
    // 值转换
    translate: sourceNode => {
      return translateMyLocation(sourceNode);
    }
  },
  mylocationFillColor: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validColorNode(sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  mylocationStrokeColor: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validColorNode(sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  mylocationIconPath: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validUrl(sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  caretColor: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  thumbColor: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validColorNode(sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  trackColor: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validColorNode(sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  layerColor: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validColorNode(sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  layoutType: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return enumValidate(['grid', 'stagger'], sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  // custom style
  starBackground: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validUrl(sourceNode);
    }
    // 值在parser中已转换，无需额外转换
  },
  starForeground: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validUrl(sourceNode);
    }
    // 值在parser中已转换，无需额外转换
  },
  starSecondary: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validUrl(sourceNode);
    }
    // 值在parser中已转换，无需额外转换
  },
  fontFamily: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  // Progress style
  startAngle: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validAngleNode(sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  totalAngle: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validAngleNode(sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  centerX: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validateLengthNode(sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  centerY: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validateLengthNode(sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  radius: {
    // csstree-validator不可校验
    validate: sourceNode => {
      return validateLengthNode(sourceNode);
    }
    // 按照一般转换即可，无需额外转换
  },
  scrollSnapType: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  },
  scrollSnapAlign: {
    // csstree-validator可校验
    // 按照一般转换即可，无需额外转换
  }
};
/**
 * 校验节点的长度值
 * @param sourceNode
 * @returns
 */
function validateLengthNode(sourceNode) {
  const {
    name: attributeName,
    value
  } = sourceNode;
  const simpleValueInfo = validSimpleValue(sourceNode);
  let validateInfo = {
    level: _sharedUtils.Loglevel.WARN,
    message: []
  };
  if (simpleValueInfo.message.length > 0) {
    return simpleValueInfo;
  } else {
    // 符合单值要求，继续校验
    value[0] = value[0];
    const validResult = validLength(value[0]);
    if (validResult.message.length > 0) {
      validateInfo.message = [`The value verification of attribute`, {
        word: attributeName
      }, `failed.`, ...validResult.message];
    }
  }
  return validateInfo;
}
/**
 * 使用css-tree的语法解析来做校验
 * @param value
 * @returns
 */
function validLength(value) {
  let validateInfo = {
    level: _sharedUtils.Loglevel.WARN,
    message: []
  };
  if (_cssTree.default.lexer.matchType('length', value.value + value.unit).error !== null) {
    validateInfo.message = [`The length value is`, {
      word: value.value || 'null'
    }, `, unit is`, {
      word: value.unit || 'null'
    }, `, which does not meet the length standard.`];
  }
  return validateInfo;
}
/**
 * 校验枚举值
 */
function enumValidate(enumList, sourceNode) {
  const {
    name: attributeName,
    value
  } = sourceNode;
  const simpleValueInfo = validSimpleValue(sourceNode);
  let validateInfo = {
    level: _sharedUtils.Loglevel.WARN,
    message: []
  };
  if (simpleValueInfo.message.length > 0) {
    return simpleValueInfo;
  } else {
    // 符合单值要求，继续校验
    value[0] = value[0];
    const index = enumList.indexOf(value[0].value);
    if (index < 0) {
      validateInfo.message = [`The value`, {
        word: `'${value}'`
      }, `of attribute`, {
        word: `'${attributeName}'`
      }, `is invalid ( valid enumeration value:`, {
        word: `'${enumList.join('|')}'`
      }, `)`];
    }
  }
  return validateInfo;
}
/**
 * 校验ValueType[]数组中的仅有一个值，且结构为SimpleValueType
 */
function validSimpleValue(sourceNode) {
  const {
    name: attributeName,
    value
  } = sourceNode;
  let validateInfo = {
    level: _sharedUtils.Loglevel.WARN,
    message: []
  };
  if (value.length !== 1) {
    // 值长度不符合要求
    validateInfo.message = [`Error parsing the value length`, `of`, {
      word: `'${attributeName}'`
    }, `is`, {
      word: value.length
    }, `, which does not meet the requirement.`];
  } else {
    if (!('value' in value[0])) {
      // 属性值解析错误
      validateInfo.message = [`Error parsing the value of`, {
        word: `'${attributeName}'`
      }];
    }
  }
  return validateInfo;
}
/**
 * 颜色值校验, 支持 rgb, rgba, hsl, hsla, #fff, #fffa, #ffffff, #ffffffaa, named-color
 * @param value
 */
function validColorNode(sourceNode) {
  const {
    value,
    name: attributeName
  } = sourceNode;
  const simpleValueInfo = validSimpleValue(sourceNode);
  let validateInfo = {
    level: _sharedUtils.Loglevel.WARN,
    message: []
  };
  if (simpleValueInfo.message.length > 0) {
    return simpleValueInfo;
  } else {
    // 符合单值要求，继续校验
    value[0] = value[0];
    const valueStr = value[0].value;
    const validResult = validColor(valueStr);
    if (validResult.message.length > 0) {
      validateInfo.message = [`The value verification of attribute `, {
        word: attributeName
      }, `failed.`, ...validResult.message];
    }
    return validateInfo;
  }
}
/**
 * 使用css-tree的语法解析来做校验
 * @param value
 * @returns
 */
function validColor(value) {
  let validateInfo = {
    level: _sharedUtils.Loglevel.WARN,
    message: []
  };
  if (_cssTree.default.lexer.matchType('color', value).error !== null) {
    validateInfo.message = [`The color value`, {
      word: `'${value}'`
    }, `is invalid`];
  }
  return validateInfo;
}
/**
 * 校验值符合REGEXP_NAME正则表达式
 * @param sourceNode
 * @returns
 */
function validName(sourceNode) {
  const {
    value,
    name: attributeName
  } = sourceNode;
  const simpleValueInfo = validSimpleValue(sourceNode);
  let validateInfo = {
    level: _sharedUtils.Loglevel.WARN,
    message: []
  };
  if (simpleValueInfo.message.length > 0) {
    return simpleValueInfo;
  } else {
    // 符合单值要求，继续校验
    value[0] = value[0];
    if (!value[0].value.match(REGEXP_NAME)) {
      validateInfo.message = [`The value`, {
        word: `'${value[0].value}'`
      }, `of attribute`, {
        word: attributeName
      }, `is not in the correct format`];
    }
  }
  return validateInfo;
}
/**
 * 校验位置
 * 1. 位置值长度最多为3
 * 2. 每一个(旧版本中要求值类型必须为长度值)
 * @param sourceNode
 * @returns
 */
function validPosition(sourceNode) {
  let validateInfo = {
    level: _sharedUtils.Loglevel.WARN,
    message: []
  };
  const {
    value,
    name: attributeName
  } = sourceNode;
  if (value.length <= 0) {
    validateInfo.message = [`Error parsing the value of attribute`, {
      word: `${attributeName}`
    }];
  } else if (value.length > 3) {
    validateInfo.message = [`Error parsing the value length`, `of`, {
      word: `'${attributeName}'`
    }, `is`, {
      word: value.length
    }, `, which does not meet the requirement.`];
  } else {
    value.forEach(v => {
      v = v;
      const validResult = validLength(v);
      // 有报错
      if (validResult.message.length > 0) {
        validateInfo.message.push(...validResult.message);
      }
    });
    // 如果有报错，添加一下属性名
    if (validateInfo.message.length > 0) {
      validateInfo.message.unshift(`The value verification of attribute `, {
        word: attributeName
      }, `failed.`);
    }
  }
  return validateInfo;
}
/**
 * 校验mylocation属性
 * 1. 属性值最多有三个
 * 2. 扩展值
 *  2.1 第一次出现的颜色为mylocationFillColor属性值
 *  2.2 第二次出现的颜色为mylocationStrokeColor属性值
 *  2.3 url值为mylocationIconPath属性值
 *
 * @param sourceNode
 * @returns
 */
function validMyLocation(sourceNode) {
  let validateInfo = {
    level: _sharedUtils.Loglevel.WARN,
    message: []
  };
  let countColor = 0;
  let countUrl = 0;
  let elseValue = 0;
  let valueStr = '';
  const {
    value,
    name: attributeName
  } = sourceNode;
  if (value.length > 0 && value.length <= 3) {
    value.forEach(v => {
      v = v;
      valueStr = valueStr + ', ' + v.value + v.unit;
      if (_UxUtil.default.isAbsoluteResource(v.value) || v.value.match(/^none$/i)) {
        countUrl++;
      } else if (validColor(v.value)) {
        countColor++;
      } else {
        elseValue++;
      }
    });
    if (!(countUrl <= 1 && countColor <= 2 && elseValue === 0)) {
      // 格式错误
      validateInfo.message = [`the value`, {
        word: `'${valueStr}'`
      }, `of attribute`, {
        word: attributeName
      }, 'does not meet the fillColor、strokeColor and iconPath test standard'];
    }
  } else {
    // 错误
    validateInfo.message = [`Error parsing the value length`, `of`, {
      word: `'${attributeName}'`
    }, `is`, {
      word: value.length
    }, `, which does not meet the requirement.`];
  }
  return validateInfo;
}
/**
 * 校验url值，由于parser时已转换了url值，所以校验步骤修改如下：
 * 1. 是否绝对路径
 * 2. 是否为网络值
 * 3. 是否为none
 * @param sourceNode
 * @returns
 */
function validUrl(sourceNode) {
  let validateInfo = {
    level: _sharedUtils.Loglevel.WARN,
    message: []
  };
  const simpleValueInfo = validSimpleValue(sourceNode);
  const {
    value,
    name: attributeName
  } = sourceNode;
  if (simpleValueInfo.message.length > 0) {
    return simpleValueInfo;
  } else {
    // 符合简单值要求，继续校验
    const nodeV = value[0].value;
    if (!(_UxUtil.default.isAbsoluteResource(nodeV) || nodeV.match(/^none$/i))) {
      // 不符合要求
      validateInfo.message = [`The value`, {
        word: `'${nodeV}'`
      }, `of attribute`, {
        word: attributeName
      }, `is error`];
    }
  }
  return validateInfo;
}
/**
 * 校验单位
 * @param sourceNode
 * @returns
 */
function validAngleNode(sourceNode) {
  let validateInfo = {
    level: _sharedUtils.Loglevel.WARN,
    message: []
  };
  const simpleValueInfo = validSimpleValue(sourceNode);
  const {
    value,
    name: attributeName
  } = sourceNode;
  if (simpleValueInfo.message.length > 0) {
    return simpleValueInfo;
  } else {
    // 符合简单值要求，继续校验
    value[0] = value[0];
    const validResult = validAngle(value[0].unit);
    if (validResult.message.length > 0) {
      validateInfo.message = [`The value verification of attribute `, {
        word: attributeName
      }, `failed.`, ...validResult.message];
    }
  }
  return validateInfo;
}
function validAngle(value) {
  let validateInfo = {
    level: _sharedUtils.Loglevel.WARN,
    message: []
  };
  if (!cssAngleUnits.includes(value)) {
    validateInfo.message = [`The value unit is`, {
      word: value || 'null'
    }, `, not the specified unit (`, {
      word: cssLengthUnits.join(', ')
    }, ')'];
  }
  return validateInfo;
}
function translateMyLocation(sourceNode) {
  let targetNode = {};
  let haveFillColor = false;
  const {
    value
  } = sourceNode;
  value.forEach(v => {
    v = v;
    if (_UxUtil.default.isAbsoluteResource(v.value) || v.value.match(/^none$/i)) {
      targetNode['mylocationIconPath'] = v.value;
    } else if (validColor(v.value)) {
      if (haveFillColor) {
        targetNode['mylocationStrokeColor'] = v.value;
      } else {
        haveFillColor = true;
        targetNode['mylocationFillColor'] = v.value;
      }
    }
  });
  return targetNode;
}
const STYLE_ATTRIBUTE_LIST = exports.STYLE_ATTRIBUTE_LIST = Object.keys(STYLE_ATTRIBUTE_CONFIG);