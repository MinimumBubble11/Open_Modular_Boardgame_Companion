"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _sharedUtils = require("@aiot-toolkit/shared-utils");
var parse5 = _interopRequireWildcard(require("aiot-parse5"));
var _path = _interopRequireDefault(require("path"));
var _TemplateUtil = _interopRequireDefault(require("../translate/vela/utils/TemplateUtil"));
var _UxUtil = _interopRequireDefault(require("../utils/UxUtil"));
var _ScriptParser = _interopRequireDefault(require("./ScriptParser"));
var _StyleParser = _interopRequireDefault(require("./StyleParser"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * UxParser
 */
class UxParser {
  constructor(options, compilerOption, globalVar, collectImageResource) {
    this.options = options;
    this.compilerOption = compilerOption;
    this.globalVar = globalVar;
    this.collectImageResource = collectImageResource;
  }
  async parser() {
    const content = this.options.content;
    const fileName = _path.default.basename(this.options.filePath);
    const ast = {
      template: {
        nodeName: '#document-fragment',
        childNodes: []
      },
      script: {
        content: ''
      },
      style: {
        styleContent: []
      },
      import: []
    };
    const uxAst = parse5.parseFragment(content, {
      scriptingEnabled: false,
      sourceCodeLocationInfo: true
    });
    if (this.validateContent(uxAst.childNodes)) {
      // 拆分tempalte script style
      for (const childNode of uxAst.childNodes) {
        const {
          nodeName
        } = childNode;
        switch (nodeName) {
          case 'template':
            // 将节点转为文本内容
            ast.template = childNode.content;
            break;
          case 'script':
            // 存储script正文的偏移行数
            this.options.scriptOffsetLine = 0;
            if (childNode?.childNodes?.[0]?.sourceCodeLocation) {
              this.options.scriptOffsetLine = childNode.childNodes[0].sourceCodeLocation.startLine || 0;
            }
            const scriptContent = parse5.serialize(childNode);
            const scriptParserResult = new _ScriptParser.default(this.options).parser(scriptContent);
            ast.script = scriptParserResult.ast;
            break;
          case 'style':
            const cssContent = parse5.serialize(childNode);
            // 获取lang值，组合成文件名
            const langType = _UxUtil.default.getLangType(childNode);
            const cssFileName = _UxUtil.default.spliceFileName(fileName, langType);
            // 转换全局变量为符合lang类型的字符串
            const globalStyle = _UxUtil.default.convertGlobalJson(this.globalVar, langType);
            // 解析CSS 转为 js格式的内容
            const cssParserResult = await new _StyleParser.default(this.options, this.compilerOption, this.collectImageResource, childNode.sourceCodeLocation?.startLine || 0).parser(`${cssContent}\n${globalStyle}`, cssFileName);
            // 多Style标签(TODO: 应该不支持多style标签)
            ast.style.styleContent.push(...cssParserResult.ast.styleContent);
            break;
          case 'import':
            this.parserImport(childNode, ast);
            break;
          default:
            break;
        }
      }
    }
    return {
      ast,
      offsetList: []
    };
  }

  /**
   * 验证内容
   * 1. template：
   *    a. 最多1个
   *    b. 子元素有且仅有1个，不能是 block
   */
  validateContent(childNodes) {
    let result = true;
    const {
      onLog,
      filePath
    } = this.options;
    const templateCount = childNodes.filter(node => node.nodeName === 'template').length;
    // const scriptCount = childNodes.filter((node) => node.nodeName === 'script').length || 0

    // 1.a
    if (templateCount && templateCount > 1) {
      onLog({
        level: _sharedUtils.Loglevel.THROW,
        filePath,
        message: [{
          word: '<template>'
        }, `There are`, {
          word: templateCount
        }, `, but expect at most`, {
          word: 1
        }]
      });
      result = false;
    }
    // 1.b
    else if (templateCount === 1) {
      const templateNode = childNodes.filter(node => node.nodeName === 'template')[0];
      const templateChildNodes = templateNode.content.childNodes;
      const elements = templateChildNodes.filter(node => _TemplateUtil.default.isElement(node));
      if (elements.length !== 1) {
        onLog({
          level: _sharedUtils.Loglevel.THROW,
          filePath,
          position: _TemplateUtil.default.parse5LocationToPosition(templateNode.sourceCodeLocation?.startTag),
          message: [{
            word: '<template>'
          }, `There are`, {
            word: elements.length
          }, `children, but expect to have`, {
            word: 1
          }]
        });
        result = false;
      }
    }

    // 2
    // if (scriptCount !== 1) {
    //   onLog({
    //     level: Loglevel.THROW,
    //     filePath,
    //     message: [
    //       { word: '<script>' },
    //       `There are`,
    //       { word: scriptCount },
    //       `, but expect to have`,
    //       { word: 1 }
    //     ]
    //   })
    //   result = false
    // }

    return result;
  }
  /**
   * 解析import内容
   * @param sourceNode
   * @param ast
   */
  parserImport(sourceNode, ast) {
    const {
      onLog
    } = this.options;
    // 必须要有name和src
    let name = '';
    let src = '';
    for (let item of sourceNode.attrs) {
      if (item.name === 'src') {
        // src中文件后缀需从ux转为js
        src = item.value;
      }
      if (item.name === 'name') {
        name = item.value;
      }
    }
    if (name && src) {
      ast.import.push({
        name,
        src
      });
    } else {
      onLog({
        filePath: this.options.filePath,
        position: _TemplateUtil.default.parse5LocationToPosition(sourceNode.sourceCodeLocation?.startTag),
        level: _sharedUtils.Loglevel.ERROR,
        message: ['### uxParser ### import missing', {
          word: `name or src`
        }]
      });
    }
  }
}
var _default = exports.default = UxParser;