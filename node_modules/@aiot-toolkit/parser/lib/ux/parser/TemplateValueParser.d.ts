export interface ITemplateValueItem {
    value: string;
    type: TemplateValueType;
    start: number;
    end: number;
}
export declare enum TemplateValueType {
    CHAR = 1,
    CODE = 2
}
export default class TemplateValueParser {
    /**
     * 解析模板字符串
     *
     * 概述：模板字符串包含两种类型--文字类型和代码类型，代码类型被包裹在 {{}}中
     * 例如 a{{b}}c，[{value:'a', type:'文字类型'}, {value:'b', type:'代码类型'}, {value:'c', type:'文字类型'}]
     *
     * @example `new TemplateValueParser().parse('a{{b}}c')`
     *
     * 解析过程
     * 1. 初始
     *    a. 状态为文字状态
     *    b. 定义变量`bracketCounter`，记录'{'的数量
     *    b. 遍历字符串进行解析
     * 2. 文字状态
     *    a. 遇到 { 且下个字符也是 {, 则：
     *        a1. 如果当前值有值，则添加到结果列表中(文本类型)
     *        a2. 循环序号+1
     *        a4. bracketCounter重置为0
     *        a3. 进入代码状态
     *    b. 否则，字符添加到当前值中
     * 3. 代码状态
     *    a. 遇到 }
     *        c1. 如计数为0
     *            c11. 判断后面的字符是否为}
     *                c111. 如果是，如果当前值有值，则添加到结果列表中(代码类型)并进入`文字状态`
     *                c112. 否则，字符添加到当前值
     *        c2. 否则，计数减1，但最小值为0
     *    b. 遇到 {
     *        b1. 如果下一个字符也是{，则报错
     *        b2. 否则计数+1, 并把字符添加到当前值-因为js代码会有{}，例如
     * ```
     *
     * {{()=>{}}}
     * 12    3456
     *
     * // 遇到3时，是{，计数加1
     * // 遇到4时，是}, 计数减1, 此时计数为0
     * // 遇到5时，是{，计数为0，则判断下一个字符也是}, jscode 状态结束
     * ```
     *    c. 如果是"或', 进入`代码_字符串`状态，同时字符添加到当前值
     *    d. 否则，字符添加到当前值
     * 4. 代码_字符串
     *    a. 字符添加到当前值中
     *    c. 如果是"或', 则：退回到`代码状态`
     * 5. 遇到最后一个字符
     *    a. 如果仍处于代码状态，则把`{{ + 当前值`以文字类型添加到结果列表中. 示例：a{{b --> [a, {{b]
     *    b. 否则，把`当前值`以`文字类型`添加到结果列表中
     * 6. 返回结果列表
     * @param template
     */
    parse(template: string): ITemplateValueItem[];
}
