"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TemplateValueType = void 0;
let TemplateValueType = exports.TemplateValueType = /*#__PURE__*/function (TemplateValueType) {
  TemplateValueType[TemplateValueType["CHAR"] = 1] = "CHAR";
  TemplateValueType[TemplateValueType["CODE"] = 2] = "CODE";
  return TemplateValueType;
}({});
var TemplateValueParseState = /*#__PURE__*/function (TemplateValueParseState) {
  TemplateValueParseState[TemplateValueParseState["IN_CHAR"] = 1] = "IN_CHAR";
  TemplateValueParseState[TemplateValueParseState["IN_CODE"] = 2] = "IN_CODE";
  TemplateValueParseState[TemplateValueParseState["IN_CODE_STRING"] = 3] = "IN_CODE_STRING";
  return TemplateValueParseState;
}(TemplateValueParseState || {});
class TemplateValueParser {
  /**
   * 解析模板字符串
   *
   * 概述：模板字符串包含两种类型--文字类型和代码类型，代码类型被包裹在 {{}}中
   * 例如 a{{b}}c，[{value:'a', type:'文字类型'}, {value:'b', type:'代码类型'}, {value:'c', type:'文字类型'}]
   *
   * @example `new TemplateValueParser().parse('a{{b}}c')`
   *
   * 解析过程
   * 1. 初始
   *    a. 状态为文字状态
   *    b. 定义变量`bracketCounter`，记录'{'的数量
   *    b. 遍历字符串进行解析
   * 2. 文字状态
   *    a. 遇到 { 且下个字符也是 {, 则：
   *        a1. 如果当前值有值，则添加到结果列表中(文本类型)
   *        a2. 循环序号+1
   *        a4. bracketCounter重置为0
   *        a3. 进入代码状态
   *    b. 否则，字符添加到当前值中
   * 3. 代码状态
   *    a. 遇到 }
   *        c1. 如计数为0
   *            c11. 判断后面的字符是否为}
   *                c111. 如果是，如果当前值有值，则添加到结果列表中(代码类型)并进入`文字状态`
   *                c112. 否则，字符添加到当前值
   *        c2. 否则，计数减1，但最小值为0
   *    b. 遇到 {
   *        b1. 如果下一个字符也是{，则报错
   *        b2. 否则计数+1, 并把字符添加到当前值-因为js代码会有{}，例如
   * ```
   *
   * {{()=>{}}}
   * 12    3456
   *
   * // 遇到3时，是{，计数加1
   * // 遇到4时，是}, 计数减1, 此时计数为0
   * // 遇到5时，是{，计数为0，则判断下一个字符也是}, jscode 状态结束
   * ```
   *    c. 如果是"或', 进入`代码_字符串`状态，同时字符添加到当前值
   *    d. 否则，字符添加到当前值
   * 4. 代码_字符串
   *    a. 字符添加到当前值中
   *    c. 如果是"或', 则：退回到`代码状态`
   * 5. 遇到最后一个字符
   *    a. 如果仍处于代码状态，则把`{{ + 当前值`以文字类型添加到结果列表中. 示例：a{{b --> [a, {{b]
   *    b. 否则，把`当前值`以`文字类型`添加到结果列表中
   * 6. 返回结果列表
   * @param template
   */
  parse(template) {
    let state = TemplateValueParseState.IN_CHAR;
    let bracketCounter = 0;
    let currentValue = '';
    let currentStart = 0;
    let codeStringStartChar = '';
    const result = [];
    for (let i = 0; i < template.length; i++) {
      const char = template[i];
      switch (state) {
        case TemplateValueParseState.IN_CHAR:
          if (char === '{' && template[i + 1] === '{') {
            if (currentValue) {
              result.push({
                value: currentValue,
                type: TemplateValueType.CHAR,
                start: currentStart,
                end: i
              });
              currentValue = '';
            }
            i++; // 跳过下一个字符
            bracketCounter = 0;
            state = TemplateValueParseState.IN_CODE;
            currentStart = i + 1;
          } else {
            if (currentValue === '') {
              currentStart = i;
            }
            currentValue += char;
          }
          break;
        case TemplateValueParseState.IN_CODE:
          if (char === '}') {
            if (bracketCounter === 0 && template[i + 1] === '}') {
              if (currentValue) {
                result.push({
                  value: currentValue,
                  type: TemplateValueType.CODE,
                  start: currentStart,
                  end: i
                });
                currentValue = '';
              }
              i++; // 跳过下一个字符
              state = TemplateValueParseState.IN_CHAR;
              currentStart = i + 1;
            } else {
              bracketCounter = Math.max(0, bracketCounter - 1);
              currentValue += char;
            }
          } else if (char === '{') {
            if (template[i + 1] === '{') {
              throw new Error("Unexpected '{{' inside code block");
            } else {
              bracketCounter++;
              currentValue += char;
            }
          } else if (char === '"' || char === "'") {
            currentValue += char;
            state = TemplateValueParseState.IN_CODE_STRING;
            codeStringStartChar = char;
          } else {
            currentValue += char;
          }
          break;
        case TemplateValueParseState.IN_CODE_STRING:
          currentValue += char;
          if (char === codeStringStartChar) {
            state = TemplateValueParseState.IN_CODE;
            codeStringStartChar = '';
          }
          break;
      }
    }

    // 处理最后一个字符
    if (currentValue) {
      if (state === TemplateValueParseState.IN_CODE) {
        result.push({
          value: '{{' + currentValue,
          type: TemplateValueType.CHAR,
          start: currentStart - 2,
          end: template.length
        });
      } else {
        result.push({
          value: currentValue,
          type: TemplateValueType.CHAR,
          start: currentStart,
          end: template.length
        });
      }
    }
    return result;
  }
}
exports.default = TemplateValueParser;