"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _sharedUtils = require("@aiot-toolkit/shared-utils");
var _cssTree = _interopRequireWildcard(require("css-tree"));
var _lodash = _interopRequireDefault(require("lodash"));
var _less = _interopRequireDefault(require("less"));
var _path = _interopRequireDefault(require("path"));
var _postcss = _interopRequireDefault(require("postcss"));
var _postcssImport = _interopRequireDefault(require("postcss-import"));
var _postcssUrl = _interopRequireDefault(require("postcss-url"));
var _sass = _interopRequireDefault(require("sass"));
var _StyleSelectorType = require("../enum/StyleSelectorType");
var _StyleUtil = _interopRequireDefault(require("../utils/StyleUtil"));
var _sourceMap = require("source-map");
var _StyleMapUtil = _interopRequireDefault(require("../utils/StyleMapUtil"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const {
  validate: CsstreeValidator
} = require('csstree-validator');
/**
 * StyleParser
 * 1. 根据语言类型分别转为CSS样式
 * 2. 用CSSTREE解析CSS内容
 * 3. 把解析结果转换为目标格式
 */
class StyleParser {
  constructor(options, compilerOption, collectImageResource, styleLineOffset) {
    this.options = options;
    this.compilerOption = compilerOption;
    this.collectImageResource = collectImageResource;
    this.styleLineOffset = styleLineOffset;
    this.nodeMap = {
      version: 3,
      sources: [],
      names: [],
      mappings: '',
      file: ''
    };
  }
  async parser(content, fileName) {
    const {
      onLog
    } = this.options;
    const {
      ext: fileExt
    } = _path.default.parse(fileName);
    // 文件名后缀为样式语言类型
    switch (fileExt) {
      case '.less':
        content = (await this.lessToCss(content)) || '';
        break;
      case '.scss':
        content = (await this.scssToCss(content, false)) || '';
        break;
      case '.sass':
        content = (await this.scssToCss(content, true)) || '';
        break;
      case '.css':
      case '.postcss':
        break;
      default:
        onLog({
          level: _sharedUtils.Loglevel.ERROR,
          filePath: this.options.filePath,
          message: [{
            word: `[${fileExt}]`
          }, `is an unsupported CSS preprocessor, and will be converted directly as CSS`]
        });
        break;
    }
    // 所有语言都要再进行一次css解析，处理例如@import导入css文件等语法
    content = (await this.parserCss(content)) || '';
    // 将获取的map信息转为consumer对象
    this.sourceMapConsumer = await new _sourceMap.SourceMapConsumer(this.nodeMap);
    this.styleMapUtil = new _StyleMapUtil.default(this.sourceMapConsumer, this.styleLineOffset, this.options);
    // 使用CSSTREE解析CSS内容
    let errors = [];
    const originAst = _cssTree.default.parse(content, {
      positions: true,
      onParseError(error, fallbackNode) {
        const validError = _StyleUtil.default.collectParserError(error, fallbackNode);
        validError && errors.push(validError);
      }
    });
    // 解析错误全部抛出
    errors = this.printError('parserError', errors);
    errors.push(..._StyleUtil.default.collectSyntaxError(CsstreeValidator(originAst, fileName)));
    // 校验错误打印warn
    this.printError('validateError', errors);
    const cssAst = {
      styleContent: []
    };
    // 转换为目标树
    _cssTree.default.walk(originAst, {
      visit: 'StyleSheet',
      enter: node => {
        // 循环children
        const nodeChildrens = node.children;
        for (const children of nodeChildrens) {
          // 记录一个rule结构
          cssAst.styleContent.push(this.parserNode(children));
        }
      }
    });
    return {
      ast: cssAst
    };
  }
  /**
   * 将Less样式转为CSS
   * @param sourceContent
   * @returns
   */
  lessToCss(sourceContent) {
    let CSSCode = '';
    const {
      onLog,
      filePath
    } = this.options;
    const baseName = _path.default.basename(filePath);
    return new Promise((resolve, reject) => {
      _less.default.render(sourceContent, {
        filename: filePath,
        relativeUrls: true,
        sourceMap: {
          sourceMapURL: `${baseName}.map`,
          outputSourceFiles: true
        }
      }, (error, output) => {
        if (error) {
          onLog({
            level: _sharedUtils.Loglevel.THROW,
            filePath,
            message: `### lessToCss ### ${error}`
          });
          reject(`### lessToCss ### ${error}`);
        } else {
          CSSCode = output?.css ? output.css : '';
          if (output?.map) {
            this.nodeMap = output.map;
          }
          resolve(CSSCode);
        }
      });
    });
  }
  /**
   * 将Scss样式转为CSS
   * @param sourceContent
   * @returns
   */
  async scssToCss(sourceContent, isSass) {
    const {
      onLog,
      filePath
    } = this.options;
    try {
      let Result = await _sass.default.compileStringAsync(sourceContent, {
        url: new URL(`file://${filePath}`),
        sourceMap: true,
        sourceMapIncludeSources: true,
        charset: false,
        syntax: isSass ? 'indented' : 'scss'
      });
      if (Result.sourceMap) {
        this.nodeMap = JSON.stringify(Result.sourceMap);
      }
      return Result.css;
    } catch (error) {
      onLog({
        level: _sharedUtils.Loglevel.THROW,
        message: `### scssToCss ### ${error}`,
        filePath
      });
    }
  }
  /**
   * 使用postcss做css样式转换
   * 例如：将@import 转换为引入的内容
   * @param sourceContent
   * @returns
   */
  async parserCss(sourceContent) {
    const {
      onLog,
      filePath
    } = this.options;
    try {
      const result = await (0, _postcss.default)([(0, _postcssImport.default)(), _postcssUrl.default]).process(sourceContent, {
        from: filePath,
        map: {
          prev: this.nodeMap,
          inline: false,
          annotation: true
        }
      });
      this.nodeMap = result.map.toString();
      return result.css;
    } catch (error) {
      onLog({
        level: _sharedUtils.Loglevel.THROW,
        filePath,
        message: `### Css ### ${error?.toString() || 'unknown error'}`
      });
    }
  }
  /**
   * 解析CSS语法树的上的节点
   * 1. 将节点按照rule节点、Atrule节点、没有prelude属性的Atrule节点区分
   * 2. 节点内容将按照定义的IRuleType类型返回
   * @param sourceNode
   * @returns
   */
  parserNode(sourceNode) {
    let targetNode = {
      type: '',
      name: '',
      prelude: [],
      rules: [],
      block: []
    };
    const sourceNodeType = sourceNode.type;
    if (sourceNodeType === _StyleSelectorType.IRuleTypes.RULE) {
      // rule节点
      targetNode = this.paserRuleNode(sourceNode);
    } else if (sourceNodeType === _StyleSelectorType.IRuleTypes.AT_RULE) {
      if (sourceNode.prelude) {
        // Atrule节点
        targetNode = this.paserAtRuleNode(sourceNode);
      } else {
        // @media {} 不写条件和媒体类型时，没有prelude
        if ('name' in sourceNode && sourceNode.name === _StyleSelectorType.AtruleSelector.MEDIA) {
          return targetNode;
        }
        // 没有prelude属性的Atrule节点
        targetNode = this.parserNoPreludeAtRule(sourceNode);
      }
    }
    return targetNode;
  }
  /**
   * 解析rule节点
   * @param sourceNode
   * @returns 返回预定义的RuleType结构
   */
  paserRuleNode(sourceNode) {
    const targetNode = {
      type: '',
      prelude: [],
      block: [],
      position: sourceNode.loc ? this.styleMapUtil.transfromLocToPosition(sourceNode.loc) : undefined
    };
    const {
      type,
      prelude,
      block
    } = sourceNode;
    targetNode.type = type;
    targetNode.prelude = this.parserPrelude(prelude);
    targetNode.block = this.parserBlock(block);
    return targetNode;
  }
  /**
   * 解析一般的Atrule节点
   * @param sourceNode
   * @returns 返回预定义的AtRuleType结构
   */
  paserAtRuleNode(sourceNode) {
    const targetNode = {
      type: '',
      name: '',
      prelude: [],
      rules: [],
      position: sourceNode.loc ? this.styleMapUtil.transfromLocToPosition(sourceNode.loc) : undefined
    };
    const {
      type,
      prelude,
      block,
      name
    } = sourceNode;
    targetNode.type = type;
    targetNode.name = name;
    if (prelude && prelude.children) {
      targetNode.prelude = this.parserPrelude(prelude);
    } else {
      if (prelude) {
        const preludeStr = prelude.value;
        const replaceStr = preludeStr.replace(/(\d+\.\d+|\d)+\s*([-+*/])\s*(\d+\.\d+|\d)+/g, match => {
          try {
            return _lodash.default.round(eval(match), 2) + '';
          } catch (error) {
            return match;
          }
        });
        targetNode.prelude.push([{
          type: prelude.type,
          name: replaceStr
        }]);
      }
    }
    if (block) {
      block.children.forEach(ruleNode => {
        targetNode.rules.push(this.parserNode(ruleNode));
      });
    }
    return targetNode;
  }
  /**
   * 解析没有prelude属性的Atrule节点
   * 1. 处理block中的属性和值的内容
   * @param sourceNode
   * @returns 返回预定义的NoPreludeAtRule结构
   */
  parserNoPreludeAtRule(sourceNode) {
    const targetNode = {
      type: '',
      name: '',
      block: [],
      position: sourceNode.loc ? this.styleMapUtil.transfromLocToPosition(sourceNode.loc) : undefined
    };
    const {
      type,
      block,
      name
    } = sourceNode;
    targetNode.type = type;
    targetNode.name = name;
    // 此时block内容与rule节点的block内容相同
    targetNode.block = this.parserBlock(block);
    return targetNode;
  }
  /**
   * 解析prelude节点
   * 1. SelectorList时，返回选择器列表
   * 2. AtrulePrelude时，返回条件字符串列表
   * @param nodeList
   * @returns
   */
  parserPrelude(sourceNode) {
    let targetList = [];
    // 1.
    if (_StyleUtil.default.isSelectorList(sourceNode)) {
      sourceNode.children.toArray().forEach(node => {
        if ('children' in node) {
          let childResult = [];
          node.children?.toArray().forEach(childNode => {
            childResult.push({
              type: childNode.type,
              name: _StyleUtil.default.generateNodename(childNode)
            });
          });
          targetList.push(childResult);
        }
      });
    }
    // 2.
    else if (_StyleUtil.default.isAtrulePrelude(sourceNode)) {
      sourceNode.children.toArray().forEach(node => {
        if (_StyleUtil.default.isMediaQueryList(node)) {
          targetList = _StyleUtil.default.parseMediaQueryList(this.options, node, this.styleMapUtil);
        } else {
          targetList.push([{
            type: node.type,
            name: _StyleUtil.default.generateNodename(node)
          }]);
        }
      });
    } else {
      // type 为 Raw等非预期格式
      targetList.push([{
        type: sourceNode.type,
        name: (0, _cssTree.generate)(sourceNode)
      }]);
    }
    return targetList;
  }
  /**
   * 解析block结构
   * 生成属性name和value组成的对象列表
   * [
   *  {
   *    name: '',
   *    value: [{value:'', unit:''}, ...]
   *  }, ...
   * ]
   * @param sourceNode
   * @returns
   */
  parserBlock(sourceNode) {
    const targetList = [];
    const {
      onLog,
      filePath
    } = this.options;
    sourceNode.children.forEach(node => {
      if (_StyleUtil.default.isDeclaration(node)) {
        const nodeName = node.property.replace(/-([a-z])/g, function (s, m) {
          return m.toUpperCase();
        });
        targetList.push(...this.parserValue(nodeName, node));
      } else {
        // 该类型结构未被toolkit识别
        onLog({
          level: _sharedUtils.Loglevel.ERROR,
          filePath: filePath,
          position: node.loc ? this.styleMapUtil.transfromLocToPosition(node.loc) : undefined,
          message: `Structure ${node.type} is not recognized, ${JSON.stringify(node)}`
        });
      }
    });
    return targetList;
  }
  /**
   * 解析value属性
   * 1. 若value对象有'Children'属性则表示存在值，否则返回空列表
   * 2. 循环Children列表，遇到操作符、Url做特殊处理
   * 3. 其他子项，需要取出value和unit内容
   */
  parserValue(nodeName, node) {
    const {
      onLog,
      filePath
    } = this.options;
    const targetList = [];
    const nodeValue = node.value;
    let valueList = [];
    // 处理value内容
    if ('children' in nodeValue) {
      // children为空时
      if (!nodeValue.children || nodeValue.children.size <= 0) {
        return targetList;
      }
      // children不为空时
      let value = '';
      nodeValue.children.map(v => {
        let tempTargetValue;
        const tempPosition = v.loc ? this.styleMapUtil.transfromLocToPosition(v.loc) : undefined;
        switch (v.type) {
          case 'Operator':
            value = _cssTree.default.generate(v);
            tempTargetValue = {
              value,
              unit: ''
            };
            break;
          case 'Url':
            if ('value' in v && v.value) {
              //此处应该传入文件路径
              value = _StyleUtil.default.handleDynamicAssets(this.options, this.compilerOption, v.value, this.collectImageResource, tempPosition);
              tempTargetValue = {
                value,
                unit: ''
              };
            } else {
              // 警告：不能为空
              onLog({
                level: _sharedUtils.Loglevel.WARN,
                filePath: tempPosition?.source || filePath,
                position: tempPosition,
                message: ['The value in', {
                  word: 'url'
                }, 'is empty']
              });
              tempTargetValue = {
                value: '',
                unit: ''
              };
            }
            break;
          case 'Hash':
            value = _cssTree.default.generate(v);
            tempTargetValue = {
              value,
              unit: ''
            };
            break;
          case 'Percentage':
            tempTargetValue = {
              value: v.value,
              unit: v.type
            };
            break;
          case 'Function':
            if (nodeName === 'transform' || nodeName === 'filter' || nodeName === 'background') {
              const childList = v.children.toArray().map(item => {
                return {
                  type: item.type,
                  value: _cssTree.default.generate(item)
                };
              });
              tempTargetValue = {
                name: v.name,
                param: childList
              };
              break;
            }
          default:
            if ('value' in v && v.value) {
              if (typeof v.value === 'string') {
                value = v.value;
              } else {
                value = _cssTree.default.generate(v.value);
              }
            } else {
              value = _cssTree.default.generate(v);
            }
            tempTargetValue = {
              value,
              unit: 'unit' in v && v.unit ? v.unit : ''
            };
            break;
        }
        if (tempTargetValue) {
          tempTargetValue.position = tempPosition;
          valueList.push(tempTargetValue);
        }
      });
      targetList.push({
        name: nodeName,
        value: valueList,
        position: node.loc ? this.styleMapUtil.transfromLocToPosition(node.loc) : undefined
      });
    }
    return targetList;
  }
  printError(errorType) {
    let errors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    let isParserError = errorType === 'parserError';
    let sourceCodeStyle = _sharedUtils.Loglevel.WARN;
    const {
      onLog,
      filePath
    } = this.options;
    if (isParserError) {
      sourceCodeStyle = _sharedUtils.Loglevel.ERROR;
    }
    errors.forEach(error => {
      const sourceCode = error.source ? [`, source code:`, {
        word: `${error.source}`
      }] : [];
      onLog({
        level: sourceCodeStyle,
        filePath,
        position: {
          pos: 0,
          end: 0,
          startLine: error.startLine + this.styleLineOffset - 2 || 0,
          startColumn: error.startCol || 0,
          endLine: 0,
          endColumn: 0
        },
        message: [{
          word: error.message
        }, ...sourceCode]
      });
    });
    return [];
  }
}
var _default = exports.default = StyleParser;