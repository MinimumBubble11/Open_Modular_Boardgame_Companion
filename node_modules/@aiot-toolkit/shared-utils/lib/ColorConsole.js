"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _chalk = _interopRequireDefault(require("chalk"));
var _dayjs = _interopRequireDefault(require("dayjs"));
var _ILog = require("./interface/ILog");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * Log
 */
class ColorConsole {
  static defaultStyle = {
    color: '#cccccc'
  };
  static styleDic = (() => ({
    [_ILog.Loglevel.SUCCESS]: {
      color: '#008000',
      icon: 'âœ…'
    },
    [_ILog.Loglevel.INFO]: {
      color: '#03A9F4',
      icon: 'ğŸ”·'
    },
    [_ILog.Loglevel.WARN]: {
      color: '#FF9800',
      icon: 'ğŸŸ '
    },
    [_ILog.Loglevel.ERROR]: {
      color: '#ff0000',
      icon: 'âŒ'
    },
    [_ILog.Loglevel.THROW]: {
      color: '#ff0000',
      bold: true,
      icon: 'âŒ'
    },
    [_ILog.Loglevel.LOG]: ColorConsole.defaultStyle
  }))();
  static getStyle(logLevel) {
    return ColorConsole.styleDic[logLevel] || ColorConsole.defaultStyle;
  }
  static log() {
    for (var _len = arguments.length, message = new Array(_len), _key = 0; _key < _len; _key++) {
      message[_key] = arguments[_key];
    }
    return ColorConsole._log(_ILog.Loglevel.LOG, ...message);
  }
  static error() {
    for (var _len2 = arguments.length, message = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      message[_key2] = arguments[_key2];
    }
    return ColorConsole._log(_ILog.Loglevel.ERROR, ...message);
  }
  static info() {
    for (var _len3 = arguments.length, message = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      message[_key3] = arguments[_key3];
    }
    return ColorConsole._log(_ILog.Loglevel.INFO, ...message);
  }
  static success() {
    for (var _len4 = arguments.length, message = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      message[_key4] = arguments[_key4];
    }
    return ColorConsole._log(_ILog.Loglevel.SUCCESS, ...message);
  }
  static throw() {
    for (var _len5 = arguments.length, message = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      message[_key5] = arguments[_key5];
    }
    ColorConsole._log(_ILog.Loglevel.THROW, ...message);
  }
  static warn() {
    for (var _len6 = arguments.length, message = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      message[_key6] = arguments[_key6];
    }
    return ColorConsole._log(_ILog.Loglevel.WARN, ...message);
  }

  /**
   * åˆ›å»ºå¤æ‚æ ¼å¼çš„æ¶ˆæ¯ï¼Œå¯å•ç‹¬è®¾ç½®è¯è¯­æ ·å¼
   *
   * @example
   * ```js
   * createMessage("my name is", {message:'****', style:{ color:'red' }})
   * ```
   * @param words
   * @returns
   */
  static createMessage(words) {
    const list = Array.isArray(words) ? words : [words];
    const result = list.map(item => {
      if (typeof item === 'object') {
        return ColorConsole.formatWord(item.word, item.style);
      }
      return ColorConsole.formatWord(item, ColorConsole.defaultStyle);
    }).join(' ');
    return result;
  }
  static _log(logLevel) {
    const style = ColorConsole.styleDic[logLevel] || ColorConsole.defaultStyle;
    for (var _len7 = arguments.length, message = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
      message[_key7 - 1] = arguments[_key7];
    }
    console.log(ColorConsole.createDefaultPrefix({
      level: logLevel,
      message
    }).join(' ') + ColorConsole.createMessage(message.map(item => {
      if (typeof item === 'object') {
        return {
          ...item,
          style: item.style || style
        };
      }
      return item;
    })));
  }
  static formatWord(word, style) {
    if (word === undefined || word === null) {
      return '';
    }
    const {
      color,
      bgColor,
      bold,
      italic
    } = style || ColorConsole.defaultStyle;
    let result = word;
    if (color) {
      result = _chalk.default.hex(color)(result);
    }
    if (bgColor) {
      result = _chalk.default.bgHex(bgColor)(result);
    }
    if (bold) {
      result = _chalk.default.bold(result);
    }
    if (italic) {
      result = _chalk.default.italic(result);
    }
    return result;
  }

  /**
   * æŒ‰ç…§æ—¥å¿—ç±»å‹æ‰“å°ä¸åŒé¢œè‰²çš„æ—¥å¿—
   * @param log é»˜è®¤æ—¥å¿—ç±»å‹ä¸ºinfo
   * @returns è¿”å›æ‰“å°çš„æ—¥å¿—ä¿¡æ¯
   */
  static logger(log) {
    const str = ColorConsole.logToString(log);
    console.log(str);
  }

  /**
   * æ—¥å¿—è½¬æ¢ä¸ºå¸¦é¢œè‰²çš„å­—ç¬¦ä¸²
   *
   * @param log æ—¥å¿—å¯¹è±¡
   * @param prefix å‰ç¼€åˆ—è¡¨
   * false-ä¸ä½¿ç”¨å‰ç¼€
   * string[]-è‡ªå®šä¹‰å‰ç¼€
   * é»˜è®¤-[å›¾æ ‡ã€æ—¶é—´ã€toolkitå­—æ ·]
   *
   * @example logToString(log, ['myPrefix'])
   */
  static logToString(log, prefix) {
    const {
      message,
      position,
      filePath,
      level = _ILog.Loglevel.INFO
    } = log;

    // ä½ç½®æ¶ˆæ¯
    let positionMessage = filePath ? {
      style: ColorConsole.getStyle(level),
      word: [filePath, position?.startLine, position?.startColumn].filter(item => Boolean(item)).join(':')
    } : null;
    const logs = Array.isArray(message) ? message : [message];
    if (positionMessage) {
      logs.unshift(positionMessage);
    }

    // å‰ç¼€
    let effectPrefix;
    if (prefix === false) {
      prefix = [];
    }
    if (prefix === undefined) {
      effectPrefix = ColorConsole.createDefaultPrefix(log);
    } else {
      effectPrefix = prefix;
    }
    const style = ColorConsole.styleDic[level] || ColorConsole.defaultStyle;
    return [...effectPrefix].join(' ') + ColorConsole.createMessage(logs.map(item => {
      if (typeof item === 'object') {
        return {
          ...item,
          // å¯¹è±¡æ ¼å¼æ¶ˆæ¯çš„æ ·å¼ä¾æ¬¡ä½¿ç”¨ï¼š[æ¶ˆæ¯è‡ªèº«æ ·å¼, logæ ·å¼, é»˜è®¤æ ·å¼]
          style: item.style || style
        };
      }
      return item;
    }));
  }

  /**
   * åˆ›å»ºé»˜è®¤æ¶ˆæ¯å‰ç¼€åˆ—è¡¨
   *
   * 1. å›¾æ ‡
   * 2. æ—¶é—´
   * 3. toolkit å­—æ ·
   *
   * @param log
   */
  static createDefaultPrefix(log) {
    const {
      level = _ILog.Loglevel.INFO
    } = log;
    const style = ColorConsole.styleDic[level] || ColorConsole.defaultStyle;
    const time = ColorConsole.formatWord(`[${(0, _dayjs.default)().format('MM-DD HH:mm:ss')}] [toolkit]: `, style);
    const icon = style.icon ? style.icon : '';
    return [icon, time];
  }
}
var _default = exports.default = ColorConsole;