"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _sharedUtils = require("@aiot-toolkit/shared-utils");
var _fsExtra = _interopRequireDefault(require("fs-extra"));
var _jszip = _interopRequireDefault(require("jszip"));
var _path = _interopRequireDefault(require("path"));
var _UxFileUtils = _interopRequireDefault(require("../../../../utils/ux/UxFileUtils"));
var _CompileMode = _interopRequireDefault(require("../../../enum/CompileMode"));
var _BuildNameFormatType = _interopRequireDefault(require("../enum/BuildNameFormatType"));
var _Package = _interopRequireDefault(require("../model/Package"));
var _UxCompileUtil = _interopRequireDefault(require("./UxCompileUtil"));
var _SignUtil = _interopRequireDefault(require("./signature/SignUtil"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * Zip 用于将打包成功的 build 目录按特定规则压缩成 rpk
 *
 * @see ZipUtil.createRpk 打包的完整规则
 */
class ZipUtil {
  static DIGEST_HASH_JSON = 'hash.json';

  // 摘要文件夹
  static META_PATH = 'META-INF';

  // 文件摘要包（zip 文件）
  static CERT_PATH = `${this.META_PATH}/CERT`;

  // 打包信息文件
  static BUILD_FILE_PATH = `${this.META_PATH}/build.txt`;

  /**
   * zip压缩参数
   */
  static ZIP_OPTION = {
    type: 'nodebuffer',
    compression: 'DEFLATE',
    compressionOptions: {
      level: 9
    }
  };

  /**
   * dist 目录生成 rpk
   * 1. 获取文件列表
   *    1. 过滤出需要的文件
   *    2. 按配置排序
   * 2. 生成文件流
   *    1. 每个文件生成加密串
   *    2. 生成元数据流
   *    3. 把元数据流和普通文件合并到一个流
   * 3. 写入到硬盘
   * @param dist
   * @param param
   * @returns 生成的 rpk 文件名
   */
  static async createRpk(dist, param) {
    const config = _UxFileUtils.default.getMainfestInfo(param.projectPath, param.sourceRoot);

    // 1
    const files = this.getSortedFiles(dist, param, config);
    if (!files.length) {
      _sharedUtils.ColorConsole.error(`The build file is missing, stop generating the application package, please check carefully`);
      return;
    }

    // 2
    const {
      fullPackage
    } = await this.createPackagesDefinition(param, config, files);

    // 生产出带签名的rpk文件buffer
    const signConfig = _SignUtil.default.getProjectSignConfig(param);
    const rpkBuffer = await ZipUtil.buildProjectAndOutput(fullPackage, signConfig);
    // 3
    return this.generateDistFile(rpkBuffer, param, this.getFileName(param, config, 'rpk'));
  }
  static getFileName(param, config, ext) {
    const {
      mode,
      buildNameFormat
    } = param;
    const {
      package: packageName
    } = config;
    return [packageName, mode === _CompileMode.default.DEVELOPMENT ? 'debug' : 'release', buildNameFormat === _BuildNameFormatType.default.ORIGINAL ? '' : config.versionName, ext].filter(Boolean).join('.');
  }
  static async packageToZipBuffer(target) {
    const {
      resourceList,
      comment
    } = target;
    const packageFileList = resourceList.map(item => {
      return {
        path: item.fileBuildPath,
        content: item.fileContentBuffer
      };
    });
    return await this.createZipBufferFromFileList(packageFileList, comment);
  }

  /**
   *
   * @param buffer
   * @param param
   * @param fileName
   *
   * @returns 生成的文件名
   */
  static async generateDistFile(buffer, param, fileName) {
    const {
      releasePath,
      projectPath
    } = param;
    const filePath = _path.default.join(projectPath, releasePath, fileName);
    _fsExtra.default.outputFileSync(filePath, buffer);
    _sharedUtils.ColorConsole.success(`Project build and generate files：${fileName}`);
    return fileName;
  }

  /**
   * 根据文件列表创建 zip 的 Buffer
   * @param fileList 文件列表
   * @param comment zip 的注释
   * @returns
   */
  static async createZipBufferFromFileList(fileList, comment) {
    const zip = new _jszip.default();
    fileList.forEach(item => {
      zip.file(item.path, item.content);
    });
    return await zip.generateAsync({
      ...this.ZIP_OPTION,
      comment
    });
  }

  /**
   * 创建包，一个包对应一个 rpk 文件
   * @param param
   * @param config
   * @param files
   * @returns
   */
  static async createPackagesDefinition(param, config, files) {
    const {
      projectPath,
      outputPath
    } = param;
    const {
      package: appPackage
    } = config;
    const comment = this.createComment(param);
    const fullPackage = new _Package.default({
      filePrefix: appPackage,
      fileSuffix: 'rpk',
      standalone: true,
      comment: JSON.stringify(comment)
    });

    // 写入文件
    for (let fileBuildPath of files) {
      const absPath = _path.default.join(projectPath, outputPath, fileBuildPath);
      let fileContentBuffer = _fsExtra.default.readFileSync(absPath);
      if (fileBuildPath === ZipUtil.CERT_PATH) {
        let metaZip = await _jszip.default.loadAsync(fileContentBuffer);
        fileContentBuffer = await metaZip.generateAsync({
          ...ZipUtil.ZIP_OPTION,
          comment: null
        });
      }
      const fileContentDigest = _sharedUtils.CommonUtil.calcDataDigest(fileContentBuffer);
      const resourceInfo = {
        fileBuildPath,
        fileContentBuffer,
        fileContentDigest
      };
      fullPackage.addResource(resourceInfo);

      // 分包相关逻辑 todo
    }
    return {
      fullPackage
    };
  }

  /**
   * 获取有序的文件列表
   *
   * 打包后的文件夹生成vela 应用程序，需要先把文件排序，再进行压缩
   *
   * @see getPriorities 获取排序规则
   *
   * @param dist 打包后的文件目录的绝对路径
   * @param param 打包参数
   * @returns
   */
  static getSortedFiles(dist, param, config) {
    const priorities = this.getPriorities(config);
    const getFileIndex = file => {
      const result = priorities.findIndex(item => {
        if (typeof item === 'string') {
          return item === file;
        }
        return file.match(item);
      });
      if (result < 0) {
        return Number.MAX_SAFE_INTEGER;
      }
      return result;
    };
    // 筛选中需要的文件并排序
    // 1. 排除META-INF 目录下的文件
    // 2. 生产环境排除 .map 文件
    const mapReg = /\.map$/;
    let result = _sharedUtils.FileUtil.readAlldirSync(dist);
    result = result.filter(item => {
      return !(item.startsWith(_UxCompileUtil.default.DIGEST_ZIP_DIR) || param.mode === _CompileMode.default.PRODUCTION && mapReg.test(item));
    }).map(item => _path.default.relative(dist, item).split(_path.default.sep).join(_path.default.posix.sep));
    result.sort((a, b) => {
      const indexA = getFileIndex(a);
      const indexB = getFileIndex(b);
      return indexA - indexB;
    });
    return result;
  }

  /**
   * 根据 **固定规则**、**manifest.json入口配置**，获取压缩文件时使用的排序规则
   *
   * @param param
   * @returns
   */
  static getPriorities(config) {
    const entrySkFiles = []; // todo
    const {
      entry
    } = config.router;
    const result = ['META-INF/CERT',
    // 多语言配置文件要在 manifest 之前
    /^i18n\/.+\.json$/i,
    // 多终端配置文件如manifest-tv.json，也要在manifest之前，不然流式加载初始化的时候，会读不到对应的终端配置文件
    /^manifest-\w+\.json$/, 'manifest.json', 'app.js', /page-chunks.json$/, /skeleton\/config\.json$/, ...entrySkFiles, new RegExp(`^${entry}/$`), new RegExp(`^${entry}/.+`), /^common\//i,
    // 静态资源
    /.+\.js/, 'META-INF/build.txt'];
    return result;
  }

  /**
   * 创建打包的注释属性
   */
  static createComment(param) {
    const obj = {
      originType: param.originType,
      toolkit: require(_path.default.join(__dirname, '../../../../../package.json')).version,
      timeStamp: new Date().toJSON(),
      node: process.version,
      platform: process.platform,
      arch: process.arch,
      component: true
    };
    return obj;
  }

  /**
   * 生成rpk的最终的Buffer
   *
   * @description 使用证书对原始rpk包的 buffer 签名. 签名失败，返回原始包； 签名成功，返回新包
   * @param fullPackage 原始包 buffer
   * @param signConfig 证书信息
   * @returns
   */
  static async buildProjectAndOutput(target, signConfig) {
    let result;
    if (signConfig) {
      const {
        privatekey,
        certificate
      } = signConfig;
      const fullPackageBuffer = await _SignUtil.default.signPackage(target, privatekey, certificate);
      if (fullPackageBuffer === false) {
        _sharedUtils.ColorConsole.throw('Fullpackage signature failed');
      } else {
        result = fullPackageBuffer;
      }
    }
    if (!result) {
      result = await this.packageToZipBuffer(target);
    }
    return result;
  }
}
var _default = exports.default = ZipUtil;