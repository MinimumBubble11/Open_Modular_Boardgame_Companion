"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _parser = require("@aiot-toolkit/parser");
var _sharedUtils = require("@aiot-toolkit/shared-utils");
var _fsExtra = _interopRequireDefault(require("fs-extra"));
var _path = _interopRequireDefault(require("path"));
var _TranslateCache = _interopRequireDefault(require("@aiot-toolkit/parser/lib/ux/translate/vela/TranslateCache"));
var _UxFileUtils = _interopRequireDefault(require("./ux/UxFileUtils"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const BinaryPlugin = require('@aiot-toolkit/parser/lib/ux/translate/vela/protobuf/BinaryPlugin');

/**
 * BeforeCompileUtils
 */
class BeforeCompileUtils {
  /**
   * 获取ux项目的路由入口
   * @param context
   * @param fileList
   * @returns
   */
  static getEntries = params => {
    const {
      context,
      compilerOption
    } = params;
    const {
      projectPath
    } = context;
    const srcPath = _path.default.join(projectPath, compilerOption.sourceRoot);
    // 判断路径是否真实存在
    const manifestContent = _UxFileUtils.default.getMainfestInfo(projectPath);
    // 存储entries
    let entryList = [];
    const {
      router
    } = manifestContent;
    if (router) {
      const {
        pages
      } = router;
      if (pages) {
        Object.keys(pages).map(page => {
          const pageContent = pages[page];
          const entryDir = _path.default.join(srcPath, page);
          const entryPages = _parser.ExtensionConfig.TEMPLATES.map(item => `${pageContent.component}${item}`);
          const entry = entryPages.find(item => _fsExtra.default.existsSync(_path.default.join(entryDir, item)));
          if (entry) {
            entryList.push(_path.default.join(entryDir, entry));
          } else {
            // 路径不存在
            _sharedUtils.ColorConsole.throw(`### manifest ### path '${_path.default.join(entryDir, entryPages.join(' | '))}' does not exist`);
          }
        });
      } else {
        // 没有pages配置
        _sharedUtils.ColorConsole.throw(`### manifest ### No pages configuration`);
      }
    } else {
      // 没有router配置
      _sharedUtils.ColorConsole.throw(`### manifest ### No router configuration`);
    }
    context['entries'] = entryList;
    return Promise.resolve();
  };
  static clean = async params => {
    const {
      context,
      compilerOption,
      compalition
    } = params;
    if (compilerOption) {
      // 存储build中的文件列表
      const buildPath = _path.default.join(context.projectPath, compilerOption.outputPath);
      const buildFileList = _fsExtra.default.existsSync(buildPath) ? _sharedUtils.FileUtil.readAlldirSync(buildPath).map(filePath => {
        const relativePath = _path.default.relative(buildPath, filePath);
        const fileContent = _fsExtra.default.readFileSync(filePath);
        return {
          path: relativePath,
          content: fileContent
        };
      }) : [];
      if (compalition) {
        compalition.buildFileList = buildFileList;
      }
    }
    context.translateCache = new _TranslateCache.default();
    BinaryPlugin.reset();
    BinaryPlugin.config = {
      projectPath: context.projectPath,
      outputProjectPath: _path.default.join(context.projectPath, context.output),
      source: compilerOption?.sourceRoot,
      output: compilerOption?.outputPath
    };
  };
  /**
   * 获取项目的全局样式变量配置
   * @param context
   */
  static getGlobalVar = params => {
    const {
      context,
      compilerOption
    } = params;
    const {
      projectPath
    } = context;
    const filePath = _path.default.join(projectPath, compilerOption?.sourceRoot || '', 'globalVar.json');
    let globalVar = {};
    // 判断文件是否存在
    if (_fsExtra.default.existsSync(filePath)) {
      // 存在则取内容，否则内容为空
      globalVar = _fsExtra.default.readJSONSync(filePath);
    }
    context.globalVar = globalVar;
    return Promise.resolve();
  };
}
var _default = exports.default = BeforeCompileUtils;