"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _sharedUtils = require("@aiot-toolkit/shared-utils");
var _archiver = _interopRequireDefault(require("archiver"));
var _fsExtra = _interopRequireDefault(require("fs-extra"));
var _path = _interopRequireDefault(require("path"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
class XtsFileLaneUtils {
  /**
   * 将buildPath文件夹的内容压缩成zip包，放置于targetPath路径下
   * @param buildPath
   * @param targetPath
   * @param zipRootDirNames 可自定义压缩包内最外层目录的名称
   */
  static async zipProject(buildPath, targetFile, zipRootDirNames) {
    return new Promise((resolve, reject) => {
      const output = _fsExtra.default.createWriteStream(targetFile);
      const archive = _archiver.default.create('zip', {
        zlib: {
          level: 9
        }
      });
      // 监听错误
      archive.on('error', err => {
        _sharedUtils.ColorConsole.throw(`${err.message}`);
        output.close();
        reject();
      });
      // 监听写入流打开的事件
      output.on('open', () => {
        _sharedUtils.ColorConsole.info(`Write stream is open`);
      });
      output.on('close', () => {
        _sharedUtils.ColorConsole.info(`Write stream is closed`);
        resolve();
      });
      // 将压缩文件导入到输出流中
      archive.pipe(output);

      // 指定压缩目录
      buildPath.forEach((folder, index) => {
        const folderName = _path.default.basename(folder); // 获取文件夹名
        if (zipRootDirNames && zipRootDirNames[index]) {
          archive.directory(folder, zipRootDirNames[index]);
        } else {
          archive.directory(folder, folderName);
        }
      });
      archive.on('finish', () => {
        _sharedUtils.ColorConsole.info('finish');
      });
      // 完成压缩，关闭输出流
      archive.finalize();
    });
  }
}
var _default = exports.default = XtsFileLaneUtils;