"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _sharedUtils = require("@aiot-toolkit/shared-utils");
var _fsExtra = _interopRequireDefault(require("fs-extra"));
var _path = _interopRequireDefault(require("path"));
var _UxFileUtils = _interopRequireDefault(require("./../ux/UxFileUtils"));
var _XtsFileLaneUtils = _interopRequireDefault(require("../../utils/xts/XtsFileLaneUtils"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * XtsFollowWorks
 */
class XtsFollowWorks {
  /**
   * 将项目中build文件夹的内容压缩成zip包，并将压缩产物放到dist文件夹下
   * @param context
   */
  static async defaultZipProject(context, options) {
    const {
      projectPath
    } = context;
    const output = options.tarDir || context.output;
    const buildPath = _path.default.join(projectPath, output);
    const zipPath = _path.default.join(projectPath, 'dist');
    // buildPath必须是真实文件夹路径
    if (!_fsExtra.default.existsSync(buildPath)) {
      _sharedUtils.ColorConsole.throw(`buildPath: '${buildPath}' not exist`);
    }
    try {
      // 确认文件夹是否存在，不存在则创建
      _fsExtra.default.ensureDirSync(zipPath);
      // 清空dist文件夹
      _fsExtra.default.emptyDirSync(zipPath);
      const filePath = XtsFollowWorks.getFilePath(projectPath, 'dist', options.packageName, 'rpk');
      await _XtsFileLaneUtils.default.zipProject([buildPath], filePath, [options.packageName]);
    } catch (err) {
      _sharedUtils.ColorConsole.throw(`${err.message}`);
    }
  }
  /**
   * 将分布式项目按照manifest.json中的配置打包，思路如下：
   * 1. 获取manifest中aspect的路由配置
   * 2. 对aspects中的所有路由信息进行遍历
   * 3. 按照设备（设备+rule）对aspect分类
   * 4. 按照设备列表分别进行打包
   * @param context
   */
  static async zipDistributedQuickApp(context) {
    const deviceList = [{
      device: 'phone',
      aspectList: []
    }];
    const {
      projectPath,
      output
    } = context;
    const manifestPath = _UxFileUtils.default.getManifestFilePath(projectPath, 'app');
    if (_fsExtra.default.existsSync(manifestPath)) {
      //获取manifest.json内容
      const aspectsRule = _fsExtra.default.readJSONSync(manifestPath)?.router?.aspects;
      if (aspectsRule) {
        Object.keys(aspectsRule).forEach(aspectRule => {
          // 分别处理每个aspectRule数组
          for (let item of aspectsRule[aspectRule]) {
            const {
              devices,
              rule,
              path
            } = item;
            // 如果存在设备列表
            if (devices && Array.isArray(devices) && devices.length > 0) {
              for (let device of devices) {
                // 设备名与rule组合为一个设备
                if (rule) {
                  device = `${device}.${rule}`;
                }
                // 查找设备是否已存在于设备列表中
                const index = device === 'phone' ? 0 : deviceList.findIndex(item => item.device === device);
                if (index === -1) {
                  // 新设备
                  deviceList.push({
                    device,
                    aspectList: [path]
                  });
                } else {
                  // 已存在的设备信息时，仅需添加aspect路由
                  deviceList[index].aspectList.push(path);
                }
              }
            } else {
              // 设备值默认值为phone
              deviceList[0].aspectList.push(path);
            }
          }
        });
      }
      const zipPath = _path.default.join(projectPath, 'dist');
      _fsExtra.default.ensureDirSync(zipPath);
      _fsExtra.default.emptyDirSync(zipPath);
      // 根据deviceList进行打包
      for (const item of deviceList) {
        // 所有zip包都需要app信息
        item.aspectList.push('app');
        // 将路由转为真实路径
        const buildPaths = item.aspectList.map(name => _path.default.join(projectPath, output, name));
        const filePath = XtsFollowWorks.getFilePath(projectPath, 'dist', item.device);
        try {
          await _XtsFileLaneUtils.default.zipProject(buildPaths, filePath);
        } catch (error) {}
      }
    } else {
      _sharedUtils.ColorConsole.throw('not find manifest.json');
    }
  }
  /**
   * 根据项目路径，打包文件夹名和传入的压缩包名，生成压缩文件zip路径
   * @param projectPath
   * @param outputDir
   * @param zipName
   * @returns
   */
  static getFilePath(projectPath) {
    let outputDir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'dist';
    let zipName = arguments.length > 2 ? arguments[2] : undefined;
    let ext = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'zip';
    zipName = zipName ? `${zipName}.${ext}` : `${_path.default.basename(projectPath)}.${ext}`;
    const zipPath = _path.default.join(projectPath, outputDir);
    return _path.default.join(zipPath, zipName);
  }
}
var _default = exports.default = XtsFollowWorks;