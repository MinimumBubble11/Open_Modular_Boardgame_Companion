"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.UxFileUtils = void 0;
var _CommonUtil = _interopRequireDefault(require("@aiot-toolkit/shared-utils/lib/utils/CommonUtil"));
var _fsExtra = _interopRequireDefault(require("fs-extra"));
var _path = _interopRequireDefault(require("path"));
var _ManifestSchema = _interopRequireDefault(require("./ManifestSchema"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
* FileUtils
*/
class UxFileUtils {
  static CONFIG_FILE_NAME = 'manifest.json';
  /**
   * 获取manifest.json路径
   * @param projectPath
   * @param sourceRoot
   * @returns
   */
  static getManifestFilePath(projectPath) {
    let sourceRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'src';
    return _path.default.resolve(projectPath, sourceRoot, UxFileUtils.CONFIG_FILE_NAME);
  }
  /**
   * 获取manifest.json内容
   * @param projectPath
   * @param sourceRoot
   * @returns
   */
  static getMainfestInfo(projectPath) {
    let sourceRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'src';
    return _fsExtra.default.readJSONSync(UxFileUtils.getManifestFilePath(projectPath, sourceRoot));
  }

  /**
   * 检查 manifest文件，并显示错误信息
   *
   * 1. 使用ManifestSchema 校验
   *    1. TypeError: Error
   *    2. 其它: Warn
   * 2. 检查 router.entry 是否存在于 router.pages
   *
   * @param projectPath 项目路径
   * @param sourceRoot 源码路径--相对项目根目录
   * @returns
   */
  static validateManifest(projectPath) {
    let sourceRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'src';
    const path = UxFileUtils.getManifestFilePath(projectPath, sourceRoot);
    if (!_fsExtra.default.existsSync(path)) {
      throw new Error(`no such file: '${path}'`);
    }

    // 1
    const jsonData = this.getMainfestInfo(projectPath, sourceRoot);
    const schema = _ManifestSchema.default;
    const errors = _CommonUtil.default.validateJson(jsonData, schema) || [];

    // 2
    const {
      entry,
      pages
    } = jsonData.router;
    if (!pages[entry]) {
      errors.push(new TypeError(`router.entry content:  ${entry}, is missing in router.pages`));
    }
    if (errors?.length) {
      const message = `Manifest.json error: ${errors.map((item, index) => {
        return `\r\n${index + 1}. ${item.message}`;
      })}`;
      throw new Error(message);
    }
  }

  /**
   * 检查 sitemap.json 文件，并显示错误信息
   *
   * 1. 当sitemap.json的 rules 中配置的page 不存在于 manifest.json 中时，报错
   * @param projectPath
   * @param sourceRoot
   */
  static validateSitemap(projectPath) {
    let sourceRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'src';
    const sitemapPath = _path.default.join(projectPath, sourceRoot, 'sitemap.json');
    if (_fsExtra.default.existsSync(sitemapPath)) {
      const rules = _fsExtra.default.readJSONSync(sitemapPath).rules;
      const manifest = this.getMainfestInfo(projectPath, sourceRoot);
      const pages = Object.keys(manifest.router.pages || {});
      const errorList = [];
      rules.forEach((item, index) => {
        const page = item.page;
        if (page !== '*' && !pages.includes(page)) {
          errorList.push(`The ${index + 1}th item of sitemap rules is configured incorrectly, the page ${page} does not exist`);
        }
      });
      if (errorList.length) {
        throw new Error(errorList.join('\r\n'));
      }
    }
  }
  /**
   * 1. 遍历旧文件列表
   *  1.1 若文件路径在新文件列表newFileList中，且内容一致时，从newFileList中移除该项
   *  1.2 若文件路径在新文件列表newFileList中，且内容不一致时，添加到diffList中表示待更新，从newFileList中移除该项
   *  1.3 若文件路径不在新文件列表中，表示该文件待删除(热更新时，可以不做删除，删除耗费性能)
   * 2. 若遍历完旧文件列表后，newFileList长度不为0，表示有文件待新增
   * @param oldFileList 旧文件列表
   * @param newFileList 新文件列表
   * @returns
   */
  static getDiffJSON(compilation, newFileList, buildPath) {
    const oldFileList = compilation.buildFileList;
    if (!oldFileList.length) {
      return [];
    }
    let diffList = [];
    // 1.
    for (let i = 0; i < oldFileList.length; i++) {
      const index = newFileList.findIndex(file => file === oldFileList[i].path);
      // 1.3
      if (index !== -1) {
        // 1.2
        const oldContent = oldFileList[i].content?.toString('utf-8');
        const newContent = _fsExtra.default.readFileSync(_path.default.join(buildPath, newFileList[index]), 'utf-8');
        if (oldContent !== newContent) {
          diffList.push(newFileList[index]);
        }
        // 从newFileList中移除该项
        newFileList.splice(index, 1);
      }
    }
    // 2.
    newFileList.length > 0 && newFileList.forEach(file => diffList.push(file));
    return diffList;
  }
}
exports.UxFileUtils = UxFileUtils;
var _default = exports.default = UxFileUtils;