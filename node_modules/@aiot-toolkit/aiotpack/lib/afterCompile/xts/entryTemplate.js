"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateEntryFile = exports.entryTemplate = exports.XtsEntryFileName = void 0;
var _parser = require("@aiot-toolkit/parser");
var _sharedUtils = require("@aiot-toolkit/shared-utils");
var _fsExtra = _interopRequireDefault(require("fs-extra"));
var _path = _interopRequireDefault(require("path"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const entryTemplate = options => {
  const {
    aspects = []
  } = options;
  function generatImportAspects() {
    if (!aspects) return '';
    let imports = '// import aspects\n';
    for (let i = 0; i < aspects.length; i++) {
      const aspect = aspects[i];
      imports += `import AspectClass${i + 1} from './${aspect.path}'\n`;
      const {
        routes = []
      } = aspect;
      for (let r = 0; r < routes?.length; r++) {
        const route = routes[r];
        imports += `import Page${i + 1}_${r + 1}, { ${_parser.HomeState.interface} as ${_parser.HomeState.interface}${i + 1}_${r + 1}_ } from './${route.importPath}'\n`;
      }
    }
    return imports;
  }
  function generateDefs() {
    let res = '// aspects\n';
    for (let i = 0; i < aspects.length; i++) {
      const aspect = aspects[i];
      const {
        routes = []
      } = aspect;
      res += `
  const aspectName_${i + 1} = '${aspect.name}'
  const pathPages_${i + 1} = new Map()`;
      for (let r = 0; r < routes.length; r++) {
        const route = routes[r];
        res += `
  pathPages_${i + 1}.set('${route.route}', function (params?: ${_parser.HomeState.interface}${i + 1}_${r + 1}_): Page {
    return new Page${i + 1}_${r + 1}(params)
  })
        `;
      }
      res += `
  const aspectDef_${i + 1}: AspectDefinition = {
    newFn: (): ViewAspect => new AspectClass${i + 1}(),
    pathPages: pathPages_${i + 1}
  } 
  aspectDefs.set(aspectName_${i + 1}, aspectDef_${i + 1})
      `;
    }
    return res;
  }
  return `import {
  // class
  App,
  AppDefinition,
  AppContainer,
  AspectDefinition,
  ViewAspect,
  Page,
  Route,
  RouteInfo,
  // framework
  context,
  getInfoFromRoute,

  // export function
  on
} from '../node_modules/${_parser.tsFrameWork.name}/index'

// import app
import AppClass from './${options.appPath}'
${generatImportAspects()}
console.log('startApp-start timeEnd:', Date.now())

function getAspectDefs() {
  const aspectDefs = new Map()
  ${generateDefs()}
  return aspectDefs
}

function entry(path: string): void {
  console.log('~~~~~~~~~entry path', path)
  const route: Route = { uri: path }
  const routeInfo: RouteInfo = getInfoFromRoute(route)
  // app
  let appName: string = ''
  if (routeInfo?.appName) appName = routeInfo.appName
  let app = context.getApp(appName)
  if (app === null) {
    const appDef: AppDefinition = {
      newFn: (): App => new AppClass()
    }
    const aspectDefs = getAspectDefs()
    app = new AppContainer(appDef, aspectDefs)
  }
  context.openApp(app, routeInfo)
}

// export api to native
export { entry, on }
`;
};
exports.entryTemplate = entryTemplate;
function getManifest(manifestPath) {
  const content = _fsExtra.default.readFileSync(manifestPath, 'utf-8');
  const data = JSON.parse(content);
  return data;
}
const XtsEntryFileName = exports.XtsEntryFileName = '__entry__.ts';
/**
 * 生成 __entry__.ts 文件
 * @param context
 */
const generateEntryFile = exports.generateEntryFile = async function generateEntryFile(params) {
  const {
    context,
    compilerOption
  } = params;
  const {
    projectPath,
    output
  } = context;
  if (compilerOption?.skip?.includes('xts2ts')) {
    _sharedUtils.ColorConsole.info(`### skip generate entry file due to --skip xts2ts}`);
    return;
  }
  _sharedUtils.ColorConsole.info(`Generating entry file`);
  const buildDir = _path.default.resolve(projectPath, output);
  const appManifestPath = _path.default.join(buildDir, 'app', 'manifest.json');
  const appManifest = getManifest(appManifestPath);
  if (!appManifest) {
    _sharedUtils.ColorConsole.throw('not find app/manifest.json file !');
  }
  const appTs = _path.default.join(buildDir, 'app', 'app.ts');
  if (!_fsExtra.default.existsSync(appTs)) {
    _sharedUtils.ColorConsole.throw('not find app/app.ts file !');
  }
  function relativeDist(tar) {
    return _path.default.join('.', _path.default.relative(buildDir, tar)).replace(_path.default.sep, '/');
  }
  let opt = {
    appPath: relativeDist(appTs.replace('.ts', '')),
    aspects: []
  };
  function getAspectRoutes(aspectPath) {
    const aspectManifestPath = _path.default.join(aspectPath, 'src', 'manifest.json');
    const aspectManifest = getManifest(aspectManifestPath);
    if (!aspectManifest?.router?.pages) return [];
    return Object.entries(aspectManifest.router.pages).map(_ref => {
      let [k, v] = _ref;
      return {
        importPath: relativeDist(_path.default.resolve(_path.default.dirname(aspectManifestPath), v.path)),
        name: k,
        route: v.path
      };
    });
  }
  if (appManifest?.router?.aspects) {
    Object.entries(appManifest.router.aspects).forEach(_ref2 => {
      let [name, aspects] = _ref2;
      aspects.forEach(aspect => {
        const aspectPath = _path.default.join(buildDir, aspect.path);
        opt.aspects?.push({
          name: name,
          path: relativeDist(_path.default.resolve(buildDir, aspect.path, 'src', 'aspect')),
          routes: getAspectRoutes(aspectPath)
        });
      });
    });
  }
  const template = entryTemplate(opt);
  _fsExtra.default.writeFileSync(_path.default.join(projectPath, output, XtsEntryFileName), template);
  _sharedUtils.ColorConsole.info(`entry file built`);
};