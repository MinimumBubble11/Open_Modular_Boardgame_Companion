"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _sharedUtils = require("@aiot-toolkit/shared-utils");
var _fsExtra = _interopRequireDefault(require("fs-extra"));
var _lodash = _interopRequireDefault(require("lodash"));
var _path = _interopRequireDefault(require("path"));
var _CompileMode = _interopRequireDefault(require("../../compiler/enum/CompileMode"));
var _JavascriptCompiler = _interopRequireDefault(require("../../compiler/javascript/JavascriptCompiler"));
var _JavascriptDefaultCompileOption = _interopRequireDefault(require("../../compiler/javascript/JavascriptDefaultCompileOption"));
var _Jsc = _interopRequireDefault(require("../../compiler/javascript/vela/utils/Jsc"));
var _ZipUtil = _interopRequireDefault(require("../../compiler/javascript/vela/utils/ZipUtil"));
var _UxFileUtils = _interopRequireDefault(require("../../utils/ux/UxFileUtils"));
var _FileLaneTriggerType = _interopRequireDefault(require("file-lane/lib/enum/FileLaneTriggerType"));
var _ZipFileUtil = _interopRequireDefault(require("@aiot-toolkit/shared-utils/lib/utils/ZipFileUtil"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const BinaryPlugin = require('@aiot-toolkit/parser/lib/ux/translate/vela/protobuf/BinaryPlugin');

/**
 * UxAfterCompile
 */
class UxAfterCompile {
  static webpack = async params => {
    const {
      context,
      compilerOption
    } = params;
    return new _JavascriptCompiler.default().compile({
      projectPath: _path.default.join(context.projectPath, context.output),
      mode: _CompileMode.default.DEVELOPMENT,
      devtool: false,
      platform: 'vela',
      ..._JavascriptDefaultCompileOption.default,
      ...compilerOption
    }).then(() => {
      _sharedUtils.ColorConsole.info(`webpack complete`);
    }).catch(_ref => {
      let {
        errors,
        warnings
      } = _ref;
      const errorLength = errors?.length || 0;
      const messages = [`webpack error:\r\n`];
      if (errors?.length) {
        messages.push({
          word: errors.map((item, index) => {
            return `${index + 1}. ${item.message}`;
          }).join('\r\n'),
          style: _sharedUtils.ColorConsole.getStyle(_sharedUtils.Loglevel.THROW)
        });
      }
      if (warnings?.length) {
        messages.push({
          word: warnings.map((item, index) => {
            return `${errorLength + index + 1}. ${item.message}`;
          }).join('\r\n'),
          style: _sharedUtils.ColorConsole.getStyle(_sharedUtils.Loglevel.WARN)
        });
      }
      if (errors?.length) {
        _sharedUtils.ColorConsole.throw(...messages);
        throw new Error();
      } else {
        _sharedUtils.ColorConsole.warn(...messages);
      }
    });
  };
  static protobuf = async params => {
    const {
      compilerOption
    } = params;
    if (compilerOption?.enableProtobuf) {
      BinaryPlugin.createBinFiles();
    }
  };
  static jsc = async params => {
    const {
      context,
      compilerOption
    } = params;
    if (compilerOption && compilerOption.enableJsc === true) {
      return new _Jsc.default(context.projectPath, _path.default.join(context.projectPath, context.output, compilerOption.outputPath)).jsc();
    }
  };
  static toRpk = async params => {
    const {
      compilerOption,
      compalition,
      config
    } = params;
    if (compilerOption) {
      const fileName = await _ZipUtil.default.createRpk(_path.default.join(compilerOption.projectPath, compilerOption.outputPath), compilerOption);
      if (compalition && fileName) {
        compalition.info.rpk = _path.default.join(config.projectPath, compilerOption.releasePath, fileName);
      }
      return fileName;
    }
  };

  /**
   * 复制各类资源文件，例如图片、视频等
   * @param context
   * @param config
   * @param compilerOption
   */
  static copyResource = async params => {
    const {
      context,
      compilerOption
    } = params;
    const genDeviceManifests = compilerOption => {
      const {
        projectPath,
        sourceRoot,
        outputPath
      } = compilerOption;
      const manifest = _fsExtra.default.readJSONSync(_path.default.join(projectPath, sourceRoot, 'manifest.json'));
      const {
        deviceTypeList
      } = manifest;
      // 生成设备的 manifest 文件，规则为：manifest.json + config-设备类型.json
      if (deviceTypeList) {
        deviceTypeList.forEach(deviceType => {
          let data = {
            ...manifest
          };
          const deviceConfigPath = _path.default.join(projectPath, sourceRoot, `config-${deviceType}.json`);
          if (_fsExtra.default.existsSync(deviceConfigPath)) {
            const deviceJson = _fsExtra.default.readJSONSync(deviceConfigPath);
            data = _lodash.default.merge({}, data, deviceJson);
          }
          const buildPath = _path.default.join(projectPath, outputPath, `manifest-${deviceType}.json`);
          _fsExtra.default.writeFileSync(buildPath, JSON.stringify(data, undefined, 2));
        });
      }
    };
    const copyResourceFiles = compilerOption => {
      // 复制除 js/jsx/ts/tsx/json 外，但是包含manifest.json、sitemap.json的文件
      const {
        projectPath,
        sourceRoot,
        outputPath
      } = compilerOption;
      const includeList = [/sitemap\.json$/, /i18n(.+)\.json/];
      const excludeExtList = ['js', 'jsx', 'coffee', 'ts', 'tsx', 'vue', 'css', 'less', 'sass', 'styl', 'html', 'md', 'ux', 'mix', 'DS_Store', 'map'];
      const excludeReg = `\\.(${excludeExtList.join('|')})$`;
      _sharedUtils.FileUtil.copyFiles(_path.default.join(projectPath, sourceRoot), _path.default.join(projectPath, outputPath), new RegExp(excludeReg));
      _sharedUtils.FileUtil.copyFiles(_path.default.join(projectPath, sourceRoot), _path.default.join(projectPath, outputPath), undefined, includeList);
    };

    /**
     * 写入 manifest.json 文件
     *
     * 需要在源码manifest.json基础加一些额外的内容
     * @param compilerOption
     */
    const updateManifest = compilerOption => {
      const {
        projectPath,
        sourceRoot,
        outputPath,
        completeFeature
      } = compilerOption;
      const content = _UxFileUtils.default.getMainfestInfo(projectPath, sourceRoot);
      const translateCache = context.translateCache;
      if (!content.minAPILevel) {
        content.minAPILevel = 1;
      }
      if (!content.packageInfo) {
        content.packageInfo = _ZipUtil.default.createComment(compilerOption);
      }
      if (completeFeature && translateCache?.featureCache.size) {
        const featureSet = new Set([...Array.from(translateCache.featureCache), ...(content.features || []).map(item => item.name)]);
        content.features = Array.from(featureSet).map(item => {
          return {
            name: item
          };
        });
      }
      _fsExtra.default.writeJSONSync(_path.default.join(projectPath, outputPath, _UxFileUtils.default.CONFIG_FILE_NAME), content, {
        spaces: 2
      });
    };
    const genMetaFiles = async compilerOption => {
      const {
        projectPath,
        outputPath,
        sourceRoot
      } = compilerOption;
      const outputAbsPath = _path.default.join(projectPath, outputPath);
      const comment = _ZipUtil.default.createComment(compilerOption);

      // build.txt
      const content = Object.keys(comment).map(key => `${key}=${comment[key]}`).join('\n');
      _fsExtra.default.outputFileSync(_path.default.join(outputAbsPath, _ZipUtil.default.BUILD_FILE_PATH), content);
      // cert
      const files = _ZipUtil.default.getSortedFiles(outputAbsPath, compilerOption, _UxFileUtils.default.getMainfestInfo(projectPath, sourceRoot));
      const digestDic = Object.fromEntries(files.map(item => [item, _sharedUtils.CommonUtil.calcDataDigest(_fsExtra.default.readFileSync(_path.default.join(outputAbsPath, item))).toString('hex')]));
      const hashJson = [{
        path: _ZipUtil.default.DIGEST_HASH_JSON,
        content: JSON.stringify({
          algorithm: 'SHA-256',
          digests: digestDic
        })
      }];
      const buffer = await _ZipUtil.default.createZipBufferFromFileList(hashJson, JSON.stringify(comment));
      _fsExtra.default.outputFileSync(_path.default.join(outputAbsPath, _ZipUtil.default.CERT_PATH), buffer);
    };
    if (compilerOption) {
      await copyResourceFiles(compilerOption);
      await updateManifest(compilerOption);
      await genDeviceManifests(compilerOption);
      await genMetaFiles(compilerOption);
    }
  };
  /**
   * 如果是更新触发，则对比临时项目build文件夹 和 项目build文件夹，生成diff.json
   * @param context
   * @param config
   * @param compilerOption
   */
  static generateDiff = async params => {
    const {
      compilerOption,
      compalition,
      config
    } = params;
    if (!compilerOption || !compalition) {
      return;
    }
    if (compalition.trigger === _FileLaneTriggerType.default.START) {
      return;
    }
    const {
      outputPath,
      projectPath
    } = compilerOption;
    // 读取临时项目build文件夹中所有文件路径
    const tempBuildPath = _path.default.join(projectPath, outputPath);
    // 待优化，map文件跟随源文件变化，与时间戳有关文件无需对比
    const tempFileList = _sharedUtils.FileUtil.readAlldirSync(tempBuildPath).map(filePath => _path.default.relative(tempBuildPath, filePath));
    const diffList = _UxFileUtils.default.getDiffJSON(compalition, tempFileList, tempBuildPath);

    // 所有差异文件，压缩到 .diff.rpk 中
    if (diffList?.length) {
      const buildFold = _path.default.join(compilerOption.projectPath, compilerOption.outputPath);
      const distFold = _path.default.join(compilerOption.projectPath, compilerOption.releasePath);
      const diffFileName = `.diff.rpk`;
      const diffPath = _path.default.join(distFold, diffFileName);
      await _ZipFileUtil.default.createZipFile(diffPath, diffList.map(item => ({
        filePath: _path.default.join(buildFold, item),
        zipFilePath: item
      })));
      compalition.info.diffList = diffList;
      compalition.info.diffFile = _path.default.join(config.projectPath, compilerOption.releasePath, diffFileName);
    }
  };

  /**
   * 打包结果移回源码项目，并删除中间项目
   *
   * 1. 把 build和rpk 目录从**中间项目**移回**源码项目**
   * 2. 删除中间项目
   * @param context
   * @param config
   * @param compilerOption
   */
  static moveBackResult = async params => {
    const {
      context,
      compilerOption
    } = params;
    if (!compilerOption) {
      return;
    }
    const {
      outputPath,
      releasePath,
      projectPath
    } = compilerOption;
    const {
      projectPath: orgProjectPath
    } = context;
    const targetList = [{
      from: _path.default.join(projectPath, outputPath),
      to: _path.default.join(orgProjectPath, outputPath)
    }, {
      from: _path.default.join(projectPath, releasePath),
      to: _path.default.join(orgProjectPath, releasePath)
    }];
    targetList.forEach(item => {
      _fsExtra.default.removeSync(item.to);
      _fsExtra.default.moveSync(item.from, item.to, {
        overwrite: true
      });
    });
  };

  /**
   * 创建 node_module 软链
   * @param context
   * @param config
   * @param compilerOption
   */
  static symlinkNodeModule = async params => {
    const {
      context,
      compilerOption
    } = params;
    if (!compilerOption) {
      return;
    }
    try {
      const foldList = ['node_modules'];
      foldList.forEach(item => {
        const sourcePath = _path.default.join(context.projectPath, item);
        const targetPath = _path.default.join(compilerOption.projectPath, item);
        if (_fsExtra.default.existsSync(sourcePath) && !_fsExtra.default.existsSync(targetPath)) {
          _fsExtra.default.symlinkSync(sourcePath, targetPath, 'junction');
        }
      });
    } catch (error) {
      throw new Error(`${error?.toString() || 'unknown error'}. Please check whether the file system of the current disk supports the creation of soft links.`);
    }
  };
}
var _default = exports.default = UxAfterCompile;