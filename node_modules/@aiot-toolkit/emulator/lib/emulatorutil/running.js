"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fileNamePattern = exports.defaultDirRelativePath = void 0;
exports.getEmulatorDefaultConfigDir = getEmulatorDefaultConfigDir;
exports.getPlatform = getPlatform;
exports.getRunningAvdConfig = getRunningAvdConfig;
exports.getRunningAvdConfigByName = getRunningAvdConfigByName;
exports.getRunningAvdConfigFiles = getRunningAvdConfigFiles;
exports.getRunningVvdDebugPort = getRunningVvdDebugPort;
exports.getRunningVvds = getRunningVvds;
var _os = _interopRequireDefault(require("os"));
var _fs = _interopRequireDefault(require("fs"));
var _ini = _interopRequireDefault(require("ini"));
var _path = _interopRequireDefault(require("path"));
var _adb = require("@miwt/adb");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const defaultDirRelativePath = exports.defaultDirRelativePath = 'avd/running';
const fileNamePattern = exports.fileNamePattern = /pid_\d+\.ini/;
function getPlatform() {
  const platform = _os.default.platform();
  return platform === 'darwin' ? 'darwin' : platform === 'win32' ? 'win32' : 'linux';
}

/**
 * Returns the Emulator registration directory.
 */
function computeRegistrationDirectoryContainer() {
  const platform = getPlatform();
  switch (platform) {
    case 'darwin':
      return resolvePath(_path.default.join(_os.default.homedir(), 'Library', 'Caches', 'TemporaryItems'));
    case 'win32':
      return resolvePath(_path.default.join(process.env.LOCALAPPDATA, 'Temp'));
    default:
      return resolveLinuxPath();
  }
}

/**
 * @returns 获取模拟器配置文件目录
 */
function getEmulatorDefaultConfigDir() {
  const dir = computeRegistrationDirectoryContainer();
  if (!dir) {
    throw new Error('Unable to determine Emulator registration directory');
  }
  return _path.default.join(dir, defaultDirRelativePath);
}
function resolveLinuxPath() {
  const linuxPatterns = [process.env.XDG_RUNTIME_DIR, `/run/user/${process.env.UID}`, _path.default.join(_os.default.homedir(), '.android')];
  for (const pattern of linuxPatterns) {
    if (!pattern) continue;
    const dir = resolvePath(pattern);
    if (dir && _fs.default.existsSync(dir) && _fs.default.lstatSync(dir).isDirectory()) {
      return dir;
    }
  }
  return resolvePath(_path.default.join(_os.default.tmpdir(), `android-${_os.default.userInfo().username}`));
}
function resolvePath(filePath) {
  if (!filePath) {
    return null;
  }

  // Replace environment variables in the filePath
  filePath = filePath.replace(/{(\w+)}/g, (match, key) => {
    return process.env[key] || match;
  });
  return _path.default.resolve(filePath);
}
function getRunningAvdConfigFiles() {
  const dir = getEmulatorDefaultConfigDir();
  try {
    const files = _fs.default.readdirSync(dir);
    return files.filter(t => fileNamePattern.test(t)).map(t => _path.default.join(dir, t));
  } catch (error) {
    return [];
  }
}
function getRunningAvdConfig() {
  const file = getRunningAvdConfigFiles();
  const result = [];
  file.forEach(f => {
    result.push({
      ..._ini.default.parse(_fs.default.readFileSync(f, 'utf-8')),
      path: f
    });
  });
  return result;
}
async function getRunningVvds() {
  const config = getRunningAvdConfig();
  // running 文件中的数据可能会因为上次模拟器未正常退出而残留，所以需要过滤一下
  const adbDevices = await (0, _adb.getAdbDevices)();
  return config.filter(c => adbDevices.some(e => e.sn === `emulator-${c['port.serial']}` && e.status === 'device'));
}
function getRunningAvdConfigByName(name) {
  const config = getRunningAvdConfig();
  return config.find(t => t['avd.name'] === name);
}
function getRunningVvdDebugPort(name) {
  const e = getRunningAvdConfigByName(name);
  const regex = /hostfwd=tcp:(.*?):(\d+)-10\.0\.2\.15:101/;
  return e?.cmdline?.match(regex)?.[2];
}