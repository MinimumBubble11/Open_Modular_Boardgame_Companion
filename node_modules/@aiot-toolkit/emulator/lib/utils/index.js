"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.delayRun = delayRun;
exports.getEvenPort = getEvenPort;
exports.getSystemArch = getSystemArch;
exports.killProcessByCmd = killProcessByCmd;
exports.killProcessByPid = killProcessByPid;
exports.sleep = sleep;
exports.tryRun = tryRun;
var _ColorConsole = _interopRequireDefault(require("@aiot-toolkit/shared-utils/lib/ColorConsole"));
var _child_process = require("child_process");
var _findProcess = _interopRequireDefault(require("find-process"));
var _os = _interopRequireDefault(require("os"));
var _semver = _interopRequireDefault(require("semver"));
var _portfinder = _interopRequireDefault(require("portfinder"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const cpuArch = {
  arm64: 'aarch64',
  aarch64: 'aarch64',
  x64: 'x86_64',
  x86_64: 'x86_64'
};

/** 获取mac电脑的CPU架构
 * node 15.0.0之后，m1芯片的mac的os.arch()才是arm64，在这之前都是x86
 * 所以15.0.0之前无法通过os.arch()区分，也无法通过execSync('uname -m')区分
 */
function getSystemArch() {
  const platform = _os.default.platform();
  let osArch = _os.default.arch();
  const nodeVersion = process.version;
  if (_semver.default.lt(nodeVersion, '15.0.0') && platform === 'darwin') {
    try {
      (0, _child_process.execSync)('sysctl -n sysctl.proc_translated');
      osArch = 'arm64';
    } catch {
      osArch = 'x64';
    }
  }
  if (osArch !== 'arm64' && osArch !== 'x64') {
    return _ColorConsole.default.throw(`unsupport system`);
  }
  return cpuArch[osArch];
}

/** 根据PID杀死进程 */
function killProcessByPid(pid) {
  try {
    const cmd = _os.default.platform() === 'win32' ? `taskkill /pid ${pid} /T /F` : `kill -9 ${pid}`;
    (0, _child_process.execSync)(cmd);
  } catch (e) {
    console.error(`kill process ${pid} get error: ${e}`);
  }
}

/**
 * 根据命令杀死进程
 */
async function killProcessByCmd(cmd) {
  if (!cmd) return;
  try {
    const list = await (0, _findProcess.default)('name', cmd);
    list.forEach(async item => {
      killProcessByPid(item.pid.toString());
    });
  } catch (e) {
    console.error(`kill process ${cmd} get error: ${e}`);
  }
}

/** 延迟函数 */
async function sleep(time) {
  return new Promise(resolve => setTimeout(resolve, time));
}

/**
 * 重复执行某个任务直到成功，或者超过最大次数
 * @param task 任务，需要返回 bool 值表示是否执行成功
 * @param {Number=} maxCount 最大重试次数
 * @param {number=} duration 每次重试的间隔
 */
async function tryRun(task) {
  let maxCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;
  let duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;
  let currentCount = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  if (currentCount > maxCount) return false;
  return Boolean(await task()) || (await delayRun(() => tryRun(task, maxCount, duration, currentCount + 1), duration));
}

/**
 * 延迟执行某个任务
 * @param task
 * @param duration
 * @returns
 */
async function delayRun(task) {
  let duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
  return new Promise(resolve => {
    setTimeout(async () => {
      return resolve(task());
    }, duration);
  });
}

/**
 * 为avdPort寻找一个不被占用的端口
 * 端口号必须是偶数且在5555和5585之间
 * @returns {number}
 */
async function getEvenPort() {
  const startPort = 5556;
  const stopPort = 5584;
  let index = 1;
  let port = await _portfinder.default.getPortPromise({
    port: startPort,
    stopPort
  });
  while (port % 2 !== 0) {
    if (index > 13) return false;
    port = await _portfinder.default.getPortPromise({
      port: startPort + 2,
      stopPort
    });
    index++;
  }
  return port;
}